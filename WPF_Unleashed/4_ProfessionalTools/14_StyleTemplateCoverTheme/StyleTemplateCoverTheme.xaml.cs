using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._4_ProfessionalTools._14_StyleTemplateCoverTheme
{
    /// <summary>
    /// Interaction logic for StyleTemplateCoverTheme.xaml
    /// </summary>
    public partial class StyleTemplateCoverTheme : Window
    {
        public StyleTemplateCoverTheme()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Styles window = new Styles();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Templates window = new Templates();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            Cover window = new Cover();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            Themes window = new Themes();
            window.Show();
        }
    }

    // мы расскажем о четырех краеугольных камнях, на которых покоится поддержка стилизации в WPF:
    // - Стили – простой механизм отделения значений свойств от элементов пользовательского интерфейса (аналогичный взаимоотношениям CSS и HTML).
    // Стили также лежат в основе других механизмов, описанных в этой главе.
    // - Шаблоны – наделенные широкими возможностями объекты, которые обычно имеют в виду, говоря о «модификации внешнего вида» в WPF.
    // - Обложки – специфические для конкретного приложения коллекции стилей и/или шаблонов, которые обычно можно динамически заменять.
    // - Темы – визуальные характеристики операционной системы, которые потенциально могут настраиваться пользователем.
    // FAQ
    // Зачем WPF позволяет полностью изменять внешний вид стандартных элементов управления? Ведь несогласованность между разными приложениями только запутывает пользователей!
    // Философия WPF заключается в том, что разнообразие выразительных средств приложения должно быть ограничено только навыками его проектировщиков, а не лежащей в основе платформой.
    
    // Стили
    // Стиль – объект, представленный классом System.Windows.Style, – довольно простая штука. 
    // Его основная задача – сгруппировать значения свойств, которые в противном случае пришлось бы задавать по отдельности.
    // А конечная цель – предоставить эту группу в распоряжение нескольких элементов.
    // Стили удобны по нескольким причинам, в частности потому, что если вы передумаете поворачивать кнопки или захотите поменять цвет фона, то изменения придется вносить только в одном месте.
    // А определение стиля в виде ресурса дает вам всю гибкость механизма ресурсов.
    // Например, можно определить один вариант стиля buttonStyle на уровне приложения, а в коллекции Resources конкретного окна Window переопределить его по-другому (сохранив все тот же ключ buttonStyle).
    // СОВЕТ
    // Стили могут также наследовать один другому! Так, следующий элемент Style добавляет полужирное начертание к стилю buttonStyle.
    // Делается это с помощью свойства BasedOn, определяющего стиль, на котором основан данный.

    // Обобществление стилей
    // Совместное использование разнородными элементами
    // Мы заменили Button на Control
    // Можно не беспокоиться о том, что стиль будет применен к элементу, у которого нет каких-то свойств зависимости, определенных в стиле; они будут просто проигнорированы.
    // Например, у элемента InkCanvas нет свойств Foreground и FontSize.
    // И тем не менее в результате применения к нему стиля, все имеющиеся у InkCanvas свойства (Background, Height, Width и т. д.) устанавливаются правильно.
    // КОПНЕМ ГЛУБЖЕ
    // Странное (но правильное) поведение Setter
    // Если несколько типов владеют одним и тем же свойством зависимости, то не имеет значения, имя какого типа указано в Setter.Property, важно лишь, чтобы это было имя одного из владельцев. 
    // Мой совет – избегайте всех этих недоразумений и создавайте разные стили для различных типов.
    // СОВЕТ
    // Любой элемент может переопределить свойства, заданные в его стиле, напрямую присвоив свойству локальное значение.
    // Локальные значения более приоритетны, чем унаследованные от стиля
    // СОВЕТ
    // Чтобы обеспечить совместное использование значений составных свойств даже внутри стиля, в классе Style имеется собственное свойство Resources.
    // Этой коллекцией можно воспользоваться, чтобы сделать стиль полностью самодостаточным, а не создавать потенциально хрупкую зависимость от ресурсов, определенных где-то в другом месте.

    // Ограничение применимости стилей
    // Если требуется, чтобы стиль мог применяться только к какому-то одному конкретному типу, то можно установить свойство TargetType. 
    // При любой попытке применить этот стиль к элементу, отличному от Button, компилятор выдаст ошибку.
    // Таким образом, если для стиля установить свойство TargetType="{x:Type Control}", то он будет работать для всех элементов, кроме InkCanvas.
    // Кроме того, если в стиле установлено свойство TargetType, то уже нет необходимости указывать имя типа в качестве префикса имени свойства внутри элементов Setter. 
    
    // Создание неявных стилей
    // Задание свойства TargetType для стиля дает еще одну возможность. 
    // Если опустить атрибут Key, то стиль будет неявно применяться ко всем элементам указанного типа в той же области видимости.
    // Обычно такой стиль называют типизированным, в отличие от именованных стилей, с которыми мы встречались до сих пор.
    // Область видимости стиля определяется местоположением ресурса Style.
    // Например, если он находится в коллекции Window.Resources, то будет неявно применяться ко всем подходящим элементам в данном окне Window.
    // А ресурс, определенный на уровне приложения, как показано в следующем листинге, применяется ко всему приложению.
    // <Application ...>
    // <Application.Resources>
    // <Style TargetType="{x:Type Button}">
    // <Setter Property="FontSize" Value="22"/>
    // <Setter Property="Background" Value="Purple"/>
    // <Setter Property="Foreground" Value="White"/>
    // <Setter Property="Height" Value="50"/>
    // <Setter Property="Width" Value="50"/>
    // <Setter Property="RenderTransformOrigin" Value=".5,.5"/>
    // <Setter Property="RenderTransform">
    // <Setter.Value>
    // <RotateTransform Angle="10"/>
    // </Setter.Value>
    // </Setter>
    // </Style>
    // </Application.Resources>
    // </Application>
    // Чтобы восстановить стиль кнопки, подразумеваемый по умолчанию, следует записать в ее свойство Style значение null.
    // КОПНЕМ ГЛУБЖЕ
    // Какая магия стоит за ресурсами без ключей?
    // Возможно, вам любопытно, как стиль может входить в словарь ResourceDictionary, не имея ключа.
    // На самом деле ключ у него есть – только неявный. 
    // И в качестве неявного ключа выступает значение свойства TargetType (то есть объект класса Type, а не строка).
    // Чтобы явно обратиться к стилю без ключа, для которого TargetType равно Button, можно было бы написать:
    // <Button Style="{StaticResource {x:Type Button}}" .../>
    // Для каждого значения TargetType в словаре ResourceDictionary можно определить только один стиль без ключа, иначе возникнет ошибка с сообщением о попытке создать дубликат ключа в одном словаре.
    // Объекты Style ведут себя таким образом потому, что этот класс помечен следующим атрибутом:
    // [DictionaryKeyProperty("TargetType")]
    // Атрибутом DictionaryKeyPropertyAttribute можно помечать одно из свойств класса, которое будет выступать в роли поставщика ключа по умолчанию, когда экземпляр класса помещается в некоторый словарь.
    // ПРЕДУПРЕЖДЕНИЕ
    // Типизированный стиль применяется строго к элементам типа, указанного в свойстве TargetType!
    // СОВЕТ
    // Стили можно применять в разных местах. Например, у всех элементов управления, производных от FrameworkElement или FrameworkContentElement, имеется свойствоFocusVisualStyle помимо свойства Style.
    // Стиль, записанный в свойство FocusVisualStyle, активен в случае, когда элемент владеет фокусом; это очень удобно, когда хочется переопределить стандартную пунктирную прямоугольную рамочку, обозначающую фокус (которая может выглядеть чужеродно, если стиль самого элемента управления был радикально изменен).
    // В некоторых элементах управления есть еще и дополнительные места для подключения стилей. 
    // Так, в классе ItemsControl определено свойство ItemContainerStyle, которое применяется к контейнеру каждого объекта (например, ListBoxItem или ComboBoxItem).
    // В других классах, скажем в ToolBar, имеются свойства вида ResourceKey, представляющие ключи некоторых внутренних стилей, например  ButtonStyleKey и TextBoxStyleKey.
    // Хотя сами свойства XXXStyleKey допускают только чтение, никто не мешает вам создать собственный стиль с таким ключом и тем самым переопределить стандартный стиль.
    // <Application ...>
    // <Application.Resources>
    // <Style x:Key="{x:Static ToolBar.ButtonStyleKey}" TargetType="{x:Type Button}">
    // ...
    // </Style>
    // </Application.Resources>
    // </Application>

    // Триггеры
    // У триггеров, тоже есть коллекция элементов Setter – такая же, как у стилей (и/или коллекции действий TriggerAction).
    // Но если стиль применяет заданные в нем значения свойств безусловно, то работа триггера зависит от одного или нескольких условий.
    // Напомним, что существует три типа триггеров:
    // - Триггеры свойств – вызываются при изменении значения свойства зависимости.
    // - Триггеры данных – вызываются при изменении значения  обычного свойства .NET. 
    // - Триггеры событий – вызываются при возникновении маршрутизируемого события.
    // В каждом из классов FrameworkElement, Style, DataTemplate и ControlTemplate имеется коллекция Triggers, но если классы стилей и шаблонов принимают триггеры любого типа, то FrameworkElement – только триггеры событий.
    
    // Триггеры свойств
    // Триггер свойства (представленный классом Trigger) выполняет свою коллекцию элементов Setter, когда указанное свойство принимает заданное значение.
    // А когда это значение изменяется, триггер свойства «отменяет» действие своих элементов Setter.
    // Более сложный пример триггера свойства работает в сочетании с правилами проверки во время привязки к данным. 
    // В предыдущей главе мы создали класс JpgValidationRule и присоединили его к привязанному к данным элементу TextBox, чтобы не допустить ввода некорректного имени JPG-файла.
    // Чтобы декларативно определить и визуально показать, что проверка не прошла, можно создать триггер свойства, основанный на присоединенном свойстве Validation.HasError:
    // <TextBox Style="{StaticResource textBoxStyle}">
    // <TextBox.Text>
    // <Binding ...>
    // <Binding.ValidationRules>
    // <local:JpgValidationRule/>
    // </Binding.ValidationRules>
    // </Binding>
    // </TextBox.Text>
    // </TextBox>
    // Отметим, что для того чтобы стиль можно было применять и к ListBoxItem, и к TreeViewItem, в нем указан более общий класс Control (базовый класс, самый близкий к обоим), а в качестве присоединенного свойства используетсяItemsControl.AlternationIndex, а не какое-то более специфическое(например, ListBox.AlternationIndex).
    
    // Триггеры данных
    // Триггеры данных похожи на триггеры свойств, но могут срабатывать при изменении любого свойства .NET, а не только свойства зависимости.
    // (Впрочем, элементы Setter внутри триггера данных по-прежнему могут устанавливать только свойства зависимости.)
    // Чтобы воспользоваться триггером данных, следует добавить в коллекцию Triggers объект DataTrigger и указать пару свойство/значение.
    // Для поддержки обычных свойств .NET интересующее свойство задается с помощью объекта Binding, а не просто именем.
    
    // Выражение более сложной логики с помощью триггеров
    // В рассмотренных выше триггерах логика работы выглядела так: «если свойство= значение, установить следующие свойства».
    // Но существуют и другие возможности:
    // - К одному и тому же элементу можно применять несколько триггеров (для получения логического ИЛИ).
    // - В одном триггере можно вычислять несколько свойств (для получения логического И).
    // Логическое ИЛИ.
    // Поскольку коллекция Style.Triggers может содержать несколько  триггеров, то открывается возможность  создавать разные триггеры с одним и тем же набором элементов Setter – для выражения логической связки ИЛИ: 
    // КОПНЕМ ГЛУБЖЕ
    // Конфликтующие триггеры
    // Если одновременно активны несколько триггеров с конфликтующими наборами элементов Setter, то побеждает последний. 
    // То же самое относится к конфликтующим наборам Setter внутри одного триггера.
    // Логическое И.
    // Чтобы выразить отношение «логическое И», можно воспользоваться разновидностью элемента Trigger под названием MultiTrigger или разновидностью элемента DataTrigger под названием MultiDataTrigger. И MultiTrigger, и MultiDataTrigger содержат коллекцию условий Conditions, где хранится информация, которая обычно помещается внутрь Trigger или DataTrigger.
    // СОВЕТ
    // Если требуется наделить стиль еще более сложным поведением в части реакции на события, то можно воспользоваться классом EventSetter (у него тот же базовый класс, что и у Setter), позволяющим присоединить обработчик события к любому элементу, для которого задается данный стиль.
    // Элементы EventSetter включаются в стиль так же, как элементы Setter: 
    // <Style x:Key="buttonStyle" TargetType="{x:Type Button}">
    // <Setter Property="FontSize" Value="22"/>
    // <EventSetter Event="MouseEnter" Handler="Button_MouseEnter"/>
    // </Style>
    // Хотя для обработки события приходится писать процедурный код, это все же неплохой способ задать общий обработчик для нескольких элементов, не прибегая к копированию и вставке.
    
    // Шаблоны
    // В классах, производных от Control, имеется много свойств, позволяющих изменить внешний вид элементов управления.
    // У кнопки Button конфигурируются кисти Background и Foreground (можно даже использовать экстравагантные градиентные кисти), вкладки TabControl можно по-разному располагать с помощью свойства TabStripPlacement и т. д. Но все же возможности настройки за счет одних только свойств ограничены.
    // С другой стороны, шаблон позволяет полностью подменить визуальное дерево элемента всем, что взбредет вам в голову, сохранив при этом всю функциональность.
    // Исходный код элементов управления полностью  отделен от представления визуального дерева (или «визуального исходного кода»).
    // Существует несколько видов шаблонов. 
    // Те, о которых шла речь выше и которым посвящен настоящий раздел, называются шаблонами элементов управления.
    // Они представлены классом ControlTemplate, наследующим абстрактному классу FrameworkTemplate. 
    // В особо изощренных визуальных шаблонах наверняка будет применяться двумерная (и трехмерная!) графика, анимация и другие мультимедийные средства, которые мы рассмотрим в следующей главе.
    // Ну а пока ограничимся простыми двумерными рисунками.

    // Введение в шаблоны элементов управления
    // Существенная часть класса ControlTemplate – его свойство содержимого VisualTree, которое содержит дерево  элементов, определяющее внешний вид элемента.
    // Описав шаблон ControlTemplate (без сомнения, на XAML), вы сможете присоединить его к любому элементу Control или Page, установив свойство Template.
    // СОВЕТ
    // Button считается шаблоном-родителем всех элементов в визуальном дереве шаблона элемента управления.
    // В классах FrameworkElement и FrameworkContentElement имеется свойство TemplatedParent для представления этого отношения.

    // Обеспечение интерактивности с помощью триггеров
    // Обратите внимание, что больший круг в визуальном дереве шаблона имеет имя – outerCircle.
    // Это сделано для того, чтобы на него можно было сослаться из триггера.
    // СОВЕТ
    // По аналогии со свойством TargetName элемента Setter в классе Trigger (а также в классах EventTrigger и Condition) имеется свойство SourceName, которое дает возможность реагировать на изменение конкретного подэлемента шаблона, а не шаблона в целом.
    // Например, можно создать триггеры свойства IsMouseOver для отдельных подэлементов – это дало бы более интересный эффект при наведении указателя мыши.
    // КОПНЕМ ГЛУБЖЕ
    // Именованные элементы в шаблонах
    // Вне шаблона употребление ключевого слова x:Name для задания имени элемента создает поле, к которому можно обратиться из программы.
    // Но при использовании x:Name внутри шаблона дело обстоит иначе.
    // Дело в том, что шаблон может применяться к нескольким элементам в одной и той же области видимости.
    // Основная цель именования элементов в шаблоне состоит в том, чтобы на них можно было ссылаться из триггеров (как правило, определенных в XAML).
    // Но если вам все-таки нужен программный доступ к именованному элементу внутри шаблона, то можно воспользоваться методом FindName класса Template после того, как шаблон будет применен к целевому элементу.
    
    // Ограничение типа целевого элемента
    // Как и в классе Style, в классе ControlTemplate имеется свойство TargetType, позволяющее ограничить область применения шаблона.
    // В отличие от Style, использование TargetType не дает возможности отказаться от атрибута x:Key в шаблоне (если он включается в словарь).

    // Учет свойств шаблона-родителя
    // С шаблонами, которые мы видели до сих пор, связана небольшая проблема.
    // Все кнопки, к которым они применяются, выглядят абсолютно одинаково, какие бы значения свойств мы для них ни задавали. 
    // Например, в последних двух листингах содержимым кнопки была строка "OK", однако же она не отображается.
    // Если вы собираетесь создать шаблон, предназначенный для широкого распространения, то необходимо проделать некоторую работу, чтобы учитывались различные свойства целевого элемента управления.

    // Учет свойства Content класса ContentControl
    // Ключом к вставке значений свойств целевого элемента управления в шаблон является механизм привязки к данным.
    // К счастью, класс TemplateBindingExtension существенно упрощает эту задачу.
    // Источником данных для TemplateBinding всегда является целевой элемент,  а путем может быть любое  его свойство зависимости, задаваемое в свойстве Property объекта TemplateBinding.
    // СОВЕТ
    // Вместо того чтобы использовать внутри шаблона элемент ContentControl, следовало бы применить более легкий элемент ContentPresenter.
    // Он отображает содержимое так же, как ContentControl, но разработан специально для использования в шаблонах элементов управления.
    // ContentPresenter – это примитивный строительный блок, тогда как ContentControl – полноценный элемент управления с собственным шаблоном (который, кстати, содержит ContentPresenter)!
    // можно заменить строку
    // <ContentControl Margin="20" Content="{TemplateBinding Content}"/>
    // такой:
    // <ContentPresenter Margin="20" Content="{TemplateBinding Content}"/>
    // В элемент ContentPresenter даже встроена возможность сокращенной записи: если опустить присваивание Content значения {TemplateBinding Content}, то оно будет неявно подразумеваться.
    // <ContentPresenter Margin="20"/>
    // Но это работает, только если в шаблоне явно прописан тип TargetType целевого элемента, производный от ContentControl (например, Button).
    // ПРЕДУПРЕЖДЕНИЕ
    // Расширение TemplateBinding разрешено только внутри визуального дерева шаблона и не работает со свойствами, тип которых является подклассом Freezable!
    // Расширение привязки TemplateBinding не работает вне шаблона или вне его свойства VisualTree, так что его нельзя использовать даже в триггере шаблона.
    // Более того, TemplateBinding нельзя применять к свойствам, производным от класса Freezable. 
    // Например, попытка применить это расширение для привязки свойства Color любой явно заданной кисти Brush потерпит неудачу.
    // Однако TemplateBinding – всего лишь менее мощная, но удобная замена обычному расширению разметки Binding.
    // Точно такого же эффекта можно добиться, применив обычный объект Binding, в котором свойство RelativeSource равно {RelativeSource TemplatedParent}, а Path содержит путь к свойству зависимости, значение которого мы хотим получить. 
    // Такой объект Binding работает и в тех случаях, где TemplateBinding отказывается.

    // Учет остальных свойств
    // Свойство Padding целевой кнопки теперь выступает в роли свойства Margin элемента ContentPresenter.
    // Использование отступа Padding целевого элемента в качестве поля Margin внутреннего элемента шаблона – распространенная практика.
    // В конце концов, это, по существу, и есть определение отступа!
    // КОПНЕМ ГЛУБЖЕ
    // TemplateBinding и конвертеры значений
    // Как и Binding, расширение разметки TemplateBinding поддерживает конвертеры значений.
    // В классе TemplateBinding определены свойства Converter и ConverterParameter, но, как ни странно, нет свойства ConverterCulture.
    // Если последнее вам необходимо, пользуйтесь расширением Binding.

    // Похищение существующих свойств для других целей
    // Однако большинство разработчиков предпочитают  маленькую уловку – так называемое похищение свойства зависимости.
    // Смысл в том, чтобы найти в целевом элементе управления такое свойство зависимости нужного типа, которое можно было бы использовать непредусмотренным способом.
    
    // Учет визуальных состояний с помощью триггеров
    // СОВЕТ
    // Обратите внимание: предполагается, что конвертеры значений находятся в коллекции Resources объекта ControlTemplate.
    // Как и класс Style, все классы, производные от FrameworkTemplate, располагают собственной коллекцией Resources.
    // Она позволяет создавать автономные, ни от чего  не зависящие шаблоны.

    // Учет визуальных состояний с помощью менеджера визуальных состояний
    // Visual State Manager – VSM поддерживает набор типов и членов классов,  позволяющих автору элемента  управления формально определить  его части и состояния, исключая возможную путаницу.
    
    // Части элемента управления
    // Примеры:
    // - Если в шаблоне индикатора ProgressBar есть элементы с именами PART_Indicator и PART_Track, то сам элемент гарантирует, что ширина Width (или высота Height в зависимости от ориентации) элемента PART_Indicator будет составлять правильную процентную долю от ширины (или высоты) элемента PART_Track, вычисляемую с учетом значений свойств Value, Minimum и Maximum индикатора.
    // - Еслив шаблоне комбинированного списка ComboBox имеется элемент Popup с именем PART_Popup, то при закрытии этого элемента автоматически генерируется событие DropDownClosed элемента ComboBox.
    // Ели же имеется элемент TextBox с именем PART_EditableTextBox, то он автоматически интегрируется со встроенной в ComboBox возможностью обновлять выбранный элемент, когда пользователь вводит текст с клавиатуры.
    // - Большая часть функциональности таких элементов управления, как TextBox и PasswordBox, основана на наличии в шаблоне элемента с именем PART_ContentHost.
    // Именованные части, используемые в элементах управления WPF
    // page 506
    
    // Состояния элементов управления
    // Состояния – это новшество в модели частей и состояний, появившееся только в WPF 4.
    // Как и в случае частей, элементы управления могут быть наделены внутренней логикой перехода из одного именованного состояния в другое (для этого вызывается статический метод VisualStateManager.GoToState).
    // Состояния, определенные в каждом элементе управления,  объединяются в непересекающиеся группы состояний.
    // Например, у кнопки Button есть четыре состояния в группе CommonStates: Normal, MouseOver, Pressed и Disabled, а также два состояния в группе FocusStates: Unfocused и Focused.
    // В любой момент времени Button находится ровно в одном состоянии из каждой группы, по умолчанию Normal и Unfocused.
    // Этот механизм группировки придуман для того, чтобы избежать появления длинных списков, содержащих все возможные сочетания состояний (например, NormalUnfocused, NormalFocused, MouseOverUnfocused, MouseOverFocused и т. д).
    // Состояния и группы состояний, используемые в элементах управления WPF
    // page 509
    // Как и в случае частей, элементы управления должны документировать свои группы состояний и состоянияс помощью атрибута TemplateVisualStateAttribute.
    // СОВЕТ
    // В классе VisualStateGroup имеется свойство Transitions – коллекция, в которую можно поместить один или несколько объектов VisualTransition, обеспечивающих анимированные переходы между любыми комбинациями состояний. 

    // Комбинирование шаблонов со стилями
    // Чаще свойство Template элемента Control задают внутри элемента Style, а затем применяют для стилизации нужных элементов:
    // <Style TargetType="{x:Type Button}">
    // <Setter Property="Template">
    // <Setter.Value>
    // <ControlTemplate TargetType="{x:Type Button}">
    // ...
    // </ControlTemplate>
    // </Setter.Value>
    // </Setter>
    // ...
    // </Style>
    // Помимо удобства комбинирования шаблона с произвольными значениями свойств, у такого подхода есть и более весомые достоинства:
    // - Мы получаем эффект шаблонов по умолчанию. Например, когда некий типизированный стиль применяется к элементам по умолчанию и при этом содержит нестандартный шаблон, то фактически этот шаблон применяется без каких-либо явных пометок в самих элементах!
    // - Открывается возможность организовать подразумеваемые по умолчанию, но вместе с тем допускающие переопределение значения свойств, контролирующих внешний вид шаблона.
    // Иными словами, можно  учитывать свойства, установленные в шаблоне-родителе, но при этом предусматривать собственные значения по умолчанию.
    // Однако,поместив зеленую градиентную кисть в элемент Setter внутри Style, мы получаем желаемый вид по умолчанию, не запрещая отдельным элементам ProgressBar переопределять заливку путем локальной установки своего свойства Foreground.
    // И выражение {TemplateBinding Foreground} внутри шаблона менять не приходится. 
    // Элемент Style мог бы выглядеть следующим образом:
    // <Style x:Key="pieStyle" TargetType="{x:Type ProgressBar}">
    // <Setter Property="Foreground">
    // <Setter.Value>
    // <LinearGradientBrush StartPoint="0,0" EndPoint="1,1">
    // <GradientStop Offset="0" Color="LightGreen"/>
    // <GradientStop Offset="1" Color="DarkGreen"/>
    // </LinearGradientBrush>
    // </Setter.Value>
    // </Setter>
    // <Setter Property="Template">
    // <Setter.Value>
    // <ControlTemplate TargetType="{x:Type ProgressBar}">
    // ...
    // <Path x:Name="pie" Fill="{TemplateBinding Foreground}">
    // ...
    // </ControlTemplate>
    // </Setter.Value>
    // </Setter>
    // </Style>

    // При применении подобного стиля можно поступить так:
    // <!-- Использовать градиентную заливку по умолчанию -->
    // <ProgressBar Style="{StaticResource pieStyle}"
    // Width="100" Height="100" Value="10"/>
    // <!-- Использовать вместо этого заливку  красным цветом -->
    // <ProgressBar Style="{StaticResource pieStyle}" Foreground="Red"
    // Width="100" Height="100" Value="10"/>
    // КОПНЕМ ГЛУБЖЕ
    // Взаимодействие между стилями и их шаблонами
    // Если элемент Style содержит шаблон, то одно и то же свойство может устанавливаться в разных местах: в триггерах внутри Style, в триггерах, находящихся в шаблоне внутри Style, и в элементе Setter внутри Style!
    // При этом приоритетность соблюдается именно в том порядке, как перечислено в предыдущем предложении.
    // То есть триггеры стилей важнее триггеров шаблонов и любые триггеры важнее элементов Setter в стилях.
    // FAQ
    // Можно ли внести мелкие поправки в существующий шаблон элемента управления, а не создавать новый с нуля?
    // Чтобы получить «визуальный исходный код» XAML-разметки любого шаблона элемента управления, достаточно написать такую строку (после того, как завершится компоновка элемента управления, то есть после применения шаблона): 
    // string xaml = XamlWriter.Save(someControl.Template);
    // Или можно получить весь стиль любого элемента, программно извлекая нужный ресурс.
    // Следующий код извлекает стиль темы элемента, воспользовавшись свойством зависимости с именем DefaultStyleKey
    // // Получить ключ стиля по умолчанию
    // object defaultStyleKey = someElement.GetValue(
    // FrameworkElement.DefaultStyleKeyProperty);
    // Извлечь ресурс с этим ключом
    // Style style = (Style)Application.Current.FindResource(defaultStyleKey);
    // Сериализовать его XAML-представление в виде строки
    // string xaml = System.Windows.Markup.XamlWriter.Save(style);
    // Для других типов стилей можно вызвать метод FindResource с соответствующим ключом, например typeof(Button) для типизированного стиля Button (если таковой существует).
    // Есть также ряд других способов, не требующих написания кода:
    // - Обратиться к Windows SDK, где имеются XAML-файлысо всеми стилями тем, используемымив элементах управления WPF.
    // - Воспользоваться программой .NET Reflector с надстройкой BAML Viewer для просмотра стилей, внедренных в различные сборки, например PresentationFramework.Aero.dll.
    // - Создать интересующий элемент управления в Expression Blend, а затем выбрать команды меню Edit Template→Edit a Copy… (Править шаблон→ Править копию…), чтобы получить копию его стиля и вставить ее в свою XAML-разметку. 
    // (XAML-файлы для всех тем, поддерживаемых элементами управления WPF, можно найти также в развернутом дистрибутиве Blend в папке Program Files.)

    // Обложки
    // Под сменой обложки (скина) понимается изменение внешнего вида приложения «на лету», обычно в программах сторонних фирм.
    // Но если вы не хотите поощрять полную замену пользовательского интерфейса, то лучше всего сделать корнем представления обложки элемент ResourceDictionary.
    // В общем и целом, словарь ресурсов представляет собой отличную точку расширяемости из-за той легкости, с которой его можно загружать и выгружать или объединять с другими словарями.
    // Определяя обложку, имеет смысл включить в ResourceDictionary стили и/или шаблоны.
    // СОВЕТ
    // Назначая элементу стиль, который предполагается менять динамически в процессе смены обложки, не забывайте ссылаться на него как на динамический ресурс!
    // Теперь нетрудно написать и файл обложки:
    // <ResourceDictionary
    // ­­xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    // ­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    // ­­<Style x:Key="DialogStyle" TargetType="{x:Type StackPanel}">
    // ­­...
    // ­­</Style>
    // ­­<Style x:Key="HeadingStyle" TargetType="{x:Type Label}">
    // ­­...
    // ­­</Style>
    // ­­<Style x:Key="CancelButtonStyle" TargetType="{x:Type Button}">
    // ­­...
    // ­­</Style>
    // ­­До­пол­ни­тель­ные сти­ли...
    // </ResourceDictionary>
    // После этого приложению остается только динамически загрузить XAML-файл обложки и назначить его в качестве нового словаря Application.Resources. 
    // ResourceDictionary resources = null;
    // using (FileStream fs = new FileStream("CustomSkin.xaml",
    // ­­­FileMode.Open, FileAccess.Read))
    // {
    // // По­лу­чить кор­не­вой эле­мент, ко­то­рый дол­жен быть сло­ва­рем ResourceDictionary
    // ­­resources = (ResourceDictionary)XamlReader.Load(fs);
    // }
    // Application.Current.Resources = resources;
    // А можно вместо этого загрузить обложку из Интернета, если известен URLадрес:
    // ResourceDictionary resources = null;
    // System.Net.WebClient client = new System.Net.WebClient();
    // using (Stream s = client.OpenRead("http://adamnathan.net/wpf/CustomSkin.xaml"))
    // }
    // Application.Current.Resources = resources;
    // FAQ
    // Что произойдет, если в обложке не определен именованный стиль, нужный приложению?
    // Если вы решите полностью подменять текущий словарь Application.Resources новым, а в последнем какие-то стили отсутствуют, то те элементы управления, к которым эти стили применяются, просто вернутся к своему виду по умолчанию. 
    // КОПНЕМ ГЛУБЖЕ
    // Обложки, нуждающиеся в процедурном коде
    // В примере диалогового окна с информацией о ходе загрузки обе обложки находятся в одной и той же сборке, поэтому для их загрузки применяется такой код:
    // ResourceDictionary resources = (ResourceDictionary)Application.LoadComponent(
    // ­­new Uri("CustomSkin.xaml", UriKind.RelativeOrAbsolute));
    // Application.Current.Resources = resources;
    // FAQ
    // Как предотвратить вредоносные действия сторонней обложки?
    
    // Темы
    // Если обложки применяются к одному приложению, то темы обычно влияют на те визуальные характеристики операционной системы, которые отражаются в пользовательском интерфейсе всех программ. 
    
    // Системные цвета, шрифты и параметры
    // Свойства, определенные в классах SystemColors, SystemFonts и SystemParameters, автоматически обновляются при смене темы Windows.
    // Поэтому, чтобы обеспечить согласованность с выбранной пользователем темой, достаточно включить их в свои стили и шаблоны.
    
    // Стили и шаблоны тем
    // Ниже перечислены все созданные Microsoft темы и URI соответствующих им словарей:
    // - Тема Aero (Windows Vista и Windows 7): themes\Aero.NormalColor.xaml
    // - Тема Windows XP по умолчанию: themes\Luna.NormalColor.xaml
    // - Оливковая тема Windows XP: themes\Luna.Homestead.xaml
    // - Серебристая тема Windows XP: themes\Luna.Metallic.xaml
    // - Тема Windows XP Media Center Edition 2005 и Windows XP Tablet PC Edition 2005: themes\Royale.NormalColor.xaml
    // - Тема Windows Classic: themes\Classic.xaml
    // - Тема Zune Windows XP: themes\Zune.NormalColor.xaml
    // СОВЕТ
    // Не забывайте о типовом словаре, когда будете создавать словари тем. Это поможет обеспечить предсказуемое поведение, если встретится неожиданная тема.
    // Подготовив словари тем и типовой словарь, вы должны будете явно включать механизм автоматической адаптации к теме, снабдив сборку атрибутом ThemeInfoAttribute.
    // Конструктор этого атрибута принимает два параметра типа Reso­ur­ceDictionaryLocation. 
    // - None – не искать словарь ресурсов. Это значение по умолчанию.
    // - SourceAssembly – искать в текущей сборке.
    // - ExternalAssembly – искать в другой сборке, которая должна называться Assem­blyName.ThemeName.dll (где AssemblyName совпадает с именем текущей сборки).
    // WPF применяет эту схему ко встроенным словарям тем, которые находятся в сборках PresentationFramework.Aero.dll, PresentationFramework.Luna.dll и т. д.
    // Этот способ позволяет избежать постоянного присутствия в памяти ресурсов для всех тем.
    // Типичное использование атрибута ThemeInfoAttribute выглядит так:
    // Ис­кать сло­ва­ри тем и ти­по­вой сло­варь в этой сбор­ке
    // [assembly:ThemeInfo(ResourceDictionaryLocation.SourceAssembly,
    // ­­­­­­­­­­­­­­­­­­­­ResourceDictionaryLocation.SourceAssembly)]
    // ThemeDictionaryExtension – это расширение разметки, позволяющее переопределять стили темы любых элементов.
    // <Application ...>
    // <Application.Resources>
    // ­­<ResourceDictionary>
    // ­­<ResourceDictionary.MergedDictionaries>
    // ­­­­<ResourceDictionary .../>
    // ­­­­<ResourceDictionary Source="{ThemeDictionary MyApplication}"/>
    // ­­</ResourceDictionary.MergedDictionaries>
    // ­­</ResourceDictionary>
    // </Application.Resources>
    // </Application>
    // Другой способ присоединить стили темы к существующим элементам состоит в том, чтобы определить свой подкласс.
    // Создать подобный элемент исключительно ради назначения ему стиля темы совсем несложно.
    // Так, в примере секторной диаграммы можно было бы создать следующий нестандартный элемент ProgressPie:
    // public class ProgressPie : ProgressBar
    // {
    // ­­static ProgressPie()
    // ­­{
    // ­­­­DefaultStyleKeyProperty.OverrideMetadata(
    // ­­­­­­typeof(ProgressPie),
    // ­­­­­­new FrameworkPropertyMetadata(typeof(ProgressPie)));
    // ­­}
    // }
    //  Каждый словарь темы представляет собой автономный XAML-файл со следующей структурой:
    // <ResourceDictionary
    // ­­xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    // ­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    // ­­xmlns:local="clr­namespace:ThemedProgressPie">
    // ­­<Style TargetType="{x:Type local:ProgressPie}">
    // ­­...
    // ­­</Style>
    // </ResourceDictionary>
    // КОПНЕМ ГЛУБЖЕ
    // Темы и цветовые схемы Windows
    // В Windows 7 и Windows Vista имеется длинный список цветовых схем в диалоговом окне Дополнительные параметры оформления. 
    // СОВЕТ
    // Можете поэкспериментировать с альтернативными обложками для многих элементов управления WPF, скачав файл WPFThemes.zip с сайта http://wpf.codeplex.com.
    // Чтобы ими воспользоваться, нужно просто сослаться на словарь ресурсов в коллекции Resources для элемента App­lication, Window или еще какого-то:
    // <Application ...>
    // <Application.Resources>
    // <ResourceDictionary Source="BureauBlack.xaml"/>
    // </Application.Resources>
    // </Application>


    // !!!
    // - разобрать jpg validation rule
}
