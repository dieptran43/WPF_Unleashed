using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._4_ProfessionalTools._12_Resources
{
    /// <summary>
    /// Interaction logic for Resources.xaml
    /// </summary>
    public partial class Resources : Window
    {
        public Resources()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            BinaryResource window = new BinaryResource();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            LogicalResources window = new LogicalResources();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            StaticDynamicResources window = new StaticDynamicResources();
            window.Show();
        }
    }

    // В каркас .NET Framework встроена общая инфраструктура пакетирования и доступа к ресурсам – частям приложения или компонента, отличным от кода.
    // К ним относятся, например, растровые изображения, шрифты, аудио- и видеофайлы и таблицы строк.
    // WPF поддерживает два принципиально разных вида ресурсов: двоичные и логические.

    // Двоичные ресурсы
    // Первый тип – двоичные ресурсы – это в точности то, что понимается под ресурсами в остальных частях .NET Framework.
    // В WPF-приложениях в этой роли обычно выступают традиционные ресурсы вроде растровых изображений.
    // Но и откомпилированный XAML-код также хранится в виде двоичного ресурса. Существует три способа пакетирования двоичных ресурсов:
    // - Внедрить в сборку
    // - Оставить в виде автономных файлов, известных приложению на этапе компиляции
    // - Оставить в виде автономных файлов, не известных приложению на этапе компиляции
    // Двоичные ресурсы приложения часто относят к одной из двух категорий: локализуемые ресурсы, которые должны изменяться в зависимости от текущей культуры, и не зависящие от языка (или нелокализуемые), то есть одинаковые при любой культуре.

    // Определение двоичного ресурса
    // Типичная процедура определения двоичного ресурса заключается в том, чтобы добавить файл в проект Visual Studio и выбрать в сетке свойства подходящее действие при построении
    // Visual Studio поддерживает несколько действий при построении для WPF-приложений, два из которых имеют непосредственное отношение к двоичным ресурсам:
    // - Resource – внедрить ресурс в сборку (или в соответствующую конкретной культуре сателлитную сборку).
    // - Content – оставить ресурс в виде автономного файла, но добавить в сборку специальный атрибут (AssemblyAssociatedContentFile), в котором говорится о существовании и относительном местоположении файла.
    // Если вы вручную редактируете проект для программы MSBuild, то такой файл можно добавить следующим образом:
    // <BuildAction Include="logo.jpg"/>
    // где BuildAction – название действия при построении. Этот элемент может содержать вложенные элементы, уточняющие поведение, например:
    // <Content Include="logo.jpg">
    // <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    // </Content>
    // Если вы хотите оставить ресурсы в виде автономных файлов, то добавлять их в проект, указывая действие при построении Content, необязательно;
    // можно просто поместить их в известное на этапе выполнения место и не добавлять в проект вовсе.
    // Но так поступать не рекомендуется, потому что доступ к ресурсу оказывается менее естественным.
    // Тем не менее иногда невозможно избежать использования ресурсов, неизвестных на этапе компиляции, например файлов, которые динамически генерируются во время работы программы.
    // ПРЕДУПРЕЖДЕНИЕ
    // Избегайте действия при построении Embedded Resource!
    // Ресурсы следует внедрять в сборку (указывая действие при построении Resource), если либо они локализуемые, либо вам кажется, что иметь всего один двоичный файл лучше, чем включать в дистрибутив автономный файл, пусть даже его можно заменять независимо от кода.
    // Если ни одно из этих условий не выполнено или необходим также доступ к содержимому ресурса из внешних программ (быть может, из HTML-страниц, генерируемых приложением), то наиболее подходящим вариантом будет действие при построении Content.

    // Доступ к двоичным ресурсам
    // WPF предоставляет механизм для доступа к ним как из кода, так и из XAML, – по унифицированному идентификатору ресурса (URI).
    // Имеется конвертер типа, который позволяет задавать URI в XAML-разметке в виде простой строки, с несколькими встроенными упрощениями для наиболее распространенных случаев.
    // ПРЕДУПРЕЖДЕНИЕ
    // Откомпилированный XAML-код не может ссылаться на двоичный ресурс в текущем каталоге по имени файла без указания каталога, если этот файл не был включен в проект!
    // URI для доступа к двоичным ресурсам из XAML-разметки (ресурс называется logo.jpg)
    // Если URI имеет вид… - То ресурс…
    // logo.jpg - Внедрен в текущую сборку или является автономным и находится в той же папке, что и текущая XAML-страница либо сборка (последнее верно, только если для ресурса в проекте было указано действие при построении Content)
    // A/B/logo.jpg - Внедрен в текущую сборку с использованием внутренней структуры подпапок (A\B), определенной на этапе компиляции, или является автономным и находится в подпапке A\B относительно текущей XAML-страницы либо сборки (последнее верно, только если для ресурса в проекте было указано действие при построении Content) 
    // c:\temp\logo.jpg - Автономный и находится в локальной папке c:\temp
    // file://c:/temp/logo.jpg - Автономный и находится в локальной папке c:\temp
    // \\pc1\images\logo.jpg - Автономный и находится в общей папке \\pc1\images
    // http://adamnathan.net/logo.jpg - Автономный и находится на веб-сайте adamnathan.net
    // /MyDll;Component/logo.jpg - Внедрен в другую сборку с именем MyDll.dll или MyDll.exe
    // /MyDll;Component/A/B/logo.jpg - Внедрен в другую сборку с именем MyDll.dll или MyDll.exe с использованием внутренней структуры подпапок (A\B), определенной на этапе компиляции 
    // pack://siteOfOrigin:,,,/logo.jpg - Автономный в первоисточнике
    // pack://siteOfOrigin:,,,/A/B/logo.jpg - Автономный в первоисточнике в подпапке A\B
    // FAQ
    // Что происходит при попытке доступа к ресурсу по медленной или недоступной сети?
    // Доступ производится синхронно, то есть вы будете наблюдать, как приложение «зависает» на время, необходимое для скачивания всего ресурса до последнего бита.
    // Ко всему прочему, ошибка при доступе к ресурсу возбуждает неперехватываемое исключение.

    // Доступ к ресурсам, внедренным в другую сборку
    // URI записывается в виде
    // /AssemblyReference;Component/ResourceName
    // где AssemblyReference идентифицирует конкретную сборку, а Component – ключевое слово, которое нельзя изменять. 
    // ResourceName – это имя файла (может включать подпапки).
    // AssemblyReference может быть простым отображаемым именем сборки или включать необязательные части идентификатора сборки .NET: номер версии и маркер открытого ключа (если это сборка со строгим именем).
    // Таким образом, имеется четыре варианта записи AssemblyReference:
    // - AssemblyName
    // - AssemblyName;vVersionNumber (префикс v обязателен)
    // - AssemblyName;PublicKeyToken
    // - AssemblyName;vVersionNumber;PublicKeyToken

    // Доступ к ресурсам в первоисточнике
    // Приложения с полным доверием могут содержать жестко зашитый унифицированный указатель ресурса (URL) или путь к файлу для автономных двоичных ресурсов, но с точки зрения сопровождения разумнее воспользоваться понятием первоисточника.
    // Во время выполнения первоисточнику могут быть сопоставлены различные физические места в зависимости от способа развертывания приложения:
    // - Для приложения с полным доверием, установленного с помощью установщика Windows, первоисточником будет корневая папка приложения.
    // - Для ClickOnce-приложения с полным доверием первоисточником будет URL или UNC-путь, из которого было развернуто приложение.
    // - Для XBAP- или ClickOnce-приложения с частичным доверием первоисточником будет URL или UNC-путь к месту, где находится приложение.
    // - Для автономных XAML-страниц, просматриваемых в браузере, первоисточника нет. При попытке воспользоваться ресурсом возникает исключение.
    // Необходимо указывать префикс pack://siteOfOrigin:,,,/, за которым следует имя ресурса (возможно, содержащее подпапки)
    // FAQ
    // Откуда взялся этот ужасный синтаксис с тремя запятыми?
    // Формат URI со схемой pack определен в спецификации XML Paper Specification (XPS)ю
    // Что же касается WPF-программ, то это может быть один из двух URI, которые на этой платформе имеют особый смысл:
    // - siteOfOrigin:/// (кодируется в виде siteOfOrigin:,,,)
    // - application:/// (кодируется в виде application:,,,)
    // Пакет application:/// неявно используется во всех ссылках на ресурсы, за исключением тех, где встречается siteOfOrigin.
    // logo.jpg
    // на самом деле представляет собой сокращенную запись для
    // pack://application:,,,/logo.jpg
    // а такой URI:
    // /MyDll;Component/logo.jpg
    // будет сокращенной записью для
    // pack://application:,,,/MyDll;Component/logo.jpg

    // Доступ к ресурсам из процедурного кода
    // необходимо конструировать URI из полного URI со схемой pack или из абсолютного пути либо URL.
    // В результате создается объект типа System.Windows.Media.Imaging.BitmapImage (этот механизм работает для таких популярных графических форматов, как JPEG, PNG, GIF и BMP), являющегося косвенным потомком абстрактного класса ImageSource (это тип свойства Source).
    // Сам URI представлен объектом типа System.Uri.
    // Конструкция pack://application:,,,/ работает только для ресурсов, принадлежащих текущему  проекту, для которых указано действие при построении Resource или Content.
    // Чтобы сослаться на автономные файлы, не имеющие отношения к проекту, по относительному имени, проще всего воспользоваться URI на базе siteOfOrigin.

    // Локализация двоичных ресурсов
    // Если приложение содержит двоичные ресурсы, относящиеся к определенным культурам, то их можно поместить в сателлитные сборки (по одной на каждую культуру), которые будут автоматически загружаться при необходимости. 
    // Инструментальное средство LocBaml, входящее в состав Windows SDK, позволяет выполнять локализацию строк и других частей приложения, не выдергивая их из XAML и не применяя вручную механизмы косвенного доступа.
    
    // Подготовка проекта для нескольких культур
    // Элемент UICulture нужно помещать внутрь некоторых или всех элементов PropertyGroup, соответствующих тем конфигурациям построения, которые вас интересуют (Debug, Release и т. д.)
    // <Project ...>
    // <PropertyGroup>
    // <UICulture>en-US</UICulture>
    // Перестроив проект с такой настройкой, вы обнаружите на одном уровне со своей сборкой папку en-US, в которой будет находиться сателлитная сборка с именем AssemblyName.resources.dll.
    // Следует также пометить свою сборку атрибутом NeutralResourcesLanguage уровня сборки, значение которого совпадает с выбранной культурой по умолчанию:
    // [assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]

    // Пометка пользовательского интерфейса идентификаторами локализации
    // Следующий шаг – применение директивы Uid из пространства имен языка XAML (x:Uid) ко всем объектным элементам, нуждающимся в локализации.
    // Делать это вручную очень утомительно, но, к счастью, есть и автоматический способ – вызвать MSBuild из командной строки следующим образом:
    // msbuild /t:updateuid ProjectName.csproj

    // Создание новой сателлитной сборки с помощью LocBaml
    // Откомпилировав проект, в который добавлены Uid, можно запустить программу LocBaml из Windows SDK для файла .resources, сгенерированного в процессе построения (он находится в каталоге obj\debug):
    // LocBaml /parse ProjectName.g.en-US.resources /out:en-US.csv
    // Например, если в CSV-файле находится перевод строк на канадский диалект французского языка, то можно сохранить его с именем fr-CA.csv, а затем запустить LocBaml следующим образом:
    // LocBaml /generate ProjectName.resources.dll /trans:fr-CA.csv /cul:fr-CA
    // Чтобы протестировать приложение для другой культуры, присвойте свойству System.Threading.Thread.CurrentThread.CurrentUICulture (и System.Threading.Thread.CurrentThread.CurrentCulture) ссылку на нужный экземпляр класса CultureInfo.

    // Логические ресурсы
    // Логические ресурсы представляют собой произвольные объекты .NET, хранящиеся в свойстве элемента Resources.
    // Обычно предполагается, что таким ресурсом смогут сообща пользоваться все потомки данного элемента.
    // Свойство Resources (типа System.Windows.ResourceDictionary) определено в базовых классах FrameworkElement и FrameworkContentElement, а это означает, что оно есть в большинстве классов WPF.
    // В качестве логических ресурсов часто выступают стили или поставщики данных.
    // Но в этой главемы будем хранить в логическом ресурсе простую кисть Brush.
    // Вместо этого можно было бы сделать желтую и красную кисти логическими ресурсами элемента Window и ссылаться на них из разных элементов.
    // Это правильный способ отделить и собрать в одном месте всю информацию о стилях.
    // Во многом он напоминает применение каскадных таблиц стилей (CSS) для управления всеми цветами и стилями в пределах веб-страницы, не задавая их для каждого элемента в отдельности. 
    // Для применения ресурса к элементам мы используем расширение разметки StaticResource (сокращенная запись System.Windows.StaticResourceExtension).
    // К свойству Window.Background она применяется как элемент свойства, а к свойствам Button.Background и Button.BorderBrush – как атрибут свойства.
    
    // Поиск ресурса
    // В классе этого расширения разметки реализована возможность обхода логического дерева для поиска нужного объекта.
    // Сначала проверяется коллекция Resources текущего элемента. 
    // Если объект не найден, проверяется родительский элемент и т. д., пока не дойдем до корневого элемента.
    // В этот момент проверяется коллекция Resources объекта Application. Если искомое не найдено и здесь, то проверяется коллекция ресурсов темы.
    // Если объекта нет и там, то на последнем шаге проверяется системная коллекция (в которой находятся системные шрифты, цвета и другие настройки).
    // Если ресурс так и не удалось найти, возбуждается исключение InvalidOperationException.
    // Принимая во внимание описанное поведение, ресурсы обычно хранят в словаре ресурсов корневого элемента или в словаре уровня приложения, чтобы обеспечить максимально широкое обобществление. 
    // ПРЕДУПРЕЖДЕНИЕ
    // Осторожнее с ресурсами уровня приложения в многопоточных приложениях!
    // в WPF-приложении может быть несколько потоков пользовательского интерфейса.
    // В таком случае каждый поток будет напрямую обращаться к ресурсам уровня приложения.
    // Чтобы при этом не возникало ошибок, все такие ресурсы должны принадлежать классу Freezable и при этом быть заморожены, либо их следует пометить атрибутом x:Shared=false.
    
    // Статические и динамические ресурсы
    // WPF предлагает два способа доступа к логическому ресурсу:
    // - Статически с помощью расширения разметки StaticResource – это означает, что значение ресурса применяется только один раз (при первом обращении)
    // - Динамически с помощью расширения разметки DynamicResource – это означает, что ресурс заново применяется после каждого изменения
    // выбор того или другого определяется тем, хотите вы, чтобы потребитель ресурса видел его изменения, или нет.

    // Описание различий
    // Основное различие между StaticResource и DynamicResource заключается в том, что последующие обновления ресурса применяются только к тем элементам, для которых используется расширение DynamicResource.
    // Причиной обновления может быть как ваш собственный код (например, замена желтой кисти на синюю), так и изменение системных настроек пользователем.
    // Ресурсы, на которые есть ссылки типа StaticResource, загружаются вместе с окном Window или страницей Page, тогда как ресурсы со ссылкой типа DynamicResource не загружаются, пока к ним не обратятся.
    // Кроме того, DynamicResource можно использовать только для установки свойств зависимости, а StaticResource – практически повсеместно.
    // Например, StaticResource может служить в качестве элемента, чтобы абстрагировать целые элементы управления.
    // КОПНЕМ ГЛУБЖЕ
    // Вынесение XAML-кода
    // если вы хотите разнести набор ресурсов по нескольким XAML-файлам вне зависимости от того, в каком месте логического дерева они хранятся (быть может, ради удобства сопровождения или повышения гибкости), то придется воспользоваться свойством MergedDictionaries класса ResourceDictionary.
    // Расширение разметки StaticResource в XAML не поддерживает опережающие ссылки. 
    // Иными словами, всякому использованию ресурса должно предшествовать его объявление в XAML-файле.
    // Это означает, что StaticResource нельзя использовать как атрибут свойства, если ресурс определен в том же самом элементе.
    
    // Необобществляемые ресурсы
    // По умолчанию, когда ресурс применяется в нескольких местах, всюду используется один и тот же объект. 
    // Обычно это желательное поведение. Но можно пометить некоторые объекты в откомпилированном словаре ресурсов ключевым словом x:Shared="False", и тогда при каждом запросе будет генерироваться новый объект, который можно модифицировать независимо от остальных.
    
    // Определение и применение ресурсов в процедурном коде
    // window.Resources.Add("backgroundBrush", new SolidColorBrush(Colors.Yellow));
    // window.Resources.Add("borderBrush", new SolidColorBrush(Colors.Red));
    // Но вот применение ресурсов в процедурном коде – совсем другое дело.
    // Чтобы получить поведение, эквивалентное StaticResource, необходимо записать в свойство элемента результат вызова метода FindResource (унаследованного от класса FrameworkElement или FrameworkContentElement).
    // <Button Background="{StaticResource backgroundBrush}" BorderBrush="{StaticResource borderBrush}"/>
    // эквивалентно такому коду на C#
    // Button button = new Button();
    // Прежде чем искать ресурсы, необходимо сделать Button потомком Window:
    // stackPanel.Children.Add(button);
    // button.Background = (Brush)button.FindResource("backgroundBrush");
    // button.BorderBrush = (Brush)button.FindResource("borderBrush");
    // Метод FindResource возбуждает исключение, если не удается найти ресурс, но можно вместо него использовать метод  TryFindResource, который в этом случае просто вернет null.
    // В случае DynamicResource обращение к методу элемента SetResourceReference (также унаследованному от FrameworkElement или FrameworkContentElement) организует обновляемую привязку к свойству зависимости.
    //<Button Background="{DynamicResource backgroundBrush}" BorderBrush="{DynamicResource borderBrush}"/>
    // эквивалентна такому коду на C#:
    // Button button = new Button();
    // button.SetResourceReference(Button.BackgroundProperty, "backgroundBrush");
    // button.SetResourceReference(Button.BorderBrushProperty, "borderBrush");
    // Правило опережающих ссылок для StaticResource остается справедливым и в процедурном коде. 
    // Обращение к методу FindResource или TryFindResource завершится неудачно, если оно произведено раньше добавления ресурса в соответствующий словарь с требуемым ключом.
    // С другой стороны,метод SetResourceReference можно вызывать и до того, как ресурс добавлен.
    // КОПНЕМ ГЛУБЖЕ
    // Прямой доступ к ресурсам
    // свойства Background и BorderBrush кнопки можно было бы установить следующим образом (в предположении, что объект Window называется window):
    // Button button = new Button();
    // button.Background = (Brush)window.Resources["backgroundBrush"];
    // button.BorderBrush = (Brush)window.Resources["borderBrush"];

    // Взаимодействие с системными ресурсами
    // Один из случаев, где напрашивается использование расширения разметки DynamicResource, – доступ к системным настройкам, инкапсулированным в статические свойства трех классов в пространстве имен System.Windows: SystemColors, SystemFonts и SystemParameters.
    // Дело в том, что пользователь может в любой момент изменить эти настройки на Панели управления, даже когда ваше приложение работает.
    // В классах SystemColors, SystemFonts и SystemParameters свойства определены парами – одно содержит фактическое значение, а другое играет роль ключа ресурса, по которому производится поиск.
    // Потенциально возможные способы задания цвета фона, совпадающего с определенным в системных настройках
    // Подход - Результат
    // 1) XAML:
    // <Button Background="SystemColors.WindowBrush"/>
    // C#:
    // button.Background = (Brush)new BrushConverter(). ConvertFrom("SystemColors.WindowBrush");
    // - Не работает. Класс BrushConverter этого не поддерживает
    // 2) XAML:
    // <Button Background="{x:Static SystemColors.WindowBrush}"/>
    // C#:
    // button.Background = SystemColors.WindowBrush;
    // - Цвет успешно устанавливается один раз, но не изменяется, когда пользователь меняет системные настройки во время работы программы 
    // 3) XAML:
    // <Button Background="{StaticResource SystemColors.WindowBrushKey}"/>
    // C#:
    // button.Background =(Brush)FindResource("SystemColors.WindowBrushKey");
    // - Не работает, если только ресурс Brush не определен с ключом "SystemColors.WindowBrushKey",  не имеющим ни малейшего отношения к статическому свойству, которое вы хотели бы использовать
    // 4) XAML:
    // <Button Background="{StaticResource {x:Static SystemColors.WindowBrush}}"/>
    // C#:
    // button.Background =(Brush)FindResource(SystemColors.WindowBrush);
    // - SystemColors.WindowBrush не является допустимым ключом, поэтому при таком подходе ресурс не будет найден
    // 5) XAML:
    // <Button Background="{StaticResource {x:Static SystemColors.WindowBrushKey}}"/>
    // C#:
    // button.Background =(Brush)FindResource(SystemColors.WindowBrushKey);
    // - Ресурс будет найден. Напоминает второй подход, но, кроме того, позволяет приложению переопределить цвет (на этапе инициализации), например, для простого изменения внешнего вида 
    // 6) XAML:
    // <Button Background="{DynamicResource {x:Static SystemColors.WindowBrushKey}}"/>
    // C#:
    // button.SetResourceReference(Button.BackgroundProperty, SystemColors.WindowBrushKey);
    // - Предпочтительный подход. Реагирует на любые изменения настроек, произведенные пользователем, и позволяет приложению в любой момент переопределить их.
    // Но самое интересное – и, пожалуй, самое важное – применение логических ресурсов связано с их использованием совместно с такими объектами, как стили и шаблоны.
}
