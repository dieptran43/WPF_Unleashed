using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._2_WPFApplication_Creation._4_Element_size_position_transformation
{
    /// <summary>
    /// Interaction logic for ElementSizePositionTransformation.xaml
    /// </summary>
    public partial class ElementSizePositionTransformation : Window
    {
        public ElementSizePositionTransformation()
        {
            InitializeComponent();

            Label myLabel = new Label();
            myLabel.Margin = new Thickness(10); // To же, что Margin="10" в XAML
            myLabel.Margin = new Thickness(20, 5, 20, 5); // To же, что Margin="20,5" в XAML
            myLabel.Margin = new Thickness(0, 10, 20, 30); // To же, что Margin="0,10,20,ЗО" в XAML
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            MarginPadding window = new MarginPadding();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Visibility window = new Visibility();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            Alignment window = new Alignment();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            Transform window = new Transform();
            window.Show();
        }

        // Процедура задания размеров и положений элементов управления (и других элементов) называется компоновкой, или версткой макета.
        // Родительские элементы, поддерживающие компоновку нескольких детей, называются панелями, они наследуют абстрактному классу System. Windows.Controls.Panel.
        // Все элементы, участвующие в процессе компоновки (как родители, так и потомки), наследуют классу System.Windows.UIElement.

        // Управление размером
        // Свойства Height и Width
        // Во всех классах, производных от FrameworkElement, есть свойства Height (высота) и Width (ширина) (типа double), а также MinHeight, MaxHeight, MinWidth и MaxWidth.
        // Избегайте явного задания размеров!
        // Если явно задавать размеры элементов управления, особенно производных от класса ContentControl, например Button и Label, то возникает риск отсечения текста в случае, когда пользователь изменяет системный шрифт или текст переводится на другие языки. Поэтому лучше не задавать размеры явно, если без этого можно обойтись. К счастью, благодаря наличию панелей необходимость явно задавать размеры возникает редко.
        // Специальное значение длины "Auto". Чтобы проверить, выбирается ли размер элемента автоматически, можно воспользоваться статическим методом Double.IsNaN.
        // в классе FrameworkElement есть еще несколько свойств, относящихся к размеру:
        // - DesiredSize (наследуется от UIElement)
        // - RenderSize (наследуется от UIElement)
        // - ActualHeight и ActualWidth
        // В отличие от остальных шести свойств, они являются не входными данными для процедуры компоновки, а выходными — представляющими результат компоновки, и потому доступны только для чтения.
        // Запомните: каким бы способом ни был задан размер элемента - явно, с помощью допустимых диапазонов значений или не задан вовсе, - родитель вправе изменить окончательный размер элемента на экране.
        // если свойств Height и Width не заданы явно, то они будут иметь значение Double. NaN, каким бы ни оказался истинный размер элемента.
        // ! Будьте осторожны использовании в коде свойств ActualHeight и ActualWidth (или RenderSize)!
        // Обращаться к ним безопасно только внутри обработчика события LayoutUpdated, определенного в классе UIElement. Есть и другой способ - в классе UIElement имеется метод UpdateLayout, который синхронно производит все отложенные обновления макета, но лучше его не при-менять.

        // Свойства Margin и Padding
        // Очень похожие свойства Margin и Padding тоже связаны с размером элемента. Свойство Margin определено для всех объектов, производных от FrameworkElement, свойство Padding во всех элементах управления, производных от класса Control (а также в классе Border). Различие в том, что Margin задает внешнее поле вокруг элемента, a Padding - внутренний отступ между содержимым элемента и его границами.
        // Для элемента Label свойство Padding по умолчанию равно 5, но его можно заменить любым другим допустимым значением.
        
        // Синтаксис задания значений типа Thickness
        // Синтаксис задания значений через запятую, поддерживаемый свойствами Margin и Padding, обеспечивает - догадайтесь, кто - конвертер типа System.Windows.Thick- nessConverter, который конструирует объект типа Thickness из строки.

        // Какие единицы измерения применяются в WPF?
        // По умолчанию все абсолютные измерения (в частности, величины свойств, обсуждаемых в этом разделе) выражаются в независимых от устройства пикселах. Такие «логические пикселы» представляют 1/96 дюйма независимо от разрешения экрана, выраженного в точках на дюйм (DPI).
        // Важно лишь, что все измерения не зависят от разрешающей способности.

        // Свойство Visibility
        // Тип свойства элемента Visibility - не Boolean, а перечисление System.Windows.Visibility с тремя состояниями, то есть оно может принимать три значения:
        // - Visible – элемент виден и участвует в компоновке.
        // - Collapsed – элемент не виден и не участвует в компоновке.
        // - Hidden – элемент не виден, но тем не менее участвует в компоновке.
        
        // Управление положением
        // Однако есть несколько механизмов, общих для всех дочерних элементов типа FrameworkElement.

        // Выравнивание
        // С помощью свойств HorizontalAlignment и VerticalAlignment элемент может управлять распределением избыточного пространства, выделенного ему родителем. Значениями свойств являются одноименные перечисления, которые определены в пространстве имен System.Windows:
        // - HorizontalAlignment - Left, Center, Right, Stretch
        // - VerticalAlignment - Top, Center, Bottom, Stretch
        // Эти два свойства полезны только в случае, когда родительская панель выделяет дочернему элементу больше места, чем тому необходимо. Так, задание свойства VerticalAligment для элементов на панели StaскРапеl, ничего не изменит, потому что каждому элементу уже выделена ровно такая высота, какая ему требуется, — не больше и не меньше.
        // Взаимодействие между типом выравнивания Stretch и явным заданием размера элемента
        // Даже если для элемента в качестве выравнивания задано растяжение (Stretch) по горизонтали или по вертикали, приоритет все равно отдается явно заданной высоте Height или ширине Width. Свойства MaxHeight и MaxWidth также более при-оритетны, но только в том случае, когда их значения меньше размера, получившегося после растяжения. Аналогично свойствам MinHeight и MinWidth приоритет отдается лишь тогда, когда их значения больше размера, получившегося после растяжения. Если свойство Stretch используется в контексте, где на размер элемента налагаются ограничения, то оно действует как тип выравнивания Center (или Left, если элемент слишком велик и не может быть отцентрирован внутри своего родителя).
        // Выравнивание содержимого
        // Помимо свойств HorizontalAlignment и VerticalAlignment, в классе Control имеются свойства HorizontalContentAlignment и VerticalContentAlignment. Они определяют порядок размещения содержимого внутри элемента управления.
        // Однако по умолчанию свойство HorizontalContentAlignment равно Left, a VerticalContentAlignment равно Тор.
        // Свойство FlowDirection
        // Свойство FlowDirection, определенное в классе FrameworkElement (и еще нескольких), позволяет изменить направление визуализации внутреннего содержимого элемента.
        // Тип этого свойства - перечисление System.Windows.FlowDirection, принимающее два значения: LeftToRight (по умолчанию в классе FrameworkElement) и RightToLeft.
        // Идея FlowDirection заключается в том, что для языка, записываемого справа налево, должно быть задано направление RightToLeft.

        // Применение преобразований
        // В WPF имеется целый ряд встроенных классов двумерных геометрических преобразований (производных от System.Windows.Media.Transform), которые по-зволяют изменять размер и положение элементов независимо от ранее рассмотренных свойств. Некоторые преобразования изменяют элементы и более экзотическими способами, например, поворачивают или наклоняют их.
        // Во всех подклассах FrameworkElement имеется два свойства типа Transform, по-зволяющих применять преобразования:
        // - LayoutTransform - применяется до компоновки элемента
        // - RenderTransform (унаследовано от UIElement) - применяется после завершения компоновки (непосредственно перед визуализацией элемента)
        // В обоих случаях преобразование применяется ко второй из трех кнопок. Но если оно применено как LayoutTransform, то третья кнопка сдвигается вниз, а если как RenderTransform, то третья кнопка размещается так, будто вторая не поворачивалась вовсе.
        // В классе UIElement имеется также полезное свойство RenderTransformOrigin, представляющее начальную точку преобразования (которая остается неподвижной).
        // Свойство RenderTransformOrigin имеет тип System.Windows.Point и по умолчание равно (0,0).
        // Точка (0,1) представляет левый нижний угол, (1,0) - правый верхний угол, а (1,1) - правый нижний угол.
        // Дробные значения также допустимы. В частности, точка (0.5,0.5) представляет середину объекта.
        // В этом разделе мы рассмотрим все пять встроенных двумерных преобразований, определенных в пространстве имен System.Windows.Media:
        // - RotateTransform
        // - ScaleTransform
        // - SkewTransform
        // - TranslateTransform
        // - MatrixTransform

        // Преобразование RotateTransform
        // Преобразование RotateTransform, продемонстрированное в предыдущем разделе, поворачивает элемент в соответствии со следующими тремя свойствами типа double:
        // - Angle - угол поворота в градусах (по умолчанию 0)
        // - CenterX - абсцисса центра поворота (по умолчанию 0)
        // - CenterY - ордината центра поворота (по умолчанию 0)
        // Точка (CenterX,CenterY), равная по умолчанию (0,0), соответствует левому верхнему углу. Свойства CenterX и CenterY принимаются во внимание, только если преобразование применяется в режиме RenderTransform, потому что для преоб-разования в режиме LayoutTransform положение центра поворота определяется родительской панелью.
        // В чем разница между использованием свойств CenterX и CenterY для преобразований вида RotateTransform и свойством RenderTransformOrigin элемента типа UlElement?
        // Однако же CenterX и CenterY задают абсолютное положение начальной точки, тогда как RenderTransformOrigin - относительное. Значения задаются в независимых от устройства пикселах, так что для правого верхнего угла элемента с шириной Width, равной 20, свойство CenterX будет равно 20, a CenterY - 0, а не (1,0).
        // Кроме того, при комбинировании нескольких преобразований RenderTransform(см. следующую главу) задание CenterX и CenterY для отдельных преобразований обеспечивает более точный контроль. Наконец, раздельные значения CenterX и CenterY типа double проще использовать для привязки к данным, чем одно значение RenderTransformOrigin типа Point.
        // В типичном случае, когда элемент поворачивается относительно своей середины, относительные координаты (0.5,0.5), задаваемые с помощью RenderTransformOrigin, проще записать в XAML.
        // RotateTransform имеет параметризованные конструкторы, которые принимают значения угла или угла и центра, для удобства выполнения преобразования из процедурного кода.

        // Преобразование ScaleTransform
        // Преобразование ScaleTransform увеличивает или уменьшает элемент по горизонтали, по вертикали или в обоих направлениях. У него есть четыре свойства типа double:
        // - ScaleX - коэффициент изменения ширины элемента (по умолчанию 1)
        // - ScaleY - коэффициент изменения высоты элемента (по умолчанию 1)
        // - CenterX-начальная точка для масштабирования по горизонтали (по умолчанию 0)
        // - CenterY - начальная точка для масштабирования по вертикали (по умолчанию 0)
        // Обратите внимание, что зеленая кнопка не сдвинута влево, как оранжевая, хотя CenterX в обоих случаях равно 70. Дело в том, что Center Х принимается во внимание, только если значение отлично от 1, а CenterY - если ScaleY не равно 1.
        // Взаимодействие между ScaleTransform и выравниванием типа Stretch
        // Если преобразование ScaleTransform применяется в режиме LayoutTransform к элементу, который уже растянут в направлении масштабирования, то оно принимается во внимание только в случае, когда размер после масштабирования больше размера, получившегося в результате растяжения.
        // Как преобразования, подобные ScaleTransform, влияют на свойства ActualHeight и ActualWidth элемента типа FrameworkElement и на свойство RenderSize элемента типа UIElement?
        // Применение преобразования к элементу типа FrameworkElement никогда не изменяет значений этих свойств. Это справедливо вне зависимости от того применяется преобразование в режиме RenderTransform или LayoutTransform.
        // Как преобразование ScaleTransform влияет на свойства Margin и Padding?
        // Свойство Padding масштабируется вместе со всем содержимым (поскольку отступ находится внутри элемента), а свойство Margin не масштабируется вовсе.

        // Преобразование SkewTransform
        // Преобразование SkewTransform наклоняет элемент в соответствии со значениями четырех свойств типа double:
        // - AngleX– угол наклона по горизонтали (по умолчанию 0)
        // - AngleY–угол наклонапо вертикали (по умолчанию 0)
        // - CenterX– начальная точка для наклона по горизонтали (по умолчанию 0)
        // - CenterY– начальная точка для наклона по вертикали (по умолчанию 0)
        
        // Преобразование TranslateTransform
        // Преобразование TranslateTransform просто параллельно переносит элемент в соответствии со значениями двух свойств типа double:
        // - X - величина смещения по горизонтали (по умолчанию 0)
        // - Y- величина смещения по вертикали (по умолчанию 0)
        // TranslateTransform не дает никакого эффекта, когда применяется в режиме LayoutTransfоrm, но применение его в режиме RenderTransform удобный способ «подвинуть» элементы.

        // Преобразование MatrixTransform
        // Преобразование MatrixTransform представляет собой низкоуровневый механизм описания произвольного двумерного преобразования. У него есть единственное свойство Matrix(типа System.Windows.Media.Matrix), представлении матрицу аффинного преобразования размером 3x3.
        // M11 M12 0
        // M21 M22 0
        // OffsetX OffsetY 1
        // Конвертер типа MatrixTransformКонвертер типа MatrixTransform
        // MatrixTransform единственное преобразование, конвертер типа которого позволяет описывать его в XAML с помощью простой строки. (Класс конвертера называется TransformConverter и, хотя он ассоциирован с абстрактным классом Transform, в реальности поддерживает только тип MatrixTransform.) Например, чтобы пере-местить кнопку на 10 единиц вправо и на 20 единиц вниз, нужно написать такой код:
        // <Button RenderTransform="1,0,0,1,10,20" />
        // Через запятую указаны элементы матрицы в следующем порядке: М11, М12, М21, М22, OffsetX, OffsetY. Последовательность 1, 0, 0, 1, 0, 0 соответствует тождествен-ной матрице

        // Комбинирование преобразований
        // Комбинировать преобразования можно различными способами, например, повернуть элемент с одновременным масштабированием. Можно совместно применять преобразования в режимах LayoutTransform и RenderTransform. Или вычислить матрицу преобразования MatrixTransform, которое даст желаемый эффект. Однако, скорее всего, вы предпочтете воспользоваться классом TransformGroup.
        // Класс TransformGroup также наследует классу Transform (и потому может ис-пользоваться всюду, где разрешено применять описанные выше классы), а его задача - скомбинировать несколько дочерних объектов типа Transform. В процедурном коде объекты отдельных преобразований добавляются в коллекцию Children, в XAML это делается следующим образом:
        // Отметим, что в составе группы TransformGroup может несколько раз встречаться одно и то же преобразование. Например, два поворота MatrixTransform на 45°, эквивалентные одному повороту на 90°.

        // Резюме
        // Но самой важной частью механизма компоновки являются родительские панели. В этой главе мы для простоты пользовались только панелью StackPanel, а в следующей формально изучим как ее, так и все остальные панели.
        // Не все элементы типа FrameworkElement поддерживают преобразования!
        // Элементы, содержимое которых не является «родным» для WPF, не поддерживают преобразования, хотя и наследуют свойства LayoutTransform и RenderTransform. Например, к их числу относится элемент HwndHost, выступающий в роли владельца GDI-содержимого.
        // Элемент управления Frame, который, в принципе, может содержать HTML-разметку (описывается в главе 9 «Однодетные элементы управления»), поддерживает преобразования в полном объеме, только если в нем нет HTML.


        // !!!
    }
}