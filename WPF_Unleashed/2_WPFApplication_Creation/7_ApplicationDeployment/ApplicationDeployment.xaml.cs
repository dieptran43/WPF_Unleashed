using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._2_WPFApplication_Creation._7_ApplicationDeployment
{
    /// <summary>
    /// Interaction logic for ApplicationDeployment.xaml
    /// </summary>
    public partial class ApplicationDeployment : Window
    {
        public ApplicationDeployment()
        {
            InitializeComponent();
        }
    }

    // Стандартные приложения Windows

    // Класс Window
    // Несмотря на то, что класс Window наследует Control, его зависимость от Win32 означает, что некоторые операции, например преобразования, к нему неприменимы.
    // Внешним видом Window можно управлять с помощью таких свойств, как Icon, Title (интерпретируется как заголовок окна) и Windowstyle. Для управления положением на экране служат свойства Left и Top. Более осмысленного поведения можно добиться, присваивая свойству WindowstartupLocation значение CenterScreen или CenterOwner. Короче говоря, с помощью установки свойств можно делать почти все, что принято ожидать от окна. Скажем, если установить для Topmost значение true, то окно будет всегда отображаться поверх других, а если присвоить ShowInTaskbar значение false, то значок окна не будет показываться на панели задач.
    // Объект Window может создавать произвольное число дополнительных окон. Для этого нужно лишь создать объект класса, производного от Window, и вызвать его метод Show. Эти дополнительные окна при желании можно сделать дочерними. Дочернее окно ведет себя так же, как любое другое окно верхнего уровня, но автоматически закрывается, когда закрывается его родитель, и минимизируется тоже вместе с родителем. Иногда такие окна называют немодальными диалоговыми окнами.  
    // Если некое окно хочет сделать другое окно дочерним, оно должно записать в свойство Owner (типа Window) последнего ссылку на себя, но только после того, как родитель уже был показан на экране. Перебрать дочерние окна позволяет доступное только для чтения свойство OwnedWindows.
    // Всякий раз, как окно становится активным или неактивным (например, из-за того, что пользователь переключается между разными окнами), возникает событие Activated или Deactivated объекта Window. Можно также принудительно сделать окно активным, вызвав его метод Activate (который ведет себя так же, как функция SetForegroundWindow из Win32 API). Можно предотвратить автоматическую активацию окна при первом показе, присвоив свойству ShowActivated значение false.
    // Конструктор MainWindow вызывает метод InitializeComponent, чтобы инициализировать ту часть Window, которая определена в XAML-разметке. Далее мы видим обработку событий Closing, Closed и Initialized. Но делается это путем переопределения методов OnEventName, а не присоединения обработчика к каждому событию. По принятому соглашению управляемые классы содержат защищенные методы OnEventName, по одному для каждого события, и классы WPF – не исключение. Конечный результат не зависит от того, присоединили вы обработчик или переопределили метод, но последний способ работает чуть быстрее. Разработчики .NET Framework полагают также, что переопределение метода – более естественный способ обработки событий базового класса в его подклассе.
    // Предупреждение
    // Не забывайте вызывать InitializeComponent!
    // Событие Closing возникает, когда производится попытка закрыть окно – из программы или в результате того, что пользователь нажал кнопку Close, комбинацию клавиш Alt+F4 и т. п. Однако обработчик события может запретить закрытие окна, присвоив значение true свойству Cancel переданного ему объекта CancelEventArgs (то же самое и для той же цели можно сделать в Windows Forms).

    // Класс Application
    // Теперь осталось только реализовать точку входа в приложение, где можно будет создать и показать окно. Быть может, вы думаете, что для этого следует написать в классе MainWindow, показанном в листинге 7.1, следующий метод Main:
    // public static void Main()
    // {
    //     MainWindow window = new MainWindow();
    //     window.Show();
    // }
    // Однако это неправильно по двум причинам. Во-первых, главный поток WPF-приложения должен работать в однопоточном подразделении (STA). Значит, метод Main следует снабдить атрибутом STAThread. Но важнее другое – вызов метода Show неблокирующий, то есть он показывает окно (вызывая функцию ShowWindow из Win32 API) и сразу же возвращает управление. Но ведь обращение к Show – последняя строка Main, следовательно, приложение на этом завершится. В результате окно MainWindow на мгновение промелькнет на экране и тут же исчезнет!
    // Неужели я только что прочел слова «однопоточное подразделение»?! Это же старый-престарый COM!
    // Да, подразделения – это механизм COM. Но, как и все предшествующие каркасы для построения пользовательских интерфейсов на основе Win32 (в том числе и Windows Forms), WPF требует, чтобы главный поток работал в однопоточном подразделении. Связано это прежде всего с необходимостью обеспечить интероперабельность с технологиями, отличными от WPF
    // Если вы ничего не знаете о COM и не хотите заниматься многопоточной обработкой, пожалуйста. Просто пометьте метод Main атрибутом STAThread и забудьте этих правилах!
    // В WPF ту же задачу проще всего решить с помощью класса System.Windows.Application.

    // Метод Application.Run
    // правильная реализация Main выглядит следующим образом
    // [STAThread]
    // public static void Main()
    // {
    //     Application app = new Application();
    //     MainWindow window = new MainWindow();
    //     window.Show();
    //     app.Run(window);
    // }
    // Кроме того, в классе Application имеется свойство StartupUri, с помощью которого можно показать первое окно приложения другим способом, а именно:
    // [STAThread]
    // public static void Main()
    // {
    //     Application app = new Application();
    //     app.StartupUri = new Uri("MainWindow.xaml", UriKind.Relative);
    //     app.Run();
    // }
    // Свойство StartupUri предназначено прежде всего для переноса этой стандартной инициализации в XAML. На самом деле имеющийся в Visual Studio шаблон для проектов WPF Application определяет производный от Application класс App в XAML-файле и присваивает его свойству StartupUri ссылку на главное окно Window. В приложении Photo Gallery файл App.xaml выглядит следующим образом:
    // <Application x:Class="PhotoGallery.App"
    //     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    //     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    //     StartupUri="MainWindow.xaml"/>
    //using System.Windows;
    //namespace PhotoGallery
    //{
    //public partial class App : Application
    //{
    //public App()
    //{
    //InitializeComponent();
    //}
    //}
    //}
    // Это наиболее распространенный подход к структурированию стандартного WPF-приложения и показу его главного окна. Отметим, однако, что если вы не собираетесь ничего добавлять в застраничный файл Application, то можете его вообще опустить.
    // А где же в моем WPF-приложении метод Main?
    // StandardPhotoGallery
    // Как в WPF-приложении получить аргументы командной строки?
    // - Во-первых, отказаться от определения производного от Application класса в XAML-файле, тогда можно будет вручную написать метод Main и добраться до интересующего нас массива строк. Но проще обратиться в любом месте приложения к свойству System.Environment.GetCommandLineArgs, которое вернет тот же самый массив строк, что был передан в Main.
    // - Еще один вариант реализовать нестандартную логику инициализации (будь то обработка командной строки, вывод заставки или что-то еще) состоит в том, чтобы в качестве действия при построении для вашего производного от Application класса использовать не ApplicationDefinition, а Page. Тогда вы сможете самостоятельно написать метод Main. Реализовав в нем все, что было намечено, создайте экземпляр класса Application и вызовите его метод Run – то есть сами добавьте те три строки, которые обычно помещаются в автоматически генерируемый файл App.g.cs.
    
    // Другие применения класса Application
    // Класс Application – это не просто точка входа и диспетчер сообщений. В нем определено множество событий, свойств и методов для выполнения различных действий на уровне приложения.
    // Не полагайтесь на фиксированный индекс в коллекции Windows!
    // По умолчанию приложение завершается (то есть метод Run класса Application возвращает управление), когда закрыты все окна. Но это поведение можно изменить путем присваивания свойству ShutdownMode различных значений из перечисления ShutdownMode. Например, можно заставить приложение завершаться, когда закрывается главное окно (на которое указывает свойство MainWindow), вне зависимости от состояния других окон.
    // В классе Application есть также очень полезное свойство-коллекция Properties. Как и состояние приложения или сеанса в ASP.NET, это словарь, предназначенный для удобного хранения произвольных данных (в виде пар ключ/значение), общих для различных окон или других объектов. Вместо того чтобы определять открытые поля или свойства в своем производном от Application классе, вы можете просто поместить нужные данные в коллекцию Properties.
    // myApplication.Properties["CurrentPhotoFilename"] = filename;
    // А получить к нему доступ можно следующим образом:
    // string filename = myApplication.Properties["CurrentPhotoFilename"] as string;
    // Задачи уровня приложения обычно выполняются в коде внутри объектов Window, а значит, разным окнам приложения нужно получать ссылку на текущий экземпляр Application. К счастью, это легко можно сделать с помощью статического свойства Application.Current. Так, переменную myApplication в предыдущих фрагментах можно заменить на Application.Current:
    // Application.Current.Properties["CurrentPhotoFilename"] = filename;
    // Как в WPF создать приложение с многодокументным интерфейсом(MDI)?
    // В WPF нет встроенной поддержки для создания MDI-интерфейса, но она есть в Windows Forms. Поэтому для создания такого интерфейса в WPF-приложении, в принципе, можно воспользоваться механизмом интероперабельности.
    // Однако не делайте этого! MDI-интерфейс не способен в полной мере воспользоваться такими средствами для работы с несколькими мониторами или управления окнами, как технология Aero Snap в Windows 7 или Flip 3D в Windows Vista. Если вы хотите избежать создания нескольких окон, подумайте о реализации интерфейса с вкладками (современная вариация на тему MDI), для которого в WPF имеется поддержка.
    // Как в WPF создать приложение, которое может существовать в единственном экземпляре?
    // К WPF-приложениям применим классический подход к решению этой задачи: именованный (то есть единственный во всей операционной системе) мьютекс.
    // Ниже показано, как это сделать на C#:
    // bool mutexIsNew;
    // using (System.Threading.Mutex m =
    // new System.Threading.Mutex(true, uniqueName, out mutexIsNew))
    // {
    // if (mutexIsNew)
    // // Это первый экземпляр, запускаем приложение.
    // else
    // // Экземпляр уже работает. Выходим!
    // }
    // Часто бывает нужно не просто выйти, а передать работающему экземпляру приложения аргументы командной строки. В .NET Framework для этого можно воспользоваться классом Microsoft.VisualBasic.ApplicationServices. WindowsFormsApplicationBase, который, несмотря на свое название, доступен из приложения на любом языке, в том числе из WPF-приложений. Или поступить так: первый экземпляр открывает RPC-канал, а все остальные пытаются подключиться к нему и передать информацию.
    // Создание приложения без объекта Application
    // Хотя применение объекта Application – рекомендуемый способ структурирования WPF-приложения, это отнюдь не непререкаемое требование. Окна легко показать и без Application, но необходимо по меньшей мере организовать диспетчеризацию сообщений, чтобы не столкнуться с проблемой «мгновенного выхода», описанной в начале раздела.
    // Например, в методе Main после показа главного окна можно вызвать не Application. Run, а Dispatcher.Run. (На самом деле метод Application.Run сам вызывает Dispatcher. Run для диспетчеризации сообщений!) Но такому приложению все-таки будет недоставать важной функциональности. Так, метод Dispatcher.Run не возвращает управление, пока откуда- нибудь явно не будет вызван метод Dispatcher.ExitAllFrames (например, из обработчика события окна Closed).
    // Многопоточные приложения
    // В типичном WPF-приложении имеется один поток пользовательского интерфейса и один поток визуализации. (Поток визуализации – это деталь реализации, которая разработчикам напрямую недоступна. Он работает в фоновом режиме и занимается разными низкоуровневыми операциями, в частности композицией.) Вы можете запускать и дополнительные фоновые потоки, но они не должны напрямую обращаться к любым производным от DispatcherObject объектам, созданным в потоке пользовательского интерфейса. (Из этого правила есть несколько исключений, например замороженный объект типа Freezable.)
    // К счастью, в WPF имеется простой механизм, позволяющий любому потоку запланировать выполнение некоторого кода в потоке пользовательского интерфейса. В классе DispatcherObject определено свойство Dispatcher (типа Dispatcher). Возвращаемый им объект содержит несколько перегруженных вариантов методов Invoke (синхронный вызов) и BeginInvoke (асинхронный вызов). 
    // Всем вариантам методов Invoke и BeginInvoke в обязательном порядке передается значение перечисления DispatcherPriority, в котором определено 10 приоритетов, начиная от высшего Send (то есть выполнить немедленно) до низшего SystemIdle (выполнить, когда в очереди диспетчера больше ничего нет).
    // Можно даже создать в приложении несколько потоков пользовательского интерфейса, если вызвать метод Dispatcher.Run в запущенном вами потоке. Таким образом, если у приложения более одного окна верхнего уровня, то каждое такое окно может работать в своем потоке. Это редко бывает необходимо, но в случае, когда одно окно может начать операцию, потребляющую все ресурсы потока, такая схема способна улучшить время отклика приложения. Правда, это негативно отражается на абстракции Application, потому что она подразумевает наличие динственного диспетчера. Например, коллекция Application.Windows содержит только окна, созданные в том же потоке, что и Application.
    
    // Показ заставки
    // В идеале необходимости в заставке вообще не должно возникать, но иногда от момента запуска приложения до показа главного окна проходит заметное время – особенно при первом запуске в сеансе данного пользователя (эта задержка называется временем холодного запуска). Поэтому в WPF включены специальные средства для добавления заставки. 
    // Заставка представляет собой изображение, которое появляется сразу после запуска приложения и исчезает в момент появления главного окна. Чтобы получить эффект непрямоугольного окна, можно использовать PNG-файл с прозрачными областями, но анимированное содержимое (например, анимированный GIF-файл) не допускается. Нельзя использовать ни динамическое содержимое, ни элементы WPF, поскольку заставка показывается еще до того, как закончилась загрузка WPF. (В противном случае для показа заставки могло бы потребоваться столько же времени, сколько  для показа главного окна!) Поэтому не получится создать занимательные заставки в духе Office 2010, где есть и анимации, и обновляемая информация о состоянии. Зато вы имеете полезный эффект, почти не прикладывая усилий.
    // достаточно выбрать в диалоговом окне Add New Item (Добавить новый элемент) пункт Splash Screen (WPF)
    // Другой способ добиться того же эффекта – просто добавить нужное изображение в проект и задать для него действие при построении SplashScreen.
    
    // Создание и показ диалоговых окон





    // !!!





}
