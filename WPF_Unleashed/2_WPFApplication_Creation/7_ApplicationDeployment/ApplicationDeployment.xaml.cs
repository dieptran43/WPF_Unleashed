using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._2_WPFApplication_Creation._7_ApplicationDeployment
{
    /// <summary>
    /// Interaction logic for ApplicationDeployment.xaml
    /// </summary>
    public partial class ApplicationDeployment : Window
    {
        public ApplicationDeployment()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            GadgetWindow window = new GadgetWindow();
            window.Show();
        }
    }

    // Стандартные приложения Windows

    // Класс Window
    // Несмотря на то, что класс Window наследует Control, его зависимость от Win32 означает, что некоторые операции, например преобразования, к нему неприменимы.
    // Внешним видом Window можно управлять с помощью таких свойств, как Icon, Title (интерпретируется как заголовок окна) и Windowstyle. Для управления положением на экране служат свойства Left и Top. Более осмысленного поведения можно добиться, присваивая свойству WindowstartupLocation значение CenterScreen или CenterOwner. Короче говоря, с помощью установки свойств можно делать почти все, что принято ожидать от окна. Скажем, если установить для Topmost значение true, то окно будет всегда отображаться поверх других, а если присвоить ShowInTaskbar значение false, то значок окна не будет показываться на панели задач.
    // Объект Window может создавать произвольное число дополнительных окон. Для этого нужно лишь создать объект класса, производного от Window, и вызвать его метод Show. Эти дополнительные окна при желании можно сделать дочерними. Дочернее окно ведет себя так же, как любое другое окно верхнего уровня, но автоматически закрывается, когда закрывается его родитель, и минимизируется тоже вместе с родителем. Иногда такие окна называют немодальными диалоговыми окнами.  
    // Если некое окно хочет сделать другое окно дочерним, оно должно записать в свойство Owner (типа Window) последнего ссылку на себя, но только после того, как родитель уже был показан на экране. Перебрать дочерние окна позволяет доступное только для чтения свойство OwnedWindows.
    // Всякий раз, как окно становится активным или неактивным (например, из-за того, что пользователь переключается между разными окнами), возникает событие Activated или Deactivated объекта Window. Можно также принудительно сделать окно активным, вызвав его метод Activate (который ведет себя так же, как функция SetForegroundWindow из Win32 API). Можно предотвратить автоматическую активацию окна при первом показе, присвоив свойству ShowActivated значение false.
    // Конструктор MainWindow вызывает метод InitializeComponent, чтобы инициализировать ту часть Window, которая определена в XAML-разметке. Далее мы видим обработку событий Closing, Closed и Initialized. Но делается это путем переопределения методов OnEventName, а не присоединения обработчика к каждому событию. По принятому соглашению управляемые классы содержат защищенные методы OnEventName, по одному для каждого события, и классы WPF – не исключение. Конечный результат не зависит от того, присоединили вы обработчик или переопределили метод, но последний способ работает чуть быстрее. Разработчики .NET Framework полагают также, что переопределение метода – более естественный способ обработки событий базового класса в его подклассе.
    // Предупреждение
    // Не забывайте вызывать InitializeComponent!
    // Событие Closing возникает, когда производится попытка закрыть окно – из программы или в результате того, что пользователь нажал кнопку Close, комбинацию клавиш Alt+F4 и т. п. Однако обработчик события может запретить закрытие окна, присвоив значение true свойству Cancel переданного ему объекта CancelEventArgs (то же самое и для той же цели можно сделать в Windows Forms).

    // Класс Application
    // Теперь осталось только реализовать точку входа в приложение, где можно будет создать и показать окно. Быть может, вы думаете, что для этого следует написать в классе MainWindow, показанном в листинге 7.1, следующий метод Main:
    // public static void Main()
    // {
    //     MainWindow window = new MainWindow();
    //     window.Show();
    // }
    // Однако это неправильно по двум причинам. Во-первых, главный поток WPF-приложения должен работать в однопоточном подразделении (STA). Значит, метод Main следует снабдить атрибутом STAThread. Но важнее другое – вызов метода Show неблокирующий, то есть он показывает окно (вызывая функцию ShowWindow из Win32 API) и сразу же возвращает управление. Но ведь обращение к Show – последняя строка Main, следовательно, приложение на этом завершится. В результате окно MainWindow на мгновение промелькнет на экране и тут же исчезнет!
    // Неужели я только что прочел слова «однопоточное подразделение»?! Это же старый-престарый COM!
    // Да, подразделения – это механизм COM. Но, как и все предшествующие каркасы для построения пользовательских интерфейсов на основе Win32 (в том числе и Windows Forms), WPF требует, чтобы главный поток работал в однопоточном подразделении. Связано это прежде всего с необходимостью обеспечить интероперабельность с технологиями, отличными от WPF
    // Если вы ничего не знаете о COM и не хотите заниматься многопоточной обработкой, пожалуйста. Просто пометьте метод Main атрибутом STAThread и забудьте этих правилах!
    // В WPF ту же задачу проще всего решить с помощью класса System.Windows.Application.

    // Метод Application.Run
    // правильная реализация Main выглядит следующим образом
    // [STAThread]
    // public static void Main()
    // {
    //     Application app = new Application();
    //     MainWindow window = new MainWindow();
    //     window.Show();
    //     app.Run(window);
    // }
    // Кроме того, в классе Application имеется свойство StartupUri, с помощью которого можно показать первое окно приложения другим способом, а именно:
    // [STAThread]
    // public static void Main()
    // {
    //     Application app = new Application();
    //     app.StartupUri = new Uri("MainWindow.xaml", UriKind.Relative);
    //     app.Run();
    // }
    // Свойство StartupUri предназначено прежде всего для переноса этой стандартной инициализации в XAML. На самом деле имеющийся в Visual Studio шаблон для проектов WPF Application определяет производный от Application класс App в XAML-файле и присваивает его свойству StartupUri ссылку на главное окно Window. В приложении Photo Gallery файл App.xaml выглядит следующим образом:
    // <Application x:Class="PhotoGallery.App"
    //     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    //     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    //     StartupUri="MainWindow.xaml"/>
    //using System.Windows;
    //namespace PhotoGallery
    //{
    //public partial class App : Application
    //{
    //public App()
    //{
    //InitializeComponent();
    //}
    //}
    //}
    // Это наиболее распространенный подход к структурированию стандартного WPF-приложения и показу его главного окна. Отметим, однако, что если вы не собираетесь ничего добавлять в застраничный файл Application, то можете его вообще опустить.
    // А где же в моем WPF-приложении метод Main?
    // StandardPhotoGallery
    // Как в WPF-приложении получить аргументы командной строки?
    // - Во-первых, отказаться от определения производного от Application класса в XAML-файле, тогда можно будет вручную написать метод Main и добраться до интересующего нас массива строк. Но проще обратиться в любом месте приложения к свойству System.Environment.GetCommandLineArgs, которое вернет тот же самый массив строк, что был передан в Main.
    // - Еще один вариант реализовать нестандартную логику инициализации (будь то обработка командной строки, вывод заставки или что-то еще) состоит в том, чтобы в качестве действия при построении для вашего производного от Application класса использовать не ApplicationDefinition, а Page. Тогда вы сможете самостоятельно написать метод Main. Реализовав в нем все, что было намечено, создайте экземпляр класса Application и вызовите его метод Run – то есть сами добавьте те три строки, которые обычно помещаются в автоматически генерируемый файл App.g.cs.
    
    // Другие применения класса Application
    // Класс Application – это не просто точка входа и диспетчер сообщений. В нем определено множество событий, свойств и методов для выполнения различных действий на уровне приложения.
    // Не полагайтесь на фиксированный индекс в коллекции Windows!
    // По умолчанию приложение завершается (то есть метод Run класса Application возвращает управление), когда закрыты все окна. Но это поведение можно изменить путем присваивания свойству ShutdownMode различных значений из перечисления ShutdownMode. Например, можно заставить приложение завершаться, когда закрывается главное окно (на которое указывает свойство MainWindow), вне зависимости от состояния других окон.
    // В классе Application есть также очень полезное свойство-коллекция Properties. Как и состояние приложения или сеанса в ASP.NET, это словарь, предназначенный для удобного хранения произвольных данных (в виде пар ключ/значение), общих для различных окон или других объектов. Вместо того чтобы определять открытые поля или свойства в своем производном от Application классе, вы можете просто поместить нужные данные в коллекцию Properties.
    // myApplication.Properties["CurrentPhotoFilename"] = filename;
    // А получить к нему доступ можно следующим образом:
    // string filename = myApplication.Properties["CurrentPhotoFilename"] as string;
    // Задачи уровня приложения обычно выполняются в коде внутри объектов Window, а значит, разным окнам приложения нужно получать ссылку на текущий экземпляр Application. К счастью, это легко можно сделать с помощью статического свойства Application.Current. Так, переменную myApplication в предыдущих фрагментах можно заменить на Application.Current:
    // Application.Current.Properties["CurrentPhotoFilename"] = filename;
    // Как в WPF создать приложение с многодокументным интерфейсом(MDI)?
    // В WPF нет встроенной поддержки для создания MDI-интерфейса, но она есть в Windows Forms. Поэтому для создания такого интерфейса в WPF-приложении, в принципе, можно воспользоваться механизмом интероперабельности.
    // Однако не делайте этого! MDI-интерфейс не способен в полной мере воспользоваться такими средствами для работы с несколькими мониторами или управления окнами, как технология Aero Snap в Windows 7 или Flip 3D в Windows Vista. Если вы хотите избежать создания нескольких окон, подумайте о реализации интерфейса с вкладками (современная вариация на тему MDI), для которого в WPF имеется поддержка.
    // Как в WPF создать приложение, которое может существовать в единственном экземпляре?
    // К WPF-приложениям применим классический подход к решению этой задачи: именованный (то есть единственный во всей операционной системе) мьютекс.
    // Ниже показано, как это сделать на C#:
    // bool mutexIsNew;
    // using (System.Threading.Mutex m =
    // new System.Threading.Mutex(true, uniqueName, out mutexIsNew))
    // {
    // if (mutexIsNew)
    // // Это первый экземпляр, запускаем приложение.
    // else
    // // Экземпляр уже работает. Выходим!
    // }
    // Часто бывает нужно не просто выйти, а передать работающему экземпляру приложения аргументы командной строки. В .NET Framework для этого можно воспользоваться классом Microsoft.VisualBasic.ApplicationServices. WindowsFormsApplicationBase, который, несмотря на свое название, доступен из приложения на любом языке, в том числе из WPF-приложений. Или поступить так: первый экземпляр открывает RPC-канал, а все остальные пытаются подключиться к нему и передать информацию.
    // Создание приложения без объекта Application
    // Хотя применение объекта Application – рекомендуемый способ структурирования WPF-приложения, это отнюдь не непререкаемое требование. Окна легко показать и без Application, но необходимо по меньшей мере организовать диспетчеризацию сообщений, чтобы не столкнуться с проблемой «мгновенного выхода», описанной в начале раздела.
    // Например, в методе Main после показа главного окна можно вызвать не Application. Run, а Dispatcher.Run. (На самом деле метод Application.Run сам вызывает Dispatcher. Run для диспетчеризации сообщений!) Но такому приложению все-таки будет недоставать важной функциональности. Так, метод Dispatcher.Run не возвращает управление, пока откуда- нибудь явно не будет вызван метод Dispatcher.ExitAllFrames (например, из обработчика события окна Closed).
    // Многопоточные приложения
    // В типичном WPF-приложении имеется один поток пользовательского интерфейса и один поток визуализации. (Поток визуализации – это деталь реализации, которая разработчикам напрямую недоступна. Он работает в фоновом режиме и занимается разными низкоуровневыми операциями, в частности композицией.) Вы можете запускать и дополнительные фоновые потоки, но они не должны напрямую обращаться к любым производным от DispatcherObject объектам, созданным в потоке пользовательского интерфейса. (Из этого правила есть несколько исключений, например замороженный объект типа Freezable.)
    // К счастью, в WPF имеется простой механизм, позволяющий любому потоку запланировать выполнение некоторого кода в потоке пользовательского интерфейса. В классе DispatcherObject определено свойство Dispatcher (типа Dispatcher). Возвращаемый им объект содержит несколько перегруженных вариантов методов Invoke (синхронный вызов) и BeginInvoke (асинхронный вызов). 
    // Всем вариантам методов Invoke и BeginInvoke в обязательном порядке передается значение перечисления DispatcherPriority, в котором определено 10 приоритетов, начиная от высшего Send (то есть выполнить немедленно) до низшего SystemIdle (выполнить, когда в очереди диспетчера больше ничего нет).
    // Можно даже создать в приложении несколько потоков пользовательского интерфейса, если вызвать метод Dispatcher.Run в запущенном вами потоке. Таким образом, если у приложения более одного окна верхнего уровня, то каждое такое окно может работать в своем потоке. Это редко бывает необходимо, но в случае, когда одно окно может начать операцию, потребляющую все ресурсы потока, такая схема способна улучшить время отклика приложения. Правда, это негативно отражается на абстракции Application, потому что она подразумевает наличие динственного диспетчера. Например, коллекция Application.Windows содержит только окна, созданные в том же потоке, что и Application.
    
    // Показ заставки
    // В идеале необходимости в заставке вообще не должно возникать, но иногда от момента запуска приложения до показа главного окна проходит заметное время – особенно при первом запуске в сеансе данного пользователя (эта задержка называется временем холодного запуска). Поэтому в WPF включены специальные средства для добавления заставки. 
    // Заставка представляет собой изображение, которое появляется сразу после запуска приложения и исчезает в момент появления главного окна. Чтобы получить эффект непрямоугольного окна, можно использовать PNG-файл с прозрачными областями, но анимированное содержимое (например, анимированный GIF-файл) не допускается. Нельзя использовать ни динамическое содержимое, ни элементы WPF, поскольку заставка показывается еще до того, как закончилась загрузка WPF. (В противном случае для показа заставки могло бы потребоваться столько же времени, сколько  для показа главного окна!) Поэтому не получится создать занимательные заставки в духе Office 2010, где есть и анимации, и обновляемая информация о состоянии. Зато вы имеете полезный эффект, почти не прикладывая усилий.
    // достаточно выбрать в диалоговом окне Add New Item (Добавить новый элемент) пункт Splash Screen (WPF)
    // Другой способ добиться того же эффекта – просто добавить нужное изображение в проект и задать для него действие при построении SplashScreen.
    
    // Создание и показ диалоговых окон
    // В ОС Windows имеется набор стандартных диалоговых окон (модальных окон), позволяющих выполнять такие типичные операции, как открытие или сохранение файлов, обзор папок, выбор шрифта или цвета и печать. Вы и сами можете создавать диалоговые окна с таким же модальным поведением. (Иными словами, это окна, которые не позволяют взаимодействовать с текущим окном, пока вы их явно не закроете.) 

    // Стандартные диалоговые окна
    // WPF не рисует эти диалоговые окна самостоятельно, а обращается к функциям из Win32 API
    // Для использования стандартного диалогового окна достаточно создать объект соответствующего ему класса, вызвать его метод ShowDialog, а затем обработать результат. Например, в приложении Photo Gallery диалоговое окно PrintDialog для печати фотографий используется следующим образом 
    //void printMenu_Click(object sender, RoutedEventArgs e)
    //{
    //    string filename = (pictureBox.SelectedItem as ListBoxItem).Tag as string;
    //    Image image = new Image();
    //    image.Source = new BitmapImage(new Uri(filename, UriKind.RelativeOrAbsolute));
    //    PrintDialog pd = new PrintDialog();
    //    if (pd.ShowDialog() == true) // результат может быть равен
    //    true, false или null
    //    pd.PrintVisual(image, Path.GetFileName(filename) + " from Photo Gallery");
    //}
    // Даже не думайтео том, чтобы написать собственное диалоговое окно взамен стандартного, предоставляемого Windows. 
    // Совет
    // И в Windows Forms, и в WPF имеются управляемые классы, обертывающие стандартные диалоговые окна Windows. Однако в текущей версии WPF не для всех диалоговых окон есть соответствующие классы. 
    
    // Нестандартные диалоговые окна
    // В WPF такие диалоговые окна создаются и используются почти так же, как объекты Window. На самом деле это и есть объекты Window, только с небольшим дополнением для возврата так называемого результата диалогового окна.
    // Чтобы показать окно Window в виде модального (в отличие от немодального) диалогового окна, достаточно вызвать метод ShowDialog вместо Show. В отличие от Show, метод ShowDialog блокирует выполнение программы (то есть не возвращает управление, пока окно не будет закрыто) и возвращает допускающее null булевское значение (тип bool? в C#). Вот как в приложении Photo Gallery используется нестандартное диалоговое окно RenameDialog: 
    //void renameMenu_Click(object sender, RoutedEventArgs e)
    //{
    //    string filename = (pictureBox.SelectedItem as ListBoxItem).Tag as string;
    //    RenameDialog dialog = new RenameDialog(
    //    Path.GetFileNameWithoutExtension(filename));
    //    if (dialog.ShowDialog() == true) // результат может быть равен true, 
    //        // false или null
    //        {
    //        // Пытаемся переименовать файл
    //        try
    //        {
    //            File.Move(filename, Path.Combine(Path.GetDirectoryName(filename),
    //            dialog.NewFilename) + Path.GetExtension(filename));
    //        }
    //        catch (Exception ex)
    //        {
    //            MessageBox.Show(ex.Message, "Cannot Rename File", MessageBoxButton.OK,
    //            MessageBoxImage.Error);
    //        }
    //    }
    //}
    // Чтобы задать возвращаемое этим методом значение, достаточно присвоить его свойству DialogResult (типа bool?). Побочным результатом установки DialogResult является закрытие окна. Следовательно, обработчик нажатия кнопки OK в диалоговом окне RenameDialog мог бы выглядеть следующим образом: 
    //void okButton_Click(object sender, RoutedEventArgs e)
    //{
    //    this.DialogResult = true;
    //}
    // А можно просто присвоить свойству IsDefault значение true, что позволяет достичь того же эффекта без написания процедурного кода.
    // Еще одно применение метода ShowDialog
    // Чтобы обеспечить блокировку доступа к родительскому окну, не прерывая процесса диспетчеризации сообщений, метод ShowDialog в классе Window, по сути дела, вызывает Dispatcher.Run – точно так же, как это делает метод Application.Run. Поэтому для того, чтобы корректно запустить WPF-приложение без использования класса Application, можно прибегнуть к следующему приему:
    //[STAThread]
    //public static void Main()
    //{
    //    MainWindow window = new MainWindow();
    //    window.ShowDialog();
    //}

    // Сохранение и восстановление состояния приложения
    // Стандартное приложение Windows может обращаться ко всем ресурсам компьютера (в пределах параметров безопасности работающего с ним пользователя), поэтому есть несколько вариантов сохранения данных, например в реестре или в локальной файловой системе. Но у этих классических способов есть и интересная альтернатива: изолированное хранилище .NET Framework.
    //protected override void OnClosed(EventArgs e)
    //{
    //    base.OnClosed(e);
    //    // Перед тем как закрыть приложение, записываем избранные элементы
    //    IsolatedStorageFile f = IsolatedStorageFile.GetUserStoreForAssembly();
    //    using (IsolatedStorageFileStream stream = new IsolatedStorageFileStream("myFile", FileMode.Create, f))
    //    using (StreamWriter writer = new StreamWriter(stream))
    //    {
    //        foreach (TreeViewItem item in favoritesItem.Items)
    //            writer.WriteLine(item.Tag as string);
    //    }
    //}

    //protected override void OnInitialized(EventArgs e)
    //{
    //    base.OnInitialized(e);
    //    // В момент инициализации приложения считываются все избранные элементы
    //    IsolatedStorageFile f = IsolatedStorageFile.GetUserStoreForAssembly();
    //    using (IsolatedStorageFileStream stream = new IsolatedStorageFileStream("myFile", FileMode.OpenOrCreate, f))
    //    using (StreamReader reader = new StreamReader(stream))
    //    {
    //        string line = reader.ReadLine();
    //        while (line != null)
    //        {
    //            AddFavorite(line);
    //            line = reader.ReadLine();
    //        }
    //    }
    //}
    // Классы IsolatedStorageFile и IsolatedStorageFileStream находятся в пространстве имен System.IO.IsolatedStorage. Все данные, помещенные в изолированное хранилище, физически находятся в скрытой папке внутри папки Documents (Документы) текущего пользователя.
    // Совет
    // Если вы хотите еще больше упростить сохранение и восстановление настроек приложения, ознакомьтесь с генерируемым Visual Studio классом Settings (в разделе Properties\Settings.settings). Этот механизм позволяет сохранять данные в конфигурационном файле приложения и обеспечивает строго типизированный доступ к ним.
    
    // Развертывание: технология ClickOnce и установщик Windows
    // Когда речь заходит о развертывании стандартного приложения Windows, вы, вероятно, сразу представляете  себе программу установки, которая помещает файлы в каталог Program Files (или в каталог, указанный пользователем), регистрирует необходимые компоненты, добавляет себя в список установленных программ на Панели управления и, быть может, в меню Пуск и на рабочий стол. 
    // В Visual Studio доступ к функциональности ClickOnce открывает Мастер, вызваемый командами меню Build→Publish (Построение→ Публикация).
    // Короче говоря, установщик Windows имеет следующие преимущества по сравнению с ClickOnce:
    // - Поддерживает настраиваемый пользовательский интерфейс, например показ лицензионного соглашения
    // - Позволяет задавать местоположение файлов при установке
    // - Поддерживает (с помощью настраиваемых действий) написание произвольного кода, исполняемого на этапе установки
    // - Поддерживает установку общих сборок в глобальный кэш сборок
    // - Поддерживает регистрацию COM-компонентов и сопоставлений файлов
    // - Поддерживает установку для компьютера в целом (то есть таким образом, что программа становится доступна всем пользователям)
    // - Поддерживает автономную установку с CD/DVD
    // ClickOnce имеет следующие преимущества по сравнению с инсталлятором Windows:
    // - Включает встроенную поддержку автоматического обновления и отката к предыдущей версии.
    // - Предлагает две модели установки: веб-модель, когда приложение идентифицируется посредством URL-адресов в браузере и после закрытия как бы «исчезает » (хотя на самом деле сохраняется в кэше), и традиционную модель, в которой у приложения  может  быть ярлык в меню Пуск и оно присутствует в списке установленных программ на Панели управления.
    // - Гарантирует, что устанавливаемое приложение не окажет никакого влияния на другие приложения, потому что все файлы помещаются в изолированную область и не производится никакой регистрации.
    // - Гарантирует полную деинсталляцию, так как во время установки никакой написанный пользователем код не выполняется (правда, приложения с полным доверием все-таки могут оставлять после себя какие- то следы на компьютере).
    // - Интегрируется с имеющимся в .NET механизмом разграничения доступа кода, который позволяет пользователю запускать даже те приложения, которым он не доверяет на все сто процентов. 
    // СОВЕТ
    // Многие не понимают, что технологию ClickOnce можно применять даже тогда, когда приложение содержит неуправляемый код, при условии, правда, что главный исполняемый файл не является полностью неуправляемым. Однако, чтобы это заработало, возможно, придется внести некоторые изменения в неуправляемый код. Например, вместо регистрации COM-объектов придется прибегнуть к технологии COM без регистрации.
    
    // Приложения Windows с навигацией
    // Хотя понятие навигации обычно ассоциируется с веб-браузером, такая же схема применяется и во многих других приложениях Windows, например в Проводнике Windows, Windows Media Player и, конечно же, в программе Windows Live Photo Gallery, послужившей прототипом для нашего приложения Photo.
    // мы ознакомимся с рядом дополнительных элементов, в частности NavigationWindow и Page.

    // Страницы и их навигационные контейнеры
    // При использовании навигации в WPF содержимое обычно организуется в виде элементов Page. (Page – это, по существу, упрощенная версия класса Window.) Элементы Page могут располагаться в одном из двух встроенных навигационных контейнеров: NavigationWindow или Frame. 
    // Они предоставляют средства для перехода от одной страницы к другой, «журнал», в котором хранится история навигации, и ряд относящихся к навигации событий.
    // В чем разница между NavigationWindow и Frame?
    // Функционально эти классы почти одинаковы за одним исключением: NavigationWindow ведет себя скорее, как окно браузера верхнего уровня, а Frame – как HTML-элемент FRAME или IFRAME. Если NavigationWindow – окно верхнего уровня, то Frame может заполнять произвольную (но прямоугольную) область внутри своего родительского элемента. Frame может быть вложен в NavigationWindow или в другой Frame. По умолчанию вдоль верхнего края NavigationWindow располагается панель с кнопками Назад/ Вперед, а во фрейме ее нет, но в обоих случаях панель можно добавить или убрать с помощью свойства ShowsNavigationUI, содержащегося внутристраницы Page. Кроме того, в классе NavigationWindow имеется свойство ShowsNavigationUI, а в классеFrame – свойство NavigationUIVisibility, оба они позволяют показать или скрыть эту панель вне зависимостиот настроек Page.
    // В версии приложения Photo Gallery с навигацией свойство StartupUri объекта Application указывает на следующий объект NavigationWindow:
    // <NavigationWindow x:Class="PhotoGallery.Container"
    // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    // Title="Photo Gallery" Source="MainPage.xaml">
    // </NavigationWindow>
    // Корневым элементом в файле MainPage.xaml, на который ссылается этот элемент NavigationWindow, является элемент Page, который содержит все, что раньше находилось в файле MainWindow.xaml:
    // <Page x:Class="PhotoGallery.MainPage"
    // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    // Title="Photo Gallery" Loaded="Page_Loaded">
    // ... Содержимое конкретного приложения...
    // </Page>
    // Если фотоальбом помещен внутрь NavigationWindow, то сверху появляется дополнительная панель 
    // Совет
    // Навигационные контейнеры в WPF могут содержать не только элементы Page, но также HTML-файлы (находящиеся как в локальной файловой системе, так и в Интернете)! Можно даже переходить от WPF-содержимого к HTML-содержимому и обратно. Как это делается, будет описано в следующем разделе.
    // Чтобы получить экземпляр NavigationService, следует вызвать статический метод NavigationService.GetNavigationService, передав ему экземпляр Page. Но можно поступить и проще, обратившись к свойству NavigationService объекта Page. Например, следующий код устанавливает заголовок страницы, который будет показан в раскрывающемся меню, ассоциированном с кнопками Назад и Вперед:
    // this.NavigationService.Title = "Main Photo Gallery Page";
    // А чтобы обновить текущую страницу, нужно написать:
    // this.NavigationService.Refresh();
    // Но в классе Page имеется и несколько собственных свойств, управляющих поведением родительского контейнера, например WindowHeight, WindowWidth и WindowTitle. Они особенно удобны, потому что могут быть установлены в XAML- разметке элемента Page.
    
    // Переходы между страницами
    // Есть три основных способа навигации:
    // - Посредством метода Navigate
    // - С помощью гиперссылок (объектов Hyperlink)
    // - С помощью журнала

    // Вызов метода Navigate
    // // Перейти к экземпляру страницы
    // PhotoPage nextPage = new PhotoPage();
    // this.NavigationService.Navigate(nextPage);
    // // Или перейти на страницу с заданным URI
    // this.NavigationService.Navigate(new Uri("PhotoPage.xaml", UriKind.Relative));
    // Корневым элементом XAML-файла должен быть элемент Page.
    // Представление метода Navigate в виде двух свойств
    // Чтобы перейти к объекту Page, достаточно установить свойство Content:
    // this.NavigationService.Content = nextPage;
    // а перейти по URI можно, установив свойство Source:
    // this.NavigationService.Source = new Uri("PhotoPage.xaml", UriKind.Relative);
    // Чтобы перейти к HTML-странице, необходимо воспользоваться перегруженным вариантом метода Navigate, которому передается URI. Например:
    // this.NavigationService.Navigate(new Uri("http://www.adamnathan.net/wpf"));

    // Использование элемента Hyperlink
    // Для простых схем навигации в WPF имеется элемент Hyperlink, который ведет себя во многом аналогично гиперссылкам в HTML. Если элемент Hyperlink вложен в TextBlock то, как и в случае HTML-тега A, содержимое визуализируется в виде гиперссылки, после щелчка по которой выполняется переход от текущей страницы к целевой. Целевая страница определяется свойством NavigateUri элемента Hyperlink (аналог атрибута href в HTML). 
    //<TextBlock>
    //Click <Hyperlink NavigateUri="PhotoPage.xaml">here</Hyperlink> to view the photo.
    //</TextBlock>
    // Таким образом, Hyperlink – это просто более длинная форма записи HTML-тега A. С этими объектами можно работать и из программы, как с любым другим элементом WPF, но основное их назначение – описывать простые HTML-подобные ссылки, когда целевая страница известна заранее. 
    // Совет
    // Если вам нужна гибкость программной навигации в сочетании с удобными средствами автоматического форматирования текста, предоставляемыми классом Hyperlink, то можете указать в Hyperlink фиктивное значение свойства NavigateUri, а потом в обработчике события Click этого элемента вызвать метод Navigate, задав нужный адрес перехода.
    // Совет
    // Класс Hyperlink поддерживает и дополнительные возможности – как и гиперссылки в HTML. Например, для перехода в конкретный фрейм Frame в случае, когда фреймов несколько, следует присвоить свойству TargetName элемента Hyperlink имя нужного фрейма. Чтобы перейти к определенному месту внутри страницы Page (как в HTML-якорях, обозначаемых символом #), достаточно дописать в конец URI символ # и имя любого элемента на целевой странице.
    // Как задать в HTML-странице ссылку, ведущую на элемент WPF Page?
    // Вместо этого для осуществления навигации из HTML в WPF можно воспользоваться приемом, похожим на описанный выше: в качестве значения HREF задать какое-нибудь фиктивное значение и написать обработчик события Navigating, в котором динамически изменить цель, вызвав метод Navigate самостоятельно (Navigating и другие события рассматриваются в следующем разделе). В зависимости от характера желаемого взаимодействия между HTML и WPF можно также рассмотреть возможность создания приложения XAML для браузера или автономной XAML-страницы 

    // Использование журнала
    // С обоими навигационными контейнерами ассоциирован журнал, в котором хранится история навигации, – точно так же, как в браузере. 
    // Действие - Результат
    // Назад - Помещает текущую страницу в стек прямых переходов, извлекает страницу из стека обратных переходов и переходит на нее
    // Вперед - Помещает текущую страницу в стек обратных переходов, извлекает страницу из стека прямых переходов и переходит на нее
    // Любая другая навигация - Помещает текущую страницу в стек обратных переходов и опустошает стек прямых переходов
    // Действия перехода назад и вперед могут быть инициированы как пользователем, так и программой – путем вызова методов GoBack и GoForward навигационного контейнера (предварительно вызвав соответственно метод CanGoBack или CanGoForward, чтобы избежать исключения в результате попытки извлечения из пустого стека).
    // В объекте NavigationWindow журнал есть всегда, тогда как в объекте Frame собственного журнала может и не быть; это зависит от его свойства JournalOwnership, которое может принимать следующие значения:
    // - OwnsJournal – у фрейма есть свой журнал.
    // - UsesParentJournal – история хранится в журнале родительского контейнера или не хранится вовсе, если у родителя нет журнала.
    // - Automatic – эквивалентно UsesParentJournal, если фрейм содержится в любом из двух навигационных контейнеров (NavigationWindow или Frame), в противном случае эквивалентно OwnsJournal. Это значение по умолчанию. 
    // Совет
    // В случае перехода на страницу Page с помощью URI (неважно, путем вызова метода Navigate или посредством гиперссылки Hyperlink) создается новый экземпляр Page, даже если вы уже посещали эту страницу. Поэтому, если требуется, чтобы страница «запоминала» свои данные, необходимо хранить состояния отдельно (например, в статических переменных или в словаре Application.Properties). (При вызове варианта Navigate, принимающего экземпляр Page, вы, разумеется, вольны сами решать, передать ли ему новый или старый объект.) Однако в случае навигации по журналу можно установить режим принудительного использования одного и того же объекта Page, присвоив его присоединенному свойству JournalEntry.KeepAlive значение true.
    // Совет
    // Объект Page может потребовать не заносить себя в журнал, присвоив своему свойству RemoveFromJournal значение true. Это имеет смысл для страниц, являющихся частью некоторой последовательности шагов, которые нельзя открывать в произвольном порядке после завершения операции.
    // Действия Вперед и Назад обрабатываются журналом, а как реализовать аналоги действий браузера Остановить и Обновить?
    // Для кнопок Остановить и Обновить нет встроенной поддержки в пользовательском интерфейсе, но навигационные контейнеры вполне способны выполнять соответствующие действия. Чтобы в любой момент остановить еще не законченную операцию перехода, вызовите метод контейнера StopLoading. 
    // А для обновления страницы достаточно вызвать метод контейнера Refresh без параметров. Это все равно, что вызвать метод Navigate, передав ему URI или экземпляр текущей страницы, только обработчику события Navigating в качестве данных передается значение NavigationMode.Refresh на случай, если тому потребуется модифицировать свое поведение в подобной ситуации. 
    // Использование журнала для других целей
    // Например, на основе журнала можно построить специализированную схему отмены и повтора операций, причем большую часть функциональности вы получите задаром.
    // Для этого вызовите метод контейнера AddBackEntry, передав ему объект типа CustomContentState. CustomContentState – абстрактный класс, поэтому необходимо создать его подкласс, в котором реализован метод Replay. Этот метод вызывается, когда в результате перехода вперед или назад данный объект становится текущим. Можно также переопределить еще и свойство JournalEntryName, которое возвращает метку данного объекта в раскрывающемся списке. 

    // События навигации
    // Вне зависимости от того, как инициирована навигация – путем вызова метода Navigate, с помощью гиперссылок Hyperlink или по журналу, – она всегда производится асинхронно. В процессе навигации генерируется ряд событий, позволяющих сообщать пользователю подробную информацию или даже прервать навигацию.
    // Событие NavigationProgress генерируется периодически вплоть до возникновения события Navigated. На рисунке не показано событие NavigationStopped. Оно генерируется вместо LoadCompleted, еслинавигация была отменена или произошла ошибка.
    // Совет
    // Показанные события генерирует навигационный контейнер, когда они возникают внутри него (включая и дочерние контейнеры). Но те же самые события генерирует и объект Application, чтобы в одном месте можно было обработать события от всех навигационных контейнеров в приложении.
    // Предупреждение
    // События навигации не генерируются при переходе между HTML-страницами!

    // Передача данных между страницами
    // В веб-приложениях на базе HTML данные можно кодировать в параметрах URL или использовать переменные на стороне сервера. В WPF для передачи и возврата данных применяются разнообразные способы.

    // Передача данных странице
    // WPF поддерживает схему, аналогичную параметрам URL, с помощью перегруженных вариантов метода Navigate, которые принимают дополнительный параметр типа Object. Такие варианты есть для метода, принимающего как экземпляр Page, так и Uri. В объекте- параметре можно передать произвольные данные (встроенный тип, массив, структуру данных и т. д.), которые получит целевая страница. Например: 
    // int photoId = 10;
    // // Перейти к экземпляру Page
    // PhotoPage nextPage = new PhotoPage();
    // this.NavigationService.Navigate(nextPage, photoId);
    // // Или перейти к странице по URI
    // this.NavigationService.Navigate(
    // new Uri("PhotoPage.xaml", UriKind.Relative), photoId);
    // Чтобы целевая страница могла получить данные, она должна обработать событие LoadCompleted навигационного контейнера и опросить свойство ExtraData аргумента события:
    // this.NavigationService.LoadCompleted += new LoadCompletedEventHandler(container_LoadCompleted);
    // void container_LoadCompleted(object sender, NavigationEventArgs e)
    // {
    //     if (e.ExtraData != null)
    //     LoadPhoto((int)e.ExtraData);
    // }
    // Но есть и более простая схема передачи данных – воспользоваться основным вариантом метода Navigate, который принимает экземпляр Page, и определить в классе целевой страницы конструктор, принимающий дополнительные данные 
    // int photoId = 10;
    // // Перейти к экземпляру Page
    // PhotoPage nextPage = new PhotoPage(photoId);
    // this.NavigationService.Navigate(nextPage);
    // Чтобы этот пример заработал, в классе PhotoPage должен быть такой конструктор:
    // public PhotoPage(int id)
    // {
    //     LoadPhoto(id);
    // }
    // Третий способ – организовать глобальное обобществление данных с помощью коллекции Properties объекта Application, которую мы обсуждали выше в этой главе.
    // // Перейти к экземпляру Page или по URI
    // Application.Properties["PhotoId"] = 10;
    // this.NavigationService.Navigate(...);
    // Целевая страница затем может проверить значение в любом месте кода после вызова Navigate:
    // if (Application.Properties["PhotoId"] != null)
    //  LoadPhoto((int)Application.Properties["PhotoId"]);

    // Возврат данных от страницы с помощью PageFunction
    // WPF предлагает еще один механизм «возврата» данныхпредыдущей странице безопасным относительно типов способом с автоматической навигацией обратно к ней.
    // Page Function (WPF):
    // <PageFunction
    // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    // xmlns:sys="clr-namespace:System;assembly=mscorlib"
    // x:Class="MyProject.PageFunction1"
    // x:TypeArguments="sys:String"
    // Title="PageFunction1">
    // <Grid>
    // </Grid>
    // </PageFunction>
    // Обратите внимание на ключевое слово TypeArguments. PageFunction – в действительности универсальный класс (то есть имеет вид PageFunction<T>), где аргумент-тип представляет собой тип возвращаемого значения. 
    // Поскольку PageFunction – подкласс Page, то на элемент этого типа можно переходить точно так же, как на любую другую страницу:
    // PageFunction1 nextPage = new PageFunction1<string>();
    // this.NavigationService.Navigate(nextPage);
    // Для получения возвращенного значения исходная страница должна обработать событие Return объекта PageFunction:
    // nextPage.Return += new ReturnEventHandler<string>(nextPage_Return);
    // void nextPage_Return(object sender, ReturnEventArgs<string> e)
    // {
    //    string returnValue = e.Result;
    // }
    // Страница, производная от PageFunction, может вернуть данные, обернув их типом ReturnEventArgs и вызвав метод OnReturn, унаследованный от базового класса PageFunction:
    // OnReturn(new ReturnEventArgs<string>("the data"));

    // Приложения-гаджеты
    // WPF существенно упрощает создание непрямоугольных окон верхнего уровня. Имея такую поддержку, вы можете придать стандартному во всех прочих отношениях приложению прихотливое обрамление.
    // 1. Присвоить свойству AllowsTransparency объекта Window значение true. Если вы делаете это из программы, не устанавливайте его до показа окна. В противном случае будет возбуждено исключение InvalidOperationException.)
    // 2. Присвоить свойству Windowstyle объекта Window значение None, чтобы полностью удалить обрамление. (Попытка установить любое другое значение в сочетании с AllowsTransparency="True" заканчивается исключением InvalidOperationException.)
    // 3. Присвоить свойству Background объекта Window значение Transparent. В результате содержимое не будет окружено непрозрачным прямоугольником.
    // 4. Решить, как пользователь будет перемещать окно по экрану, и в нужных местах вызывать для этой цели метод DragMove объекта Window. Техническиэто необязательно, но приложение, окно которого нельзя передвигать, не порадует пользователя.
    // 5. Подумать о добавлении кнопки закрытия, чтобы пользователю не приходилось завершать приложение щелчком правой кнопки мыши по значку на панели задач. Это особенно важно, если свойству ShowInTaskbar присвоено значение false!

    // XAML-приложения для браузера
    // WPF поддерживает создание приложений, способных работать непосредственно в веб-браузере. Они называются XAML-приложениями для браузера (XAML Browser Applications – XBAPs)
    // Работают ли XBAP-приложения в любой операционной системе и в любом браузере?
    // Нет. В отличие от приложений Silverlight, XBAP-приложениям необходима полная версия .NET Framework (3.0 или выше)
    // Основные различия:
    // - По умолчанию доступны не все средства WPF и .NET Framework.
    // - Навигация интегрирована в браузер.
    // - Развертывание осуществляется по-другому.
    // Итак, как же создается XBAP-приложение? В Visual Studio достаточно выполнить следующие шаги:
    // 1. Создать новый проект, в Visual Studio его тип, как и положено, называется WPF Browser Application.
    // 2. Сконструировать пользовательский интерфейс внутри элемента Page и написать застраничный код.
    // 3. Откомпилировать и запустить проект.
    // Как работают XAML-приложения для браузера?
    // XBAP-приложения – это, по существу, ClickOnce-приложения, способные работать только в онлайновом режиме, которые WPF обрабатывает особым образом для лучшей интеграции с браузером.
    // Предупреждение
    // Остерегайтесь кэширования ClickOnce!
    // Поэтому, изменив код приложения, перекомпилировав его и снова запустив, вы не увидите результата изменения, если одновременно не зададите другой номер версии! По умолчанию Visual Studio увеличивает номер версии при каждой перекомпиляции (из-за строки AssemblyVersion("1.0.*") в исходном файле AssemblyInfo), так что вы не столкнетесь с этой проблемой, если явно не присвоите приложению фиксированный номер версии.
    
    // Ограниченный набор возможностей
    // СОВЕТ
    // Если требуется использовать общий код в стандартном приложении с полным доверием и в XBAP-приложении с частичным доверием, то рекомендуется на этапе выполнения определять, в какой среде приложение работает, и соответственно модифицировать поведение программы. Сделать это можно с помощью статического булевского свойства BrowserInteropHelper.IsBrowserHosted из пространства имен System.Windows.Interop.
    // СОВЕТ
    // Еще одно различие между XBAP и стандартным приложением Windows заключается в способе передачи параметров (да и вообще любых внешних данных). Проще всего передать параметры в URL-адресе HTML-страницы, содержащей XBAP-приложение, а для получения полного URL (вместе с параметрами) вызвать в самом приложении метод BrowserInteropHelper.Source. Другой подход – сохранить информацию в cookie браузера, а для получения этих данных вызвать метод Application.GetCookie.
    // Как мне запустить свои собственные компоненты в зоне Интернета?
    // Используйте механизм, общий для всех компонентов .NET: если пометить сборку атрибутом AllowPartiallyTrustedCallers и установить ее в глобальный кэш сборок (а сделать это можно только, если пользователь доверяет вашему коду и готов выполнить его), то любое XBAP-приложение сможет обращаться к находящимся в этой сборке открытым API.
    // FAQ
    // Как создать XBAP-приложение с полным доверием?
    // 1. В манифесте ClickOnce-приложения (app.manifest) добавьте строку Unrestricted=" true" в XML-элемент PermissionSet
    // 2. В файле проекта (с расширением .csproj или .vbproj) измените строку <TargetZone>Internet</TargetZone>

    // Интегрированная навигация
    // СОВЕТ
    // Интеграция с журналом браузера в Internet Explorer 7 (и более поздних версиях) применима только к странице Page верхнего уровня. Если XBAP-приложение работает в HTML-фрейме IFRAME, то панель навигации будет видна, если только не сброшено в false свойство ShowsNavigationUI WPF-элемента Page.

    // Развертывание
    // Самое поразительное в XBAP-приложении – тот факт, что пользователь может установить и запустить его, просто перейдя по его URL-адресу, даже дополнений никаких не требуется
    // При запуске XBAP не выдаются предупреждения, касающиеся безопасности. Разве это не гигантская брешь в защите?
    // СОВЕТ
    // Наряду с Silverlight, технология XBAP – ключ к использованию WPF-содержимого в разных окружениях. Например, Windows Media Center и гаджеты рабочего стола Windows позволяют разработчику подключать HTML. Стоит разместить XBAP-приложение в такой HTML-странице, как вы получаете приложение для WPF Media Center или WPF-гаджет рабочего стола! 

    // Загрузка файлов по требованию
    // Технология ClickOnce поддерживает загрузку файлов по требованию приложения, так что можно спроектировать небольшое приложение, которое быстро загружается само, а затем по мере необходимости подгружает дополнительное содержимое, руководствуясь собственной логикой. Эта возможность – настоящее спасение для больших XBAP-приложений, которые в противном случае загружались бы слишком долго, но она применима и к приложениям других типов. 
    
    // Автономные XAML-страницы
    // СОВЕТ
    // Если вы хотите, чтобы сайт мог воспользоваться всем богатством автономного XAML, но при этом был способен показывать обычную HTML-страницу пользователям, не имеющим возможности просматривать XAML, то можете поддерживать две версии контента и динамически выбирать подходящую. Для этого достаточно проверить, есть ли в строке агента пользователя подстрока вида ".NET CLR 3.0". Впрочем, я еще не встречал сайта, который применял бы такую уловку. Адаптивное добавление Silverlight решает эту задачу гораздо лучше.

    // СОВЕТ
    // Чтобы одновременно использовать контент в виде HTML и автономного XAML, достаточно поместить один или несколько XAML-файлов во фреймы IFRAME на HTML-странице.


    // !!!
    // - Application
    // - Splash Screen
    // - Dialog Window
    // - Page
    // - NavigationWindow
    // - Frame
    // - Переходы между страницами
    // - Practice everything, this is basic chapter
    // Передача данных между страницами
}
