using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using System.Windows.Controls.Primitives;

namespace WPF_Unleashed._2_WPFApplication_Creation._6_InputEvents
{
    /// <summary>
    /// Interaction logic for InputEvents.xaml
    /// </summary>
    public partial class InputEvents : Window
    {
        public InputEvents()
        {
            InitializeComponent();
        }

        //public class MyButton : ButtonBase
        //{
        //    // Маршрутизируемое событие
        //    public static readonly RoutedEvent ClickEvent;

        //    static MyButton()
        //    {
        //        // Зарегистрировать событие 
        //        MyButton.ClickEvent = EventManager.RegisterRoutedEvent("Click", RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(MyButton));
        //    }

        //    // Обертывающее событие .NET (необязательное)
        //    public event RoutedEventHandler Click
        //    {
        //        add { AddHandler(MyButton.ClickEvent, value); }
        //        remove { RemoveHandler(MyButton.ClickEvent, value); }
        //    }

        //    protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e)
        //    {
        //        // Сгенерировать событие
        //        RaiseEvent(new RoutedEventArgs(MyButton.ClickEvent, this));
        //    }
        //}

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            RoutedEvent window = new RoutedEvent();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            AttachedEvent window = new AttachedEvent();
            window.Show();
        }

        // проверяется, что нажаты клавиши Alt и A, но при этом не исключается нажатие комбинаций Alt+Shift+A, Alt+Ctrl+A и т. д.
        protected override void OnKeyDown(KeyEventArgs e)
        {
            if ((e.KeyboardDevice.Modifiers & ModifierKeys.Alt) ==
            ModifierKeys.Alt && (e.Key == Key.A || e.SystemKey == Key.A))
            {
                // Нажато сочетание Alt+A, возможно, с Ctrl, Shift или Windows
            }
            base.OnKeyDown(e);
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            TouchEvents window = new TouchEvents();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            ManipulationEvents window = new ManipulationEvents();
            window.Show();
        }

        private void Button_Click_4(object sender, RoutedEventArgs e)
        {
            Spin window = new Spin();
            window.Show();
        }

        private void Button_Click_5(object sender, RoutedEventArgs e)
        {
            Command window = new Command();
            window.Show();
        }

        private void Button_Click_6(object sender, RoutedEventArgs e)
        {
            IntegralCommand window = new IntegralCommand();
            window.Show();
        }

        // проверяется, что нажата в точности комбинация Alt+A без каких-либо дополнительных модификаторов:
        //protected override void OnKeyDown(KeyEventArgs e)
        //{
        //    if (e.KeyboardDevice.Modifiers == ModifierKeys.Alt
        //    && (e.Key == Key.A || e.SystemKey == Key.A))
        //    {
        //        // Нажато сочетание Alt+A и только Alt+A
        //    }
        //    base.OnKeyDown(e);
        //}

        // проверяется нажатие комбинации [левая]Alt+A:
        //protected override void OnKeyDown(KeyEventArgs e)
        //{
        //    if (e.KeyboardDevice.Modifiers == ModifierKeys.Alt
        //    && (e.Key == Key.A || e.SystemKey == Key.A)
        //    && e.KeyboardDevice.IsKeyDown(Key.LeftAlt))
        //    {
        //        // Нажато LeftAlt+A
        //    }
        //    base.OnKeyDown(e);
        //}


        // Маршрутизируемые события
        // с помощью свойств зависимости WPF реализует дополнительную инфраструктуру поверх хорошо известной идеи свойств .NET.
        // WPF еще и дополняет понятие события. Маршрутизируемые события предназначены для работы с деревьями элементов.
        // Сгенерированное маршрутизируемое событие может распространяться вверх или вниз по визуальному и логическому дереву, достигая каждого элемента простым и естественным образом без написания дополнительного кода.
        // Таким образом, внутрь любого элемента, к примеру Button, можно поместить сколь угодно сложное содержимое, но щелчок левой кнопкой мыши при наведении указателя на любой внутренний элемент все равно приведет к возникновению события Click для родительской кнопки.

        // Реализация маршрутизируемого события
        // Напомним, что свойства зависимости представлены открытыми статическими полями типа DependencyProperty с принимаемым по соглашению суффиксом Property. Точно так же маршрутизируемые события представлены открытыми статическими полями типа RoutedEvent с принимаемым по соглашению суффиксом Event.
        // Так же, как свойство зависимости, маршрутизируемое событие регистрируется в статическом конструкторе, и дополнительно определяется обычное событие .NET – обертывающее событие, – чтобы было проще писать процедурный код и добавлять обработчик события в XAML-коде с помощью стандартного синтаксиса атрибутов событий. Как и обертывающее свойство, обертывающее событие не должно делать в аксессорах ничего, кроме вызова методов AddHandler и RemoveHandler. 
        // Методы AddHandler и RemoveHandler наследуются не от класса DependencyObject, а от UIElement. Они соответственно присоединяют и отсоединяют делегат от маршрутизируемого события.

        // Стратегии маршрутизации и обработчики событий
        // В момент регистрации маршрутизируемого события задается одна из трех стратегий маршрутизации – вариантов распространения события по дереву элементов. Стратегии описываются перечислением RoutingStrategy:
        // - Tunneling – событие сначала возникает в корне дерева, а потом опускается вниз по дереву, заново возникая в каждом элементе на пути к источнику, включая его самого (если туннелирование не будет прервано по дороге в результате пометки события как обработанного).
        // - Bubbling – событие сначала возникает в элементе-источнике, а затем поднимается вверх по дереву, заново возникая в каждом элементе на пути к корню, включая сам корень (если всплытие не будет прервано по дороге в результате пометки событиякак обработанного). 
        // - Direct – событие возникает только в элементе-источнике. Точно так же ведут себя обычные события .NET; различие лишь в том, что к маршрутизируемому событию применяются и другие механизмы, в частности триггеры событий.
        // Сигнатуры обработчиков маршрутизируемых событий устроены так же, как сигнатуры всех обработчиков событий в .NET: первый параметр – объект типа System.Object, который обычно называют sender, второй (обычно называемый e) – экземпляр класса, производного от System.EventArgs. Передаваемый обработчику параметр sender – это всегда элемент, к которому присоединен данный обработчик. Параметр e является объектом класса RoutedEventArgs (или производного от него) – подкласса EventArgs, обладающего следующими полезными свойствами:
        // - Source – элемент логического дерева, первоначально сгенерировавший событие.
        // - OriginalSource – элемент визуального дерева, первоначально сгенерировавший событие (например, в случае стандартной кнопки Button это будет дочерний элемент TextBlock или ButtonChrome).
        // - Handled – булевский флаг, которому можно присвоить значение true и тем самым пометить, что событие обработано. Именно таким способом прерывается туннелирование и всплытие.
        // - RoutedEvent – сам объект маршрутизированного события (например, Button.ClickEvent), который может быть полезен для различения событий в случае, когда один и тот же обработчик используется для обработки разных событий.

        // Маршрутизируемые события в действии
        // В классе UIElement определено много маршрутизируемых событий для клавиатуры, мыши, мультисенсорных устройств и стилуса. Большая часть из них всплывающие, но для многих есть и парные туннелируемые. Туннелируемые события легко распознать, потому что по принятому соглашению их имена начинаются со слова Preview.
        // Такое событие – также по соглашению – генерируется непосредственно перед парным ему всплывающим. Например, туннелируемое событие PreviewMouseMove генерируется перед всплывающим событием MouseMove. 
        // Идея, стоящая за такими парами событий, заключается в том, чтобы дать элементам возможность отменить или иным способом модифицировать событие, которое еще только произойдет. По соглашению встроенные в WPF элементы предпринимают действия только в ответ на всплывающее событие (в случае если определена пара событий – всплывающее и туннелируемое), гарантируя тем самым, что туннелируемые события отвечают своему названию (preview означает «предварительный просмотр »).
        // Представим, к примеру, что требуется реализовать элемент TextBox, который позволяет вводить только строки, отвечающие некоторому образцу или регулярному выражению (например, номера телефонов и почтовые индексы). Если обрабатывать в нем событие KeyDown, то лучшее, что можно сделать, – удалить текст, который уже отображен в поле TextBox. Если же обрабатывать событие PreviewKeyDown, то можно пометить его как «обработанное» и тем самым не только прервать туннелирование, но и воспрепятствовать генерации всплывающего события KeyDown. В таком случае TextBox вообще не получит уведомления о событии KeyDown и введенный символ не появится в поле.
        // Если запустить эту программу и последовательно щелкнуть правой кнопкой мыши по всем элементам, то обнаружатся два любопытных эффекта:
        // - Window не получает событие MouseRightButtonDown, если щелкнуть по любому элементу списка ListBoxItem. Дело в том, что ListBoxItem сам обрабатывает это событие, равно как и MouseLeftButtonDown (и прерывает всплытие),– это нужно ему для реализации выбора элементов.
        // - Window получает событие MouseRightButtonDown при щелчке по кнопке Button, но никаких изменений во внешнем виде рамки не происходит. Это объясняется структурой стандартного визуального дерева Button. В отличие от элементов Window, Label, ListBox, ListBoxItem и StatusBar, в визуальном дереве Button нет элемента Border.
        // Прерывание маршрутизации события – иллюзия!
        // Хотя присваивание значения true свойству Handled объекта RoutedEventArgs в обработчике маршрутизируемого события должно приводить к прерыванию туннелирования или всплытия, обработчики, присоединенные к элементам, находящимся выше или ниже в дереве, все равно могут запросить получение событий! Сделать это можно только в процедурном коде с помощью перегруженного варианта метода AddHandler, который принимает дополнительный булевский параметр handledEventsToo.
        // public AboutDialog()
        // {
        // InitializeComponent();
        // this.AddHandler(Window.MouseRightButtonDownEvent,
        // new MouseButtonEventHandler(AboutDialog_MouseRightButtonDown), true);
        // } 
        // Однако лучше не прибегать к этому приему, потому что для пометки события как обработанного, очевидно, была какая-то причина. Более правильно было бы присоединить обработчик Preview-версии того же события. 
        // Но в целом мы хотели подчеркнуть, что прерывание туннелирования и всплытия – на самом деле иллюзия. Распространение события все равно продолжается, но по умолчанию обработчики видят только те события, которые не помечены как уже обработанные. 
        
        // Присоединенные события
        // WPF поддерживает туннелирование и всплытие маршрутизируемых событий даже для элементов, в которых данное событие не определено! Возможно это благодаря понятию присоединенного события.
        // Поскольку в классе Window не определены события SelectionChanged и Click, то имена атрибутов событий необходимо снабдить префиксами, содержащими имя класса, в котором соответствующее событие определено.
        // Любое маршрутизируемое событие можно использовать как присоединенное. Синтаксис присоединенных событий допустим потому, что компилятор XAML видит событие .NET SelectionChanged, определенное в классе ListBox, и событие .NET Click, определенное в классе Button. Однако во время выполнения вызывается метод AddHandler, который присоединяет оба события к элементу Window. Поэтому эти два атрибута события эквивалентны следующему коду в конструкторе Window:
        // this.AddHandler(ListBox.SelectionChangedEvent,
        // new SelectionChangedEventHandler(ListBox_SelectionChanged));
        // this.AddHandler(Button.ClickEvent, new RoutedEventHandler(Button_Click));
        // Консолидация обработчиков маршрутизируемых событий
        // Поскольку вместе с маршрутизируемым событием передается достаточно много информации, при желании есть возможность обработать все туннелируемые и всплывающие события в одном «мегаобработчике» на верхнем уровне. Он мог бы исследовать объект RoutedEvent, определить, какое событие сгенерировано, привести параметр RoutedEventArgs к типу соответствующего подкласса (например, KeyEventArgs, MouseButtonEventArgs и т. д.), а потом предпринять соответствующие действия.
        // void GenericHandler(object sender, RoutedEventArgs e)
        // {
        //    if (e.RoutedEvent == Button.ClickEvent)
        //    {
        //       MessageBox.Show("You just clicked " + e.Source);
        //    }
        //    else if (e.RoutedEvent == ListBox.SelectionChangedEvent)
        //    {
        //        SelectionChangedEventArgs sce = (SelectionChangedEventArgs)e;
        //       if (sce.AddedItems.Count > 0)
        //            MessageBox.Show("You just selected " + sce.AddedItems[0]);
        //    }
        // } 
        // Это возможно благодаря встроенному в каркас .NET Framework механизму контравариантности делегатов, позволяющему использовать делегат с методом, в сигнатуре которого указан базовый класс ожидаемого параметра (например, RoutedEventArgs вместо SelectionChangedEventArgs). Метод GenericHandler просто приводит параметр RoutedEventArgs к нужному типу, когда ему необходимо получить дополнительную информацию, специфичную для события SelectionChanged.

        // События клавиатуры
        // Основные события клавиатуры, поддерживаемые всеми подклассами UIElement, – это всплывающие события KeyDown и KeyUp и парные им туннелируемые события PreviewKeyDown и PreviewKeyUp. Обработчикам событий клавиатуры передается аргумент типа KeyEventArgs, содержащий целый ряд свойств, в том числе:
        // - Key, ImeProcessedKey, DeadCharProcessedKey, SystemKey – четыре свойства, принадлежащие типу перечисления Key, в котором определены все возможные клавиши. Свойство Key определяет, какая клавиша вызвала генерацию события. Если клавиша обрабатывается или будет обрабатываться редактором метода ввода (Input Method Editor – IME), то можно проверить значение свойства ImeProcessedKey. Если клавиша является слепой в последовательности, то свойство Key будет равно DeadCharProcessed, тогда как реальную клавишу можно получить из свойства DeadCharProcessedKey. Если нажата системная клавиша, например Alt, то Key будет равно System, а сама клавиша берется из свойства SystemKey.
        // - IsUp, IsDown, IsToggled – булевские свойства, сообщающие дополнительную информацию о событии клавиатуры, хотя в некоторых случаях она избыточна. (Раз уж вы обрабатываете событие KeyDown, то точно знаете, что клавиша нажата!) Свойство IsToggled относится к клавишам с фиксируемым переключением состояния, таким как Caps Lock и Scroll Lock. 
        // Совет
        // Для получения информации о состоянии клавиатуры в любой момент времени, а не только внутри обработчика события от нее можно воспользоваться статическим классом System.Windows.Input и его свойством PrimaryDevice (типа KeyboardDevice). 
        // - KeyStates – свойство типа KeyStates, битового перечисления, состоящего из произвольной комбинации битов None, Down и Toggled. Эти значения отображаются на свойства IsUp, IsDown и IsToggled соответственно. Поскольку Toggled иногда комбинируется с Down, остерегайтесь определять значение KeyStates с помощью простой проверки на равенство. Лучше всего пользоваться свойствами IsXX
        // - IsRepeat – булевское свойство, равное true, когда нажатие клавиши повторяется. Например, так происходит, когда вы удерживаете нажатой пробельную клавишу и получаете лавину событий KeyDown. Свойство IsRepeat будет содержать true для всех событий KeyDown, кроме самого первого. 
        // - KeyboardDevice – свойство типа KeyboardDevice, которое позволяет работать с клавиатурой на более низком уровне, например узнать, какие клавиши сейчас нажаты, или потребовать передать фокус конкретному элементу.
        // Одна из причин для обращения к классу KeyboardDevice – получение его свойства Modifiers типа ModifierKeys (еще одно перечисление). Оно показывает, какие клавиши нажаты одновременно с основной. Возможны следующие значения: None, Alt, Control, Shift и Windows.
        // Как узнать, какая из клавиш Alt, Ctrl и Shift нажата: левая или правая?
        // можно воспользоваться методом IsKeyDown класса KeyboardDevice (или IsKeyUp либо IsKeyToggled), чтобы узнать о состоянии конкретной клавиши, например левой или правой Alt.
        // Элемент UIElement получает события клавиатуры, только если владеет фокусом. Указать, может ли некоторый элемент получать фокус, позволяет булевское свойство Focusable, по умолчанию равное true. При изменении значения этого свойства возникает событие FocusableChanged.
        // В классе UIElement определено еще много свойств и событий, относящихся к фокусу клавиатуры. Отметим из них свойство IsKeyboardFocused, которое сообщает, принадлежит ли фокус текущему элементу, и свойство IsKeyboardFocusWithin, сообщающее то же самое, но в отношении не только текущего элемента, но и его потомков. (Эти свойства доступны только для чтения; чтобы передать фокус клавиатуры, пользуйтесь методами Focus или MoveFocus.) Об изменении этих свойств уведомляют события IsKeyboardFocusedChanged, IsKeyboardFocusWithinChanged, GotKeyboardFocus, LostKeyboardFocus, PreviewGotKeyboardFocus и PreviewLostKeyboardFocus. 

        // События мыши
        // Все подклассы UIElement поддерживают следующие основные события мыши:
        // - MouseEnter и MouseLeave
        // - MouseMove и PreviewMouseMove
        // - MouseLeftButtonDown, MouseRightButtonDown, MouseLeftButtonUp, MouseRightButtonUp и более общие MouseDown и MouseUp, а также Preview-версии всех шести событий
        // - MouseWheel и PreviewMouseWheel
        // События MouseEnter и MouseLeave можно использовать для создания эффекта ролловера, хотя более предпочтительно использовать триггер со свойством IsMouseOver.
        // В подклассах UIElement имеется также свойство IsMouseDirectlyOver (и соответствующее ему событие IsMouseDirectlyOverChanged), которое позволяет исключить дочерние элементы. Оно используется в тех редких случаях, когда вы точно знаете, с каким визуальным деревом работаете.
        // А где же событие для обработки нажатия средней кнопки мыши?
        // Эту информацию можно получить с помощью обобщенных событий MouseDown и MouseUp (или их Preview-версий). Объект EventArgs, передаваемый их обработчиком, содержит свойства, показывающие, какая их следующих кнопок была нажата или отпущена: LeftButton, RightButton, MiddleButton, XButton1 или XButton2. 
        // Совет
        // Если вы не хотите, чтобы элемент генерировал события мыши (или блокировал события мыши, генерируемые лежащими под ним элементами), то можете присвоить значение false его свойству IsHitTestVisible.
        // Предупреждение
        // Прозрачные области генерируют события мыши, но null-области – нет!
        // Хотя и можно рассчитывать на то, что установка для свойства IsHitTestVisible значения false подавит события мыши, но условия, при которых эти события вообще генерируются, довольно запутанны. Если свойство Visibility элемента равно Collapsed, то событиямыши  подавляются, но установка для свойства Opacity значения 0 не влияет на генерацию событий. Еще одна тонкость касается областей, для которых любое из свойств Background, Fill или Stroke равно null.
        // В таких областях события мыши не генерируются. Однако, если явно присвоить любому из свойств Background, Fill или Stroke значение Transparent (или любой другой цвет), то в такой области события мыши будут генерироваться. (null- кисть внешне неотличима от прозрачной (Transparent) кисти, но с точки зрения проверки положения указателя мыши ведет себя иначе.)

        // Класс MouseEventArgs
        // Обработчикам всех вышеупомянутых событий мыши (кроме IsMouseDirectlyOverChanged) передается объект класса MouseEventArgs. В нем есть пять свойств типа MouseButtonState, содержащих информацию обо всех потенциально возможных нажатиях кнопок мыши: LeftButton, RightButton, MiddleButton, XButton1 и XButton2. MouseButtonState – это перечисление с двумя значениями: Pressed и Released. В классе MouseEventArgs определен также метод GetPosition, который возвращает структуру Point со свойствами X и Y, отражающими точные координаты указателя мыши.
        // GetPosition – это метод, а не просто свойство, поскольку он позволяет получить позицию указателя мыши несколькими способами: относительно левого верхнего угла экрана или левого верхнего угла произвольного нарисованного элемента UIElement. Чтобы узнать координаты относительно экрана, передайте в качестве единственного параметра null. А для получения координат относительно элемента передайте в качестве параметра интересующий вас элемент.
        // Обработчикам событий MouseWheel и PreviewMouseWheel передается объект класса MouseWheelEventArgs, производного от MouseEventArgs. Этот класс добавляет целочисленное свойство Delta, показывающее, на какой угол колесико мыши повернулось с момента последнего события. Обработчикам всех 12 событий семейства MouseUp/MouseDown передается объект класса MouseButtonEventArgs, еще одного подкласса MouseEventArgs. Этот класс добавляет свойство ChangedButton, которое сообщает, какая кнопка изменила состояние (значение принадлежит перечислению MouseButton); свойство ButtonState, которое информирует, нажата кнопка или отпущена; и свойство ClickCount.
        // Свойство ClickCount показывает, сколько раз подряд была нажата кнопка мыши, причем ведется подсчет нажатий, промежуток времени между которыми не превышает системного параметра, описывающего скорость выполнения двойного щелчка (задается на Панели управления). Класс Button генерирует событие Click, обрабатывая низкоуровневое событие MouseLeftButtonDown, а его базовый класс Control генерирует событие MouseDoubleClick, сравнивая значение ClickCount с 2 в обработчике MouseLeftButtonDown, и событие PreviewMouseDoubleClick, делая то же самое в обработчике PreviewMouseLeftButtonDown. Имея такую поддержку, вы легко сможете реагировать и на другие действия пользователя, например на тройное нажатие, двойное нажатие средней кнопки и т. д.
        // Предупреждение
        // Панель Canvas генерирует свои собственные события мыши только в области, определяемой ее свойствами Width и Height!
        // по умолчанию события мыши уровня Canvas генерируются только ее дочерними элементами.

        // Перетаскивание
        // Во всех подклассах UIElement определены события для работы с перетаскиванием:
        // - DragEnter, DragOver, DragLeave, а также PreviewDragEnter, PreviewDragOver и PreviewDragLeave
        // - Drop и PreviewDrop
        // - QueryContinueDrag и PreviewQueryContinueDrag
        // Это перетаскивание элемента в буфер обмена и бросание содержимого буфера на элемент в стиле Win32, а не перетаскивание и бросание самих элементов. Элемент может принять участие в перетаскивании, установив значение true для свойства AllowDrop.
        // Обработчикам событий из первых двух наборов передается объект типа DragEvent­Args, содержащий следующие свойства и методы:
        // - GetPosition – такой же метод, как в классе MouseEventArgs
        // - Data – свойство типа IDataObject, представляющее перетаскиваемый или бросаемый объект буфера обмена Win32
        // - Effects и AllowedEffects – битовое перечисление DragDropEffects, допускающее произвольную комбинацию флагов Copy, Move, Link, Scroll, All и None
        // - KeyStates – еще одно битовое перечисление (DragDropKeyStates), показывающее, какие кнопки мыши или клавиши-модификаторы были нажаты во время перетаскивания или бросания: LeftMouseButton, RightMouseButton, Mid­dle­MouseButton, ShiftKey, ControlKey, AltKey или None
        // События QueryContinueDrag и PreviewQueryContinueDrag генерируются, если во время перетаскивания изменяется состояние клавиатуры или какой-нибудь кнопки мыши. Это позволяет обработчику без труда отменить всю операцию. Обработчикам этих событий передается объект класса QueryConti­nue­Drag­EventArgs, имеющий следующие свойства:
        // - KeyStates – аналогично одноименному свойству класса DragEventArgs
        // - EscapePressed – отдельное булевское свойство, показывающее, была ли нажата клавиша Esc
        // - Action – свойство, которое обработчик может установить, чтобы определить судьбу операции перетаскивания; принадлежит перечислению DragAction и принимает значение Continue, Drop или Cancel
        // Совет
        // Для получения информации о состоянии мыши почти в любой момент времени, а не только внутри обработчиков ее событий можно воспользоваться статическим классом System.Win­dows.Input.Mouse. Чего нельзя сделать – так это получить достоверную позицию указателя мыши от статического метода Mouse.GetPosition во время перетаскивания. Вместо этого приходится либо вызывать метод GetPosi­tion объекта DragEventArgs, переданного обработчику события, либо, минуя обработчики событий, с помощью технологии PInvoke вызвать функцию Win32 API GetCursorPos, которая даст правильные координаты.

        // Захват мыши
        // Предположим, что нужно поддержать перетаскивание и бросание самих элементов UIElement, а не объектов буфера обмена. Легко представить себе, как это можно реализовать с помощью событий MouseLeftButtonDown, MouseMove и Mou­seLeft­ButtonUp. В начале операции перетаскивания можно установить некую булевскую переменную в обработчике события MouseLeftButtonDown элемента, потом в обработчике MouseMove перемещать элемент, так чтобы он оставался под указателем мыши, если эта переменная равна true, а в обработчике Mouse­LeftButtonUp сбросить переменную, обозначив конец перетаскивания. Однако выясняется, что эта схема не так уж хороша, потому что пользователь может двигать мышь слишком быстро или ее указатель может оказаться под другим элементом, в результате чего указатель потеряет связь с элементом, который вы пытаетесь перетащить.
        // К счастью, WPF позволяет любому элементу UIElement в любой момент захватить или освободить мышь. Когда элемент захватил мышь, он получает все события мыши, даже если указатель оказывается вне занимаемой им области. После освобождения мыши поведение событий возвращается в нормальное русло. Для захвата и освобождения мыши предназначены два метода класса UIElement: CaptureMouse и ReleaseMouseCapture. (И, разумеется, есть ряд свойств и событий, сообщающих о состоянии захвата мыши, точнее, свойства IsMou­se­Captured и IsMouseCaptureWithin и события GotMouseCapture, Lost­Mouse­Captu­re, IsMouseCaptureChanged и IsMouseCaptureWithinChanged.) 
        // Поэтому для реализации перетаскивания необходимо захватить мышь в обработчике MouseLeftButtonDown и освободить ее в обработчике MouseLeftButtonUp. Единственная сложность – придумать оптимальный способ фактического перемещения элемента в обработчике MouseMove. Выбор зависит от компоновки приложения, но, скорее всего, вы будете применять к перетаскиваемому элементу преобразование в режиме RenderTransform или LayoutTransform.

        // События стилуса
        // В WPF имеется специальная поддержка для цифрового пера, или стилуса, применяемого в таких устройствах, как Tablet PC.
        // Но если вы хотите, чтобы пользователю было удобно работать именно со стилусом, то можете организовать взаимодействие с экземпляром класса System.Win­dows.Input.StylusDevice. Получить его можно тремя способами.
        // - Воспользоваться свойством StylusDevice объекта MouseEventArgs для доступа к объекту в обработчиках событий мыши. (Если стилуса нет, то это свойство равно null.)
        // - Воспользоваться статическим классом System.Win­dows.Input.Stylus и его свойством CurrentStylusDevice – так можно получить доступ к стилусу в любой момент. (Если стилуса нет, то это свойство тоже равно null.)
        // - Обрабатывать события, специфичные для стилуса.
        // Я и так могу получить данные стилуса, если буду работать с ним, как с мышью. Так зачем еще какая-то дополнительная информация?
        // Перьевой и сенсорный дигитайзеры поддерживают два аспекта, отсутствующие у обычной мыши:
        // чувствительность к силе нажатия и более высокую разрешающую способность.

        // Класс StylusDevice
        // Класс StylusDevice содержит ряд свойств, в том числе:
        // - Inverted – булевское значение, показывающее, что стилус используется как ластик (то есть экрана касается его обратный конец).
        // - InAir – булевское значение, показывающее, касается ли стилус экрана. Это важно, потому что некоторые устройства регистрируют его перемещение даже без касания при условии, что стилус находится достаточно близко к экрану.
        // - StylusButtons – коллекция объектов типа StylusButton. В отличие от мыши, у стилуса нет фиксированного списка кнопок. В каждом объекте StylusButton имеется строковое свойство Name и идентификатор Guid, а также свойство StylusButtonState, принимающее одно из значений: Up или Down.
        // - TabletDevice – свойство типа System.Windows.Input.TabletDevice, предоставляющее детальную информацию о текущем оборудовании и возможностях стилуса (в частности, чувствительность к силе нажатия или поддержка перемещений без касания). Свойство Type равно Stylus для перьевого и Touch – для сенсорного дигитайзера. 
        // В классе StylusDevice имеется метод GetPosition, работающий так же, как его аналог для мыши. Но дополнительно есть более подробный метод GetStylusPoints, который возвращает коллекцию объектов StylusPoint. В каждом объекте StylusPoint имеются следующие свойства:
        // - X – абсцисса точки касания стилуса относительно элемента, на котором он находится.
        // - Y – ордината точки касания стилуса относительно элемента, на котором он находится.
        // - PressureFactor – значение от 0 до 1, показывающее давление, приложенное к стилусу в момент регистрации точки. Чем больше значение, тем сильнее нажатие (если оборудование вообще поддерживает чувствительность к силе нажатия). Если чувствительность к силе нажатия не поддерживается, то PressureFactor будет равно 0.5.

        // События
        // К стилусу относятся следующие события:
        // - StylusEnter и StylusLeave
        // - StylusMove и PreviewStylusMove
        // - StylusInAirMove и PreviewStylusInAirMove
        // - StylusDown, StylusUp, PreviewStylusDown и PreviewStylusUp
        // - StylusButtonDown, StylusButtonUp, PreviewStylusButtonDown и PreviewStylusButtonUp
        // - StylusSystemGesture и PreviewStylusSystemGesture
        // - StylusInRange, StylusOutOfRange, PreviewStylusInRange и PreviewStylusOutOfRange
        // - GotStylusCapture и LostStylusCapture
        
        // Обработчикам этих событий передается объект класса StylusEventArgs, свойство StylusDevice которого дает доступ к объекту StylusDevice. Для удобства в нем определены также члены InAir, Inverted, GetPosition и GetStylusPoints, обертывающие одноименные члены класса StylusDevice.
        // Некоторым обработчикам в качестве аргумента передается объект одного из подклассов StylusEventArgs:
        // - StylusDownEventArgs – передается обработчикам событий StylusDown и PreviewStylusDown; добавляет целочисленное свойство TapCount, аналогичное свойству ClickCount в событиях мыши.
        // - StylusButtonEventArgs – передается обработчикам событий StylusButtonDown, StylusButtonUp и их Preview-версий; добавляет свойство StylusButton, описывающее нажатую кнопку.
        // - StylusSystemGestureEventArgs – передается обработчикам событий StylusSystemGesture и PreviewStylusSystemGesture; добавляет свойство SystemGesture, принадлежащее типу перечисления SystemGesture и принимающее следующие значения: Tap, RightTap, TwoFingerTap, Drag, RightDrag, Flick, HoldEnter, HoldLeave, HoverEnter, HoverLeave, None. 
        // Совет
        // В WPF определен объект Stroke (росчерк), с помощью которого можно визуально представить информацию, хранящуюся в коллекции StylusPoints, и элемент InkPresenter, содержащий коллекцию объектов Stroke. Во многих сценариях рисования и рукописного ввода можно также использовать элемент InkCanvas, который основан на использовании InkPresenter. В InkCanvas встроена возможность работы со стилусом, если таковой имеется, а также средства для сбора и отображения росчерков. При использовании этого элемента вам вообще не придется обрабатывать события стилуса самостоятельно!

        // Мультисенсорные события
        // Совет
        // Если вы хотите эмулировать мультисенсорный (или даже простой сенсорный) ввод на «обычном » компьютере, то можете воспользоваться комплектом MultiPoint Mouse SDK

        // Простые события касания
        // Простые события касания во многом похожи на события мыши:
        // - TouchEnter и TouchLeave
        // - TouchMove и PreviewTouchMove
        // - TouchDown, TouchUp, PreviewTouchDown и PreviewTouchUp
        // - GotTouchCapture и LostTouchCapture
        // Обработчикам событий касания передается объект класса TouchEventArgs, содержащий следующие члены:
        // - GetTouchPoint – метод, возвращающий объект TouchPoint. Этот объект представляет точку касания в системе координат, связанной с элементом, которому она принадлежит. Аналог метода GetPosition для событий мыши.
        // - GetIntermediateTouchPoints – метод, возвращающий коллекцию объектов TouchPoint в координатах элемента, собранных за время, прошедшее между текущим и предыдущим событиями касания. Аналог метода GetStylusPoints для событий стилуса.
        // - TouchDevice – свойство, возвращающее объект TouchDevice.
        // Совет
        // В версии Silverlight 4 событий касания нет. Если вы хотите написать код, который поддерживал бы мультисенсорный ввод и работал как в WPF, так и в Silverlight, то можете воспользоваться низкоуровневым событием FrameReported, которое присутствует в обеих системах. Событие FrameReported определено в статическом классе System.Windows.Input.Touch и сообщает о точках касания TouchPoint для всего приложения в целом. Это не маршрутизируемое событие; выяснять, где произошло касание, придется самостоятельно.

        // События манипулирования, описывающие сдвиг, поворот и масштабирование
        // Мультисенсорный ввод обычно применяется пользователями для сдвига, поворота и масштабирования элементов. Тут все просто, так как эти действия точно отображаются на преобразования TranslateTransform, RotateTransform и ScaleTransform соответственно. А вот определить, когда эти преобразования следует применять и с какими параметрами, куда сложнее.
        // На наше счастье, WPF предоставляет высокоуровневые события манипулирования, позволяющие без труда поддержать сдвиг, поворот и масштабирование. Вот перечень основных событий такого рода:
        // - ManipulationStarting и ManipulationStarted
        // - ManipulationDelta
        // - ManipulationCompleted

        // Использование событий манипулирования
        // Информация передается в следующих свойствах класса ManipulationDelta:
        // - Translation – свойство типа Vector, содержащее значения X и Y
        // - Scale – еще одно свойство типа Vector
        // - Rotation – свойство типа double, определяющее угол поворота в градусах
        // - Expansion – свойство типа Vector, которое при наличии Scale можно считать избыточным; сообщает разницу в размерах, выраженную в абсолютных независимых от устройства пикселах, а не в терминах коэффициентов масштабирования
        // Манипуляции всегда производятся относительно контейнера манипулирования. По умолчанию это элемент, для которого свойство IsManipulationEnabled=True;

        // Добавление инерции
        // Чтобы включить инерцию, следует обработать событие ManipulationInertiaStarting – в дополнение к другим событиям манипулирования. Именно ManipulationInertiaStarting – а не ManipulationCompleted – первое событие манипулирования, которое генерируется после убирания всех пальцев с экрана. В обработчике ManipulationInertiaStarting вы можете решить, что именно поддерживать, для этого следует установить какие-то из свойств ManipulationInertiaStartingEventArgs. TranslationBehavior, ManipulationInertiaStartingEventArgs.RotationBehavior и ManipulationInertiaStartingEventArgs.ExpansionBehavior. В результате система продолжит генерировать события ManipulationDelta (в которых свойство ManipulationDeltaEventArgs. IsInertial будет равно true) до тех пор, пока «трение » не заставит объект остановиться, а в этот момент будет сгенерировано событие ManipulationCompleted. (Если в обработчике события ManipulationInertiaStarting ничего не делать, то событие  ManipulationCompleted генерируется сразу после него.)
        // Ниже приведен перечень свойств, которые можно установить для настройки инерции при сдвиге, повороте или масштабировании:
        // - TranslationBehavior – DesiredDisplacement, DesiredDeceleration, InitialVelocity
        // - RotationBehavior – DesiredRotation, DesiredDeceleration, InitialVelocity
        // - ExpansionBehavior – DesiredExpansion, DesiredDeceleration, InitialRadius, InitialVelocity
        // Необходимо следить, чтобы элемент не ушел полностью за пределы экрана, особенно если включена инерция. Можно воспользоваться событием ManipulationBoundaryFeedback, чтобы получать уведомления о том, что элемент достиг границы контейнера манипулирования, и воспрепятствовать его перемещению. 
        // Совет
        // WPF предлагает простой способ заставить окно колебаться, когда что-то проходит через его границу, – как в эффекте прокрутки за конец списка, который сделался популярным благодаря iPhone. Чтобы этого добиться, нужно в обработчике события ManipulationDelta вызвать метод ReportBoundaryFeedback полученного объекта ManipulationDeltaEventArgs. Тогда будет сгенерировано событие ManipulationBoundaryFeedback, которое будет обработано элементом Window, и результатом станет желаемый эффект.
        // В классе ManipulationDeltaEventArgs есть методы Complete и Cancel. В чем между ними разница?
        // Метод Complete останавливает манипуляцию (как прямую, так и инерционную). Метод Cancel тоже останавливает манипуляцию, но передает данные о касании событиям мыши, так что поведение может быть частично продолжено для элементов, умеющих работать с мышью, но не с сенсорными устройствами.
        // Совет
        // Можно воспользоваться встроенной в элемент ScrollViewer поддержкой сдвигов и присвоить свойству PanningMode одно из значений HorizontalOnly, VerticalOnly, HorizontalFirst, VerticalFirst или Both. В классе ScrollViewer имеются также свойства PanningDeceleration и PanningRatio. Последнее используется как коэффициент при вычислении расстояния для реализующего манипуляцию преобразования TranslateTransform. 
        // По умолчанию свойство PanningMode равно None, но некоторые элементы управления WPF задают для своего внутреннего ScrollViewer другое значение, более подходящее для стандартного стиля и позволяющее работать с мультисенсорными устройствами без явных действий со стороны программиста.
        // Совет
        // В доступном для скачивания наборе инструментов Surface Toolkit for Windows Touch есть немало превосходных элементов управления WPF для Microsoft Surface, которые оптимизированы для работы с мультисенсорными устройствами. В их число входят как варианты большинства стандартных элементов управления для сенсорного рабочего стола (например, SurfaceButton и SurfaceCheckBox), так и совершенно новые элементы (в частности, ScatterView и LibraryStack). 

        // Команды
        // Хотя эта глава посвящена в основном событиям, важно иметь представление о встроенной в WPF поддержке команд, более абстрактной и слабо связанной версии событий. 
        // Каноническими примерами служат команды Cut (Вырезать), Copy (Копировать) и Paste (Вставить). В приложениях эти действия часто представляются сразу несколькими способами: пункты MenuItem меню Menu, пункты MenuItem меню ContextMenu, кнопки Button на панели инструментов ToolBar, сочетания клавиш и т. д. 
        // К счастью, поддержка команд в WPF спроектирована так, чтобы максимально упростить работу в подобных ситуациях. Предлагаемый механизм уменьшает объем написанного вами кода (а иногда позволяет вообще не писать процедурный код) и дает вам возможность более гибко изменять пользовательский интерфейс, не нарушая стоящую за ним логику.
        // Мощь механизма команд основывается на трех основных особенностях:
        // - В WPF определено много встроенных команд.
        // - В команды встроена автоматическая поддержка жестов ввода (например, сочетаний клавиш).
        // - Встроенное поведение некоторых элементов управления WPF уже ориентировано на те или иные команды.

        // Встроенные команды
        // Командой называется любой объект, реализующий интерфейс ICommand (из пространства имен System.Windows.Input), в котором объявлены три простых члена:
        // - Execute – метод, который выполняет характерную для команды логику
        // - CanExecute – метод, который возвращает true, если команда активирована, и false, если она деактивирована
        // - CanExecuteChanged – событие, которое генерируется при изменении значения CanExecute
        // К счастью, в такие элементы управления, как Button, CheckBox и MenuItem, уже встроена логика, позволяющая им взаимодействовать с любой командой от вашего имени. В этих элементах имеется простое свойство Command (типа ICommand). Если оно установлено, то элемент автоматически вызывает метод команды Execute (если CanExecute возвращает true) всякий раз, как генерирует событие Click. Кроме того, свойство IsEnabled автоматически синхронизируется со значением, возвращаемым методом CanExecute, – для этого используется событие CanExecuteChanged. Поскольку вся эта функциональность становится доступна в результате присваивания простому свойству, то к ней можно обращаться из кода на XAML.
        // Но и это еще не все. В WPF уже определен целый ряд команд, поэтому вам не придется писать реализующие ICommand классы для таких команд, как Cut, Copy и Paste, и думать о том, где хранить соответствующие объекты. Встроенные в WPF команды доступны в виде статических свойств пяти разных классов: 
        // - ApplicationCommands – Close, Copy, Cut, Delete, Find, Help, New, Open, Paste, Print, PrintPreview, Properties, Redo, Replace, Save, SaveAs, SelectAll, Stop, Undo и др.
        // - ComponentCommands – MoveDown, MoveLeft, MoveRight, MoveUp, ScrollByLine, ScrollPageDown, ScrollPageLeft, ScrollPageRight, ScrollPageUp, SelectToEnd, SelectToHome, SelectToPageDown, SelectToPageUp и др.
        // - MediaCommands – ChannelDown, ChannelUp, DecreaseVolume, FastForward, IncreaseVolume, MuteVolume, NextTrack, Pause, Play, PreviousTrack, Record, Rewind, Select, Stop и др.
        // - NavigationCommands – BrowseBack, BrowseForward, BrowseHome, BrowseStop, Favorites, FirstPage, GoToPage, LastPage, NextPage, PreviousPage, Refresh, Search, Zoom и др.
        // - EditingCommands – AlignCenter, AlignJustify, AlignLeft, AlignRight, CorrectSpellingError, DecreaseFontSize, DecreaseIndentation, EnterLineBreak, EnterParagraphBreak, IgnoreSpellingError, IncreaseFontSize, IncreaseIndentation, MoveDownByLine, MoveDownByPage, MoveDownByParagraph, MoveLeftByCharacter, MoveLeftByWord, MoveRightByCharacter, MoveRightByWord и др. 
        // Каждое из этих свойств возвращает не какой-то уникальный тип, реализующий интерфейс ICommand, а объект одного и того же класса RoutedUICommand, который не только реализует ICommand, но и поддерживает всплытие как маршрутизируемые события.
        // helpButton.Command = ApplicationCommands.Help;
        // helpButton.Content = ApplicationCommands.Help.Text;
        // Совет
        // Строка Text во всех командах RoutedUICommand автоматически локализуется при использовании любого языка, поддерживаемого WPF! Это означает, что кнопка, свойству Content которой присвоено значение ApplicationCommands.Help.Text, автоматически будет называться «Справка», еслив текущей культуре пользовательского интерфейса задан русский язык. Даже в контексте, где предполагается использование изображений, а не текста (скажем, на панели инструментов), эту строку можно использовать, например, в виде всплывающей подсказки. Разумеется, ответственность за локализацию других строк в пользовательском интерфейсе по-прежнему ложится на вас. Использование свойства Text в командах лишь позволяет уменьшить количество нуждающихся в переводе терминов.
        // Для подключения своего кода необходимо добавить объект CommandBinding к самому элементу, который будет выполнять команду, или к любому его родителю (благодаря всплытию маршрутизируемых команд). Во всех классах, производных от UIElement (и ContentElement), имеется коллекция CommandBindings, в которой хранятся объекты типа CommandBinding. Поэтому объект CommandBinding для кнопки Help можно добавить прямо в корневой элемент Window окна About. В застраничном файле это делается так:
        // this.CommandBindings.Add(new CommandBinding(ApplicationCommands.Help, HelpExecuted, HelpCanExecute));

        // Выполнение команд с помощью жестов ввода
        // Применение команды Help в простом окне About может показаться перебором – ведь было бы достаточно простого обработчика события Click. Но у команды, помимо локализованного текста, есть и еще одно достоинство: автоматическая привязка к комбинации клавиш.
        // Можно связать с командой и свой жест ввода, добавив в коллекцию InputBindings подходящий объект KeyBinding и/или MouseBinding.
        // Например, чтобы назначить клавишу F2 в качестве активатора команды Help, можно добавить следующее предложение в конструктор класса AboutDialog:
        // this.InputBindings.Add(new KeyBinding(ApplicationCommands.Help, new KeyGesture(Key.F2)));
        // Но при этом активировать команду Help будут обе клавиши: F1 и F2. Чтобы подавить подразумеваемую по умолчанию клавишу F1, нужно связать с ней специальную команду NotACommand:
        // this.InputBindings.Add(new KeyBinding(ApplicationCommands.NotACommand, new KeyGesture(Key.F1)));
        // Оба предложения можно представить и в XAML-разметке следующим образом:
        //<Window.InputBindings>
        //<KeyBinding Command="Help" Key="F2"/>
        //<KeyBinding Command="NotACommand" Key="F1"/>
        //</Window.InputBindings>

        // Элементы управления со встроенными привязками к командам
        // Простейший пример – элемент TextBox, в который встроены привязки к командам Cut, Copy и Paste для взаимодействия с буфером обмена, а также к командам Undo и Redo. Это означает не только то, что TextBox реагирует на стандартные комбинации Ctrl+X, Ctrl+C, Ctrl+V, Ctrl+Z и Ctrl+Y, но и что в этих действиях могут принимать участие дополнительные элементы. 


        // !!!
        // - DependencyProperty
        // - RoutedEvent
    }
}
