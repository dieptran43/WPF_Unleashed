using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._2_WPFApplication_Creation._5_LayoutPanels
{
    /// <summary>
    /// Interaction logic for LayoutPanels.xaml
    /// </summary>
    public partial class LayoutPanels : Window
    {
        public LayoutPanels()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Canvas window = new Canvas();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            DockPanel window = new DockPanel();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            DockPanel1 window = new DockPanel1();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            VisualStudio window = new VisualStudio();
            window.Show();
        }

        private void Button_Click_4(object sender, RoutedEventArgs e)
        {
            GridSplitter window = new GridSplitter();
            window.Show();
        }

        private void Button_Click_5(object sender, RoutedEventArgs e)
        {
            SharedSizeGroup window = new SharedSizeGroup();
            window.Show();
        }

        // пять основных встроенных панелей
        // - Canvas
        // - StackPanel
        // - WrapPanel
        // - DockPanel
        // - Grid
        
        // Панель Canvas
        // Canvas поддерживает только «классическое» позиционирование элементов путем явного задания координат; впрочем, координаты хотя бы задаются в независимых от устройства пикселах, в отличие от прежних систем конструирования пользовательских интерфейсов. Панель Canvas позволяет задавать координаты относительнолюбого,  а не только левого верхнего угла.
        // Позиционирование элемента на холсте осуществляется с помощью присоединенных свойств: Left, Top, Right и Bottom. Задавая значение Left или Right, вы определяете, что ближайшая сторона элемента должна всегда отстоять на фиксированное расстояние от соответствующей стороны холста.
        // Для элемента нельзя задавать более двух присоединенных свойств Canvas!
        // невозможно пристыковать элемент более чем к одному углу холста.
        // Взаимодействие Canvas со свойствами компоновки дочерних элементов
        // Свойство - Допустимо ли внутри Canvas
        // Margin - Частично. Для двух сторон, использованных для позиционирования элемента (по умолчанию Top и Left), к значениям присоединенных свойств прибавляются соответствующие значения двух из четырех полей
        // HorizontalAlignment и VerticalAlignment - Нет. Элементам назначается в точности та величина вертикального выравнивания, которая им необходима
        // LayoutTransform - Да. Отличается от RenderTransform тем, что при использовании LayoutTransform элементы всегда отстоят на заданное расстояние от выбранного угла Canvas
        // СОВЕТ
        // Z-порядок по умолчанию (задающий, какие элементы располагаются «поверх » других) определяется порядком добавления дочерних элементов к родителю. В XAML это определяется порядком следования дочерних элементов в файле. Элементы, добавленные позже, располагаются поверх элементов, добавленных раньше. 
        // Это проявляется не только для встроенных панелей, допускающих перекрытие элементов (в частности, Canvas), но и в случае, когда к перекрытию приводит применение преобразования RenderTransform
        // Однако Z-порядок любого элемента можно задать явно, указав для него присоединенное свойство ZIndex, определенное в классе Panel (и наследуемое всеми панелями). ZIndex – это целое число, по умолчанию равное 0; оно может принимать любое целое значение (положительное или отрицательное). Элементы с большим значением ZIndex рисуются поверх элементов с меньшим значением, то есть элемент с наименьшим значением ZIndex оказывается позади всех остальных, а элемент с наибольшим значением – впереди.
        // Таким образом, для манипулирования Z-порядком из программы достаточно изменить значение ZIndex.
        // c#: Panel.SetZIndex(redButton, 0);
        // Canvas очень удобна для точного позиционирования примитивных фигур в векторных рисунках.

        // Панель StackPanel
        // она последовательно размещает своих потомков в виде стопки.
        // StackPanel и размещение справа налево
        // Если свойство FlowDirection равно RightToLeft, то для панели StackPanel с горизонтальной ориентацией сборка стопки производится справа налево, а не слева направо, как в случае по умолчанию.
        // единственный способ организовать дочерние элементы – воспользоваться свойством панели Orientation (типа System.Windows.Controls.Orientation), которое может принимать значение Horizontal или Vertical. По умолчанию подразумевается ориентация Vertical.
        // Взаимодействие StackPanel со свойствами компоновки дочерних элементов
        // Свойство - Допустимо ли внутри StackPanel
        // Margin - Да. Свойство Margin управляет промежутком между элементом и краями StackPanel, а также промежутком между краями соседних элементов 
        // HorizontalAlignment и VerticalAlignment - Частично, поскольку выравнивание игнорируется в направлении сборки стопки (так как дочерним элементам отводится ровно столько места, сколько им необходимо). Если Orientation="Vertical", то игнорируется значение VerticalAlignment. Если Orientation="Horizontal", то игнорируется значение HorizontalAlignment 
        // LayoutTransform - Да. Отличается от RenderTransform тем, что при использовании LayoutTransform оставшиеся в стопке элементы сдвигаются вниз, чтобы освободить место. При комбинировании компоновки Stretch с преобразованием RotateTransform или SkewTransform, применяемым в режиме LayoutTransform, растяжение происходит, только если угол кратен 90°
        // Виртуализирующие панели
        // Важной деталью реализации нескольких элементов управления являются панели, производные от абстрактного класса System.Windows.Controls.VirtualizingPanel. Наиболее интересная из них – панель VirtualizingStackPanel, которая работает, как StackPanel, но для повышения производительности временно игнорирует все элементы, не видные на экране (только во время привязки к данным).
        // Поэтому VirtualizingStackPanel является оптимальной панелью, когда требуется привязать к данным по-настоящему много дочерних элементов, и класс ListBox использует ее по умолчанию. Эту панель можно использовать также в TreeView, о чем пойдет речь в главе. Еще две виртуализирующие панели – DataGridCellsPanel и DataGridRowsPresenter, они используются в классе DataGrid и ассоциированных с ним  

        // Панель WrapPanel
        // Панель WrapPanel похожа на StackPanel. Но помимо организации дочерних элементов в стопку  она создает новые строки или столбцы, когда для одной стопки не хватает места. Это полезно для отображения заранее неизвестного числа элементов, когда компоновка должна отличаться от простого списка, – как, например, в Проводнике Windows.
        // В классе WrapPanel определены три свойства, контролирующие его поведение:
        // - Orientation – аналогично одноименному свойству StackPanel с тем отличием, что по умолчанию подразумевается значение Horizontal. Панель с горизонтальной ориентацией выглядит, как вид Эскизы страниц в Проводнике Windows: элементы располагаются один за другим слева направо, а когда место кончается, переходят на следующую строку. Панель с вертикальной ориентацией выглядит, как вид Список в Проводнике Windows: элементы располагаются один под другим, а когда место кончается, начинается новый столбец.
        // - ItemHeight – единая высота для всех дочерних элементов. Каким образом каждый потомок распоряжается этой высотой, зависит от значений его свойств VerticalAlignment, Height и пр. Элементы, ширина которых превышает ItemHeight, отсекаются. 
        // - ItemWidth – единая ширина для всех дочерних элементов. Каким образом каждый потомок распоряжается этой шириной, зависит от значений его свойств HorizontalAlignment, Width и пр. Элементы, высота которых превышает ItemWidth, отсекаются. 
        // по умолчанию ни в строках, ни в столбцах отсечение не производится.
        // Совет
        // Можно заставить панель WrapPanel располагать элементы в одну строку или в один столбец. Для этого следует присвоить свойству Width (в случае горизонтальной ориентации) или свойству Height (в случае вертикальной ориентации) значение Double.MaxValue либо Double.PositiveInfinity. В XAML это достигается с помощью расширения разметки x:Static, поскольку ни то ни другое значение не поддерживается конвертером типа System.Double.
        // WrapPanel и размещение справа налево
        // Если свойство FlowDirection равно RightToLeft, то для панели WrapPanel с вертикальной ориентацией новый столбец создается слева от заполненного, а для панели с горизонтальной ориентацией заполнение строки производится справа налево.
        // Взаимодействие WrapPanel со свойствами компоновки дочерних элементов
        // Свойство - Допустимо ли внутри WrapPanel
        // Margin - Да. Поля учитываются, когда WrapPanel вычисляет размеры элементов, чтобы определить подразумеваемую по умолчанию ширину или высоту стопки
        // HorizontalAlignment и VerticalAlignment - Частично. Выравнивание можно задавать в направлении, противоположном направлению роста стопки, как и в случае StackPanel. Но выравнивание может быть полезно и в направлении роста стопки, если значение ItemHeight или ItemWidth таково, что в элементе имеется дополнительное пространство для выравнивания 
        // LayoutTransform - Да. Отличается от RenderTransform тем, что при использовании LayoutTransform оставшиеся элементы сдвигаются, чтобы освободить место, но только если не установлено свойство  ItemHeight или ItemWidth (в зависимости от ориентации).  При комбинировании компоновки Stretch с преобразованием  RotateTransform или SkewTransform, применяемым в режимеLayoutTransform, растяжение происходит,только если угол кратен 90°, как и в случае StackPanel
        // Панель WrapPanel обычно используется не для компоновки элементов управления внутри окна Window, а для компоновки внутри вложенных элементов управления.

        // Панель DockPanel
        // Панель DockPanel дает простой способ пристыковки элемента к одной из сторон, растягивая его на всю имеющуюся ширину или высоту. (Отличие от Canvas заключается в том, что элементы пристыковываются не к одному углу, а ко всей стороне.) Кроме того, DockPanel позволяет расположить один элемент, так чтобы он занял все место, свободное от пристыкованных элементов.
        // В классе DockPanel определено присоединенное свойство Dock (типа System.Windows.Controls.Dock), с помощью которого дочерние элементы могут управлять своим положением. Оно может принимать четыре значения: Left (подразумевается по умолчанию, если свойство Dock не задано явно), Top, Right и Bottom 
        // Отметим, что у свойства Dock нет значения Fill, означающего, что нужно заполнить оставшееся место. Вместо этого действует соглашение о том, что все  оставшееся место отдается  последнему дочернему элементу, добавленному  в DockPanel, если только свойство  LastChildFill не равно false.
        // Как и в случае StackPanel, растяжение элементов определяется подразумеваемым по умолчанию значением свойства HorizontalAlignment или VerticalAlignment. 
        // Панель DockPanel полезна для организации верхнего уровня интерфейса внутри элемента Window или Page, когда пристыкованные элементы по большей части представляют собой другие панели, где и находится все самое важное.
        // Так, обычно к верхней стороне пристыковывается меню (Menu), справа и слева находятся какие-то панели, а снизу – строка состояния (StatusBar). Центральную же часть занимают основные данные приложения.
        // Таким образом, DockPanel является обобщением StackPanel. Если свойство LastChildFill равно false, то DockPanel ведет себя, как горизонтальная панель StackPanel 
        // Взаимодействие DockPanel со свойствами компоновки дочерних элементов
        // Margin - Да. Свойство Margin определяет, сколько места оставлять между элементом и стороной панели, а также промежуток между самими элементами 
        // HorizontalAlignment и VerticalAlignment - Частично. Как и в случае StackPanel, выравнивание в направлении пристыковки игнорируется. Иначе говоря, если Dock равно Left или Right, то не имеет смысла задавать свойство HorizontalAlignment, а если Top или Bottom – то свойство VerticalAlignment. Однако для элемента, заполняющего оставшееся пространство, применимы оба свойства, HorizontalAlignment и VerticalAlignment 
        // LayoutTransform - Да. Отличается от RenderTransform тем, что при использовании LayoutTransform оставшиеся элементы сдвигаются, чтобы освободить место. При комбинировании компоновки Stretch с преобразованием RotateTransform или SkewTransform, применяемым в режиме LayoutTransform, растяжение происходит, только если угол кратен 90°, за исключением элемента, заполняющего оставшееся пространство (потому что он может растягиваться в обоих направлениях)

        // Панель Grid
        // Grid (сетка) – самая гибкая из всех панелей и, пожалуй, наиболее употребительная. Она позволяет расположить дочерние элементы в несколько строк и несколько столбцов, не полагаясь на режим автоматического переноса. Работа с панелью Grid очень напоминает использование элемента TABLE в HTML.
        // Совет
        // В WPF также имеется класс Table (в пространстве имен System.Windows.Documents), предоставляющий примерно такие же возможности, как Grid. Но Table не наследует классу Panel (и даже классу UIElement). Этот класс, производный от FrameworkContentElement, предназначен для отображения содержимого документов
        // По умолчанию свойства RowSpan и ColumnSpan равны 1, но могут принимать любое значение, большее или равное 1, – соответственно количество строк или столбцов, занимаемых данной ячейкой.
        // Такой автоматический выбор размера достигается путем присваивания свойствам Height и Width соответственно в элементах RowDefinition и ColumnDefinition специального значения Auto, нечувствительного к регистру букв.
        // Как задать для ячеек сетки Grid цвет фона, отступ и рамку по аналогии с ячейками HTML-таблицы?
        // Чтобы придать ячейке цвет фона, достаточно поместить в нее прямоугольник Rectangle, задав для него такое значение свойства Fill, при котором он займет  всю ячейку. Чтобы получить  отступ, можно задать  режим автоматического выбора размера и установить поле Margin для соответствующего  дочернего элемента. Чтобы  получить рамку, мы снова  воспользуемся прямоугольником,  но явно зададим обводку  (свойство Stroke) нужного цвета ли поместим  внутрь элемент Border.
        // Задание размеров строк и столбцов
        // свойства Height и Width элементов RowDefinition и ColumnDefinition по умолчанию не равны Auto, они имеют тип System.Windows.GridLength, а не double. Поэтому панель Grid поддерживает три способа задания размера в элементах RowDefinition и ColumnDefinition:
        // - Абсолютный размер – числовое значение Height или Width означает, что размер задан в независимых от устройства пикселах 
        // - Автоматический выбор размера – если Height или Width равно Auto.
        // - Пропорциональное изменение размера *
        // С абсолютным и автоматическим заданием размера все понятно, но вот пропорциональное измерение требует пояснений. Звездочка работает следующим образом:
        // - Если высота строки или ширина столбца равна *, то соответствующему структурному элементу выделяется все оставшееся место.
        // - Если размер * задан для нескольких строк или столбцов, то все оставшееся место делится между ними поровну.
        // - Перед символом * можно указывать коэффициент (например, 2* или 5.5*), тогда соответствующей строке или столбцу будет выделено пропорционально больше места, чем остальным строкам или столбцам, в размере которых присутствует символ *.
        // Почему в WPF не встроена поддержка процентного задания размеров, как в HTML?
        // Разработчики WPF выбрали такой синтаксис, поскольку программисту не нужно будет следить за тем, чтобы сумма процентов оставалась равной 100 при динамическом добавлении или удалении столбцов. 
        // Конвертер типа System.Windows.GridLengthConverter преобразует строки вида "100", "auto" или "2*" в структуры GridLength. В C# для создания объекта GridLength можно воспользоваться одним из двух конструкторов. Ключом является перечисление GridUnitType, в котором определены все три вида значений.
        // GridLength length = new GridLength(100);
        // GridLength length = new GridLength(100, GridUnitType.Pixel);
        // GridLength length = new GridLength(0, GridUnitType.Auto);
        // GridLength length = new GridLength(2, GridUnitType.Star);

        // Интерактивное задание размера с помощью GridSplitter
        // Еще одна привлекательная особенность панели Grid – поддержка интерактивного изменения размера строк и столбцов мышью или клавишами.
        // В сетку Grid можно добавить произвольное число дочерних элементов GridSplitter, указав для них присоединенные свойства Grid.Row, Grid.Column, Grid.RowSpan и или Grid.ColumnSpan, как для любых других потомков.
        // Совет
        // Хотя GridSplitter по умолчанию располагается в одной ячейке, его действие всегда распространяется на весь столбец (при буксировке по горизонтали) или на всю строку (при буксировке по вертикали). Поэтому лучше задавать для него свойство ColumnSpan или RowSpan, так чтобы он пересекал всю сетку.
        // В классе GridSplitter свойство HorizontalAlignment по умолчанию равно Right, а свойство VerticalAlignment – Stretch, поэтому по умолчанию он примыкает к правой стороне указанной ячейки.
        // еще два свойства, позволяющих управлять поведением явно и независимо: ResizeDirection (типа GridResizeDirection) и ResizeBehavior (типа GridResizeBehavior). По умолчанию ResizeDirection (направление изменения размера) равно Auto, но может также принимать значение Rows или Columns, правда, они принимаются во внимание, лишь если GridSplitter растягивается в обоих направлениях
        // ResizeBehavior (поведение при изменении размера) по умолчанию равно BasedOnAlignment, при этом обеспечивается поведение. Но возможны также значения PreviousAndCurrent, CurrentAndNext или PreviousAndNext, которые управляют тем, на какие две строки или столбца изменение размера воздействует непосредственно.
        // Совет
        // Лучше всего поместить GridSplitter в отдельную строку или столбец с автоматическим выбором размера. В таком случае он не будет перекрывать содержимое соседних ячеек. Если вы все же решите поместить GridSplitter в одну ячейку с другими элементами, то хотя бы добавляйте его последним (или задавайте свойство ZIndex), чтобы Z-порядок для него был наибольшим

        // Задание общего размера для строк и столбцов
        // В классах RowDefinitions и ColumnDefinitions имеется свойство SharedSizeGroup, позволяющее задать режим, при котором линейные размеры нескольких строк и/или столбцов будут оставаться одинаковыми даже в случае, когда размер любой из них изменяетсяв процессе выполнения программы(например, с помощью GridSplitter).
        // Свойству SharedSizeGroup можно присвоить произвольное строковое значение
        // Размеры всех строк или столбцов, находящихся в одной группе, изменяются синхронно
        // Совет
        // Чтобы элемент GridSplitter был виден и доступен для использования, его ширина Width (или высота Height – в зависимости от ориентации) должна быть задана явно.
        // Свойство IsSharedSizeScope следует установить потому, что группы размеров могут применяться сразу к нескольким сеткам! Чтобы избежать потенциального конфликта имен (и сократить расходы на необходимый в этом случае обход логических деревьев), все сетки, к которым применяется одно и то же значение свойства SharedSizeGroup, должны находиться под общим родителем, а свойство IsSharedSizeScope для них должно быть равно true.
        // Это не просто свойство зависимости в классе Grid, но еще и присоединенное свойство, которое можно задавать для родителей, не являющихся сетками, например:
        // <StackPanel Grid.IsSharedSizeScope="True">
        // <Grid>...можно использовать SharedSizeGroup...</Grid>
        // <Grid>...можно использовать SharedSizeGroup...</Grid>
        // <WrapPanel>
        // <Grid>...можно использовать SharedSizeGroup...</Grid>
        // </WrapPanel>
        // </StackPanel>

        // Сравнение Grid с другими панелями
        // Единственное, чего ей не хватает, так это умения динамически генерировать новые строки и столбцы, как WrapPanel.
        // Взаимодействие Grid со свойствами компоновки дочерних элементов
        // Свойство - Допустимо ли внутри DockPanel
        // Margin - Да. Свойство Margin определяет, сколько места оставлять между элементом и сторонами объемлющей его ячейки
        // HorizontalAlignment и VerticalAlignment - Да. В отличие от остальных панелей, можно в полной мере использовать оба направления, если только не окажется, что ячейка с автоматическим изменением размеров вообще не оставила элементу дополнительного места. Поэтому по умолчанию большинство элементов растягиваются, заполняя свои ячейки целиком
        // LayoutTransform - Да. Отличается от RenderTransform тем, что при использовании LayoutTransform элементы остаются внутри ячеек (если это возможно) и учитывается величина поля  Margin. В отличие от RenderTransform, элемент, вышедший в результате масштабирования за пределы ячейки, отсекается
        // Совет
        // Хотя складывается впечатление, что панель Grid может практически все, в случае, когда количество дочерних элементов заранее неизвестно, лучше все же использовать StackPanel или WrapPanel. Кроме того, DockPanel со сложными подпанелями иногда предпочтительнее Grid, потому что изоляция, которую обеспечивают подпанели, удобнее в ситуации, когда пользовательский интерфейс изменяется. Если для этой цели использовать единственную сетку, то при добавлении строк и столбцов для сохранения иллюзии стыковки придется изменять свойства RowSpan и ColumnSpan.

        // Примитивные панели
        // в состав WPF входит также несколько простых панелей, более удобных внутри элементов управления
        // Все эти панели определены в пространстве имен System.Windows.Controls.Primitives, за исключением ToolBarTray, которая находится в пространстве имен System.Windows.Controls. 
        // Панель TabPanel
        // Как следует из ее названия, эта панель используется в подразумеваемом по умолчанию стиле элемента TabControl, где служит для организации вкладок
        // Панель ToolBarPanel
        // она работает совместно с панелью переполнения и организует элементы, не умещающиеся в ее пределах
        // Панель ToolBarOverflowPanel
        // используется в подразумеваемом по умолчанию стиле ToolBar для отображения не помещающихся элементов в области переполнения
        // Панель ToolBarTray
        // компонует элементы ToolBar последовательно
        // Панель UniformGrid
        // Панель UniformGrid интересна, но ее практическая полезность сомнительна. Это упрощенный вариант сетки Grid, в которой все строки и столбцы имеют размер *, и изменить это невозможно.
        // Панель SelectiveScrollingGrid
        // SelectiveScrollingGrid – подкласс Grid, используемый в подразумеваемом по умолчанию стиле элемента управления DataGridRow. В дополнение к функциональности Grid он позволяет «замораживать» некоторые ячейки, не препятствуя прокрутке остальных. Этим поведением управляет свойство SelectiveScrollingOrientation, принимающее следующие значения:
        // - None – ячейки не могут прокручиваться ни в каком направлении
        // - Horizontal – ячейки могут прокручиваться только по горизонтали
        // - Vertical – ячейки могут прокручиваться только по вертикали
        // - Both – ячейки могут прокручиваться в любом направлении. Это значение по умолчанию

        // Обработка переполнения содержимого
        // Встроенные панели делают все возможное для того, чтобы удовлетворить потребности своих дочерних элементов в месте на экране. Но иногда они вынуждены выделять потомкам меньше места, чем требуется, и бывает, что потомки отказываются полностьюрисовать себя, когда места недостаточно.
        // стратегии:
        // - отсечение
        // - прокрутку
        // - масштабирование
        // - оборачивание
        // - обрезку

        // Отсечение


        // !!!
    }
}
