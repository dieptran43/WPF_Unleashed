using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._3_Control_Elements._10_ManyChildElements
{
    /// <summary>
    /// Interaction logic for ManyChildElements.xaml
    /// </summary>
    public partial class ManyChildElements : Window
    {
        public ManyChildElements()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Selectors window = new Selectors();
            window.Show();
        }
    }

    // Помимо элементов управления содержимым, в WPF есть еще одна крупная категория элементов управления – многодетные элементы, которые могут содержать в качестве непосредственных потомков коллекции объектов, а не один-единственный объект. Все многодетные элементы управления наследуют абстрактному классу ItemsControl, который, как и ContentControl, является прямым подклассом Control.
    // В классе ItemsControl содержимое хранится в свойстве Items (типа ItemCollection). Коллекция может состоять из объектов произвольного типа, по умолчанию они визуализируются так же, как если бы находились внутри однодетного элемента. Иными словами, объекты типа UIElement визуализируются естественным образом, а все остальные типы (без учета шаблонов данных) – в виде текстового блока TextBlock, содержащего строку, которую возвращает метод ToString.
    // Дочерние элементы неявно добавляются в коллекцию Items, потому что Items – свойство содержимого. Этот список визуализируется. Оба элемента UIElement (Button и Expander) отображаются нормально и полностью интерактивны. Три объекта DateTime представляются в соответствии с тем, что возвращает их метод ToString.
    // свойство Items доступно только для чтения. Это означает, что в первоначально пустую коллекцию можно добавлять объекты, из нее можно удалять объекты, но нельзя записать в Items ссылку на совершенно другую коллекцию. В классе ItemsControl имеется еще одно свойство – ItemsSource, – которое поддерживает заполнение элемента объектами из уже существующей произвольной коллекции. 
    // СОВЕТ
    // Чтобы не усложнять изложение, мы в этой главе заполняем многодетные элементы управления только визуальными элементами. Однако предпочтительным является другой подход: поместить в многодетный элемент невизуальные элементы (например, специализированные бизнес-объекты) и с помощью шаблонов данных определить способ их визуализации.
    
    // Общая функциональность
    // Помимо свойств Items и ItemsSource, в классе ItemsControl есть еще несколько интересных свойств, а именно:
    // - HasItems – доступное только для чтения булевское свойство, упрощающее анализ наличия элементов в коллекции из декларативного XAML-кода. В программе на C# можно использовать это свойство или просто проверить значение Items.Count.
    // - IsGrouping – еще одно булевское свойство, доступное только для чтения. Информирует о том, разбиты ли объекты, входящие в элементы управления, на группы верхнего уровня. Группировка производится прямо в классе ItemsCollection, который включает несколько свойств для управления группами и присвоения им имен.
    // - AlternationCount и AlternationIndex – эти два свойства позволяют задать чередующиеся стили объектов-потомков в зависимости от индекса в коллекции. Например, если AlternationCount равно 2, то элементам с четным индексом будет назначен один стиль, а элементам с нечетным индексом – другой.
    // - DisplayMemberPath – строковое свойство; в него можно занести имя свойства каждого объекта (или более сложное выражение), которое изменяет порядок его визуализации. 
    // - ItemsPanel – свойство, позволяющее изменить способ организации объектов внутри многодетного элемента управления, не заменяя полностью его шаблон.
    
    // DisplayMemberPath
    // Поскольку в классах Button и Expander нет свойства DayOfWeek, то они отображаются в виде пустых текстовых блоков TextBlock.
    // Путь к свойству в WPF
    // Свойство DisplayMemberPath поддерживает синтаксис так называемого пути к свойству, который используется в WPF в нескольких местах, в частности для привязки к данным и анимации. Основная идея состоит в том, чтобы записать последовательность из одного или нескольких свойств, которую можно было бы использовать в процедурном коде для получения требуемого значения. Простейший пример пути – имя одного свойства, но если значением свойства является составной объект, то можно обратиться к его свойствам (и т. д.), разделяя отдельные имена свойств точками, как принято в C#. Этот синтаксис поддерживает даже индексаторы и массивы.
    // Представьте, к примеру, объект, в котором определено свойство FirstButton типа Button, причем в текущий момент значением свойства Content кнопки является строка "OK". Тогда значение этой строки ("OK") можно представить таким путем к свойству:
    // FirstButton.Content
    // А следующий путь к свойству представляет длину этой строки (2):
    // FirstButton.Content.Length
    // А такой путь – первый символ строки ('O'):
    // FirstButton.Content[0]
    // Эти выражения вполне соответствуют синтаксису C#, разве что приводить типы не требуется.

    // ItemsPanel
    // Как и в случае всех остальных элементов управления WPF, смыслом многодетных элементов является не их внешний вид, а способ хранения нескольких объектов, а часто также способ логического выбора объектов. Внешний облик всех элементов управления WPF можно изменить, применив другой шаблон, но для многодетных элементов есть и более короткий способ – заменить лишь часть шаблона, отвечающую за организацию хранящихся в нем объектов. Этот мини-шаблон, который еще называют внутренней панелью (items panel), позволяет подменить панель, применяемую для организации объектов, оставив все прочие аспекты элемента управления неизменными.
    // В качестве внутренней панели разрешается использовать любую из панелей (и вообще любой класс, производный от Panel).
    // Как заставить ListBox располагать свои объекты по горизонтали, а не по вертикали?
    // Присутствие ScrollViewer в шаблоне элемента по умолчанию объясняет, откуда берется поведение прокрутки. Управлять тем, как осуществляется прокрутка в многодетном элементе управления, позволяют различные присоединенные свойства элемента ScrollViewer.
    // <ControlTemplate TargetType="{x:Type ListBox}">
    // <Border ...>
    // <ScrollViewer Padding="{TemplateBinding Padding}" Focusable="false">
    // <ItemsPresenter SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"/>
    // </ScrollViewer>
    // </Border>
    // <ControlTemplate.Triggers>
    // ...
    // </ControlTemplate.Triggers>
    // </ControlTemplate>

    // Управление поведением прокрутки
    // На примере списка ListBox приведем подразумеваемые по умолчанию значения следующих свойств:
    // - ScrollViewer.HorizontalScrollBarVisibility – Auto
    // - ScrollViewer.VerticalScrollBarVisibility – Auto
    // - ScrollViewer.CanContentScroll – true
    // - ScrollViewer.IsDeferredScrollingEnabled – false
    // Если в многодетном элементе управления используется виртуализирующая панель и он содержит много сложных объектов, то установка для IsDeferredScrollingEnabled значения true может дать существенный прирост производительности за счет отказа от визуализации промежуточных состояний.
    // Например, Microsoft Outlook именно так прокручивает длинные списки.
    // ListBox – разумеется, не единственный многодетный элемент управления. Многодетные элементы можно разделить на три основных группы, которые обсуждаются в следующих разделах: селекторы, меню и все остальные.

    // Селекторы
    // Селекторами называются многодетные элементы управления, объекты которых можно индексировать и – что более важно – выбирать. Абстрактный класс Selector, производный от ItemsControl, добавляет несколько свойств, необходимых для поддержки выбора. Например, следующие три похожих свойства предназначены для получения и установки текущего выбранного объекта:
    // - SelectedIndex – отсчитываемое от нуля целое число, равное индексу выбранного объекта, или -1, если ничего не выбрано. Объекты нумеруются в порядке добавления в коллекцию.
    // - SelectedItem – сам выбранный объект.
    // - SelectedValue – значение выбранного объекта. По умолчанию оно совпадает с самим объектом, то есть SelectedValue – то же самое, что и SelectedItem. Однако с помощью свойства SelectedValuePath можно задать имя произвольного свойства или даже выражение, которое будет представлять значение объекта (SelectedValuePath работает аналогично DisplayMemberPath).
    // Все три свойства допускают чтение и запись, поэтому с их помощью можно не только получать текущий выбранный объект, но и устанавливать его.
    // В классе Selector определены также два присоединенных свойства, применяемые к отдельным объектам:
    // - IsSelected – булевское свойство, позволяющее выбрать или отменить выбор объекта (либо узнать, в каком состоянии он сейчас находится).
    // - IsSelectionActive – доступное только для чтения булевское свойство, которое сообщает, владеет ли выбранный объект фокусом.
    // В классе Selector имеется также событие SelectionChanged, которое позволяет получать уведомления об изменении выбранного объекта. 
    // В состав WPF входит пять элементов управления, производных от Selector:
    // - ComboBox
    // - ListBox
    // - ListView
    // - TabControl
    // - DataGrid

    // Элемент ComboBox
    // Он очень популярен, потому что занимает мало места на экране. В поле выбора отображается только объект, выбранный в данный момент, а весь остальной список раскрывается по требованию. Чтобы раскрыть или закрыть список, можно щелкнуть мышью, а также нажать сочетание клавиш Alt+стрелка вверх, Alt+стрелка вниз либо клавишу F4.
    // В классе ComboBox определены два события – DropDownOpened и DropDownClosed – и свойство IsDropDownOpen. Все вместе они позволяют реагировать на раскрытие или закрытие списка. Например, можно отложить заполнение ComboBox до момента раскрытия списка – обработав событие DropDownOpened.
    // Отметим, что свойство IsDropDownOpen допускает чтение и запись, то есть с его помощью можно напрямую управлять состоянием раскрытия.
    
    // Режимы работы поля выбора
    // Элемент ComboBox поддерживает режим, в котором пользователь может вводить в поле выбора произвольный текст. Если текст совпадает с каким-то из присутствующих в списке элементов, то этот элемент автоматически становится выбранным. В противном случае ни один элемент не будет выбран, но введенный текст сохраняется в свойстве Text элемента ComboBox, так что программа может получить к нему доступ. Этот режим контролируется двумя неудачно названными свойствами – IsEditable и IsReadOnly, – по умолчанию равными false. Кроме того, имеется свойство StaysOpenOnEdit; если оно равно true, то список остается раскрытым, когда пользователь щелкает по полю выбора (так ведут себя раскрывающиеся списки в Microsoft Office в противоположность стандартным спискам Win32).
    // Если поле выбора является полем ввода, то выбранный объект можно отображать только в виде простой строки. Это не страшно, если в списке ComboBox и так хранятся строки (или однодетные элементы управления, содержащие строки). Но если в списке находятся более сложные объекты, то необходимо сообщить ComboBox, как получить их строковое представление.
    // Понятно, что выводить в поле выбора имя типа "System.Windows.Controls.StackPanel" никуда не годится, и тут приходит на помощь класс TextSearch. В нем определены два присоединенных свойства, позволяющих управлять тем, что отображается в редактируемом поле выбора.
    // В чем разница между свойствами IsEditable и IsReadOnly элемента ComboBox?
    // Если IsEditable равно true, то поле выбора ComboBox превращается в поле ввода. Свойство IsReadOnly управляет тем, можно ли изменять текст в этом поле, – точно так же, как свойство IsReadOnly элемента TextBox. Таким образом, поле IsReadOnly не имеет смысла, если IsEditable не равно true, а тот факт, что IsEditable равно true, еще не означает, что текст в поле выбора можно редактировать.
    // К элементу ComboBox можно присоединить свойство TextSearch.TextPath и тем самым указать, какое свойство (или субсвойство) объекта отображать в поле выбора. Механизм работы такой же, как у свойств DisplayMemberPath и SelectedValuePath; единственное различие заключается в способе использования конечного значения.
    // <ComboBox IsEditable="True" TextSearch.TextPath="Children[1].Children[0].Text">
    // ...
    // </ComboBox>
    // Однако такое решение слишком хрупко – путь к свойству перестанет работать, если изменить структуру объекта. Не обрабатывается также случай разнородных объектов; объекты, не соответствующие структуре TextPath, представляются в поле выбора пустыми строками. 
    // В классе TextSearch есть еще одно присоединенное свойство Text; оно более гибкое, но применяться должно к индивидуальным объектам списка ComboBox. Значением свойства Text может  быть литеральный текст, отображаемый в поле выбора для данного элемента.
    // <ComboBox IsEditable="True">
    // <!-- Объект
    // #1 -->
    // <StackPanel TextSearch.Text="Curtain Call" Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // <!-- Объект
    // #2 -->
    // <StackPanel TextSearch.Text="Fireworks" Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // ...другие
    // объекты...
    // </ComboBox>
    // СОВЕТ
    // Можно подавить применение свойства TextSearch, задав свойство IsTextSearchEnabled элемента ItemsControl равным false. Свойство IsTextSearchCaseSensitive, также определенное в классе ItemsControl (по умолчанию равно false), указывает, надо ли при сравнении введенного текста с текстами присутствующих в списке объектов принимать во внимание регистр букв.
    // Как получить новый выбранный объект в обработчике события SelectionChanged?
    // Событие SelectionChanged предназначено для элементов управления, допускающих выбор нескольких объектов, поэтому для селектора типа ComboBox, позволяющего выбрать только один объект, работать с ним не очень удобно. Передаваемый обработчику события объект типа SelectionChangedEventArgs имеет два свойства типа IList: AddedItems и RemovedItems. Свойство AddedItems содержит множество вновь выбранных объектов, а свойство RemovedItems – множество ранее выбранных объектов. Если разрешено выбирать только один объект, то получить его можно следующим образом:
    // void ComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
    // {
    // if (e.AddedItems.Count > 0)
    // object newSelection = e.AddedItems[0];
    // }
    // Но не следует заранее предполагать, что какие-то элементы вообще выбраны (в приведенном выше коде это проверяется)! Мало того что выбор элемента в списке ComboBox можно отменить программно, так еще это может сделать и пользователь, если IsEditable равно true, а IsReadOnly – false. Если в этом случае пользователь введет в поле выбора значение, не совпадающее ни с одним из присутствующих в списке объектов, то событие SelectionChanged произойдет, но коллекция AddedItems будет пустой.
    // Класс ComboBoxItem
    // <!-- Объект
    // #1 -->
    // <ComboBoxItem TextSearch.Text="Curtain Call">
    // <StackPanel Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // </ComboBoxItem>
    // <!-- Объект
    // #2 -->
    // <ComboBoxItem TextSearch.Text="Fireworks">
    // <StackPanel Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // </ComboBoxItem>
    // ...другие объекты...
    // Отметим, что свойство TextSearch.Text теперь нужно присоединять к элементу ComboBoxItem, поскольку StackPanel больше не является самым внешним элементом хранимого объекта. Придется также модифицировать значение свойства TextSearch.TextPath, записав в него путь Content.Children[1].Children[0].Text.
    // А зачем мне самому обертывать объекты в ComboBoxItem?
    // В классе ComboBoxItem есть полезные свойства – IsSelected и IsHighlighted – и полезные события – Selected и Unselected. Применение ComboBoxItem позволяет также избежать странного поведения при показе однодетных элементов управления в поле выбора (когда IsEditable равно false): если объектом в списке ComboBox является однодетный элемент управления, то в поле выбора показывается не весь элемент, а только его свойство Content. Если же содержательный объект обернут в ComboBoxItem (тоже однодетный элемент), то содержимым последнего будет как раз исходный объект, который и требовалось показать. Так как ComboBoxItem – однодетный элемент управления, то его удобно использовать для добавления в список ComboBox простых строк (вместо того, чтобы обертывать их в TextBlock или Label).

    // Элемент ListBox
    // Уже знакомый нам элемент управления ListBox аналогичен ComboBox, только все объекты отображаются прямо в области, занятой элементом (если они не помещаются, то появится полоса прокрутки). 
    // Пожалуй, самая важная особенность ListBox состоит в том, что он поддерживает выбор нескольких объектов. Этим режимом управляет свойство SelectionMode, которое может принимать три значения (определенных в перечислении SelectionMode):
    // - Single – одновременно может быть выбран только один объект, как и в ComboBox. Это значение по умолчанию.
    // - Multiple – одновременно может быть выбрано несколько объектов. Щелчок по невыбранному объекту добавляет его в коллекцию SelectedItems, а щелчок по выбранному объекту удаляет его из этой коллекции. 
    // - Extended – одновременно может быть выбрано несколько объектов, но поведение оптимизировано для выбора одного объекта. Чтобы в этом режиме выбрать несколько объектов, следует во время щелчка мышью удерживать нажатой клавишу Shift (чтобы выбирать соседние элементы) или Ctrl (чтобы выбирать произвольные, необязательно соседние элементы). Точно так же ведет себя элемент управления ListBox в Win32. 
    // Как у ComboBox имеется компаньон ComboBoxItem, так и у ListBox есть компаньон ListBoxItem. С этим классом мы уже встречались в предыдущих главах. На самом деле ComboBoxItem наследует классу ListBoxItem, в котором и определены свойство IsSelected и события Selected и Unselected.
    // Свойства ListBox и множественный выбор
    // Хотя в классе ListBox имеется свойство SelectedItems, которым можно пользоваться вне зависимости от режима SelectionMode, он также наследует от класса Selector свойства SelectedIndex, SelectedItem и SelectedValue, не укладывающиеся в модель множественного выбора.
    // Если выбрано несколько объектов, то свойство SelectedItem просто указывает на первый элемент в коллекции SelectedItems (то есть тот, которым был выбран первым), а свойства SelectedIndex и SelectedValue возвращают индекс и значение этого объекта. Впрочем, для элементов управления, поддерживающих множественный выбор, этими свойствами лучше не пользоваться. Отметим, что в классе ListBox не определены свойства SelectedIndices и SelectedValues. 
    // Совет
    // Прием с использованием свойства TextSearch, продемонстрированный ранее для элемента ComboBox, сохраняет актуальность и для ListBox. Например, если объекты аннотировать соответствующими значениями TextSearch.Text, то при нажатии клавиши F в момент, когда ListBox владеет фокусом, выбранным станет объект Fireworks. Если бы TextSearch не было задано, то нажатие клавиши S привело бы к передаче фокуса списку, потому что S – первая буква в строке System.Windows.Controls.StackPanel. 
    // Как добиться плавной прокрутки ListBox?
    // По умолчанию ListBox прокручивается пообъектно. Поскольку шаг прокрутки рассчитывается на основе высоты объекта, то в случае больших объектов прокрутка может происходить рывками. Чтобы список прокручивался плавно, с шагом в несколько пикселов, не зависящим от высоты объектов, проще всего присвоить значение false свойству ScrollViewer.CanContentScroll, присоединенному к элементу ListBox, как было показано в предыдущей главе. 
    // Однако имейте в виду, что в таком режиме теряется возможность виртуализации списка. Под виртуализацией понимается оптимизация создания дочерних элементов – они создаются только в момент, когда оказываются видны на экране. Виртуализация возможна только в случае, когда для создания объектов, хранящихся в списке, применяется привязка к данным, поэтому установка для свойства CanContentScroll значения false может негативно сказаться на производительности работы списка, привязанного к данным.
    // Как отсортировать объекты в списке ListBox (да и в любом другом элементе типа ItemsControl)?
    // В основе сортировки лежит механизм, реализованный в классе ItemsCollection, поэтому он равным образом применим ко всем элементам, производным от ItemsControl. В классе ItemsCollection имеется свойство SortDescriptions. Это коллекция, которая может содержать сколько угодно объектов типа System.ComponentModel.SortDescription. Каждый такой объект описывает одно свойство, по которому производится сортировка, а также направление сортировки – по возрастанию или по убыванию.
    // Как снабдить объекты в элементе ItemsControl идентификаторами автоматизации, видными в инструментальных средствах, например в программе UI Spy?
    // Самый простой способ снабдить любой элемент, производный от FrameworkElement, идентификатором автоматизации – установить его свойство Name, поскольку именно оно по умолчанию применяется для целей автоматизации. Но если вы хотите назначить элементу идентификатор, отличный от его имени, то просто запишите желаемое значение в присоединенное свойство AutomationProperties.AutomationID (из пространства имен System.Windows.Automation).
    
    // Элемент ListView
    // Элемент управления ListView, производный от ListBox, выглядит и ведет себя, как ListBox, с тем отличием, что по умолчанию установлен режим Extended SelectionMode. Однако класс ListView добавляет также свойство View, которое расширяет возможности настройки внешнего вида, не ограничиваясь одним лишь выбором нестандартной панели ItemsPanel.
    // Свойство View принадлежит типу ViewBase, абстрактному классу. В состав WPF входит один конкретный подкласс этого класса, GridView.
    // В классе GridView имеется свойство содержимого Columns, в котором хранится коллекция объектов GridViewColumn, а также другие свойства, управляющие поведением заголовков столбцов. В WPF определен элемент ListViewItem, производный от ListBoxItem. В данном случае объекты DateTime неявно обернуты элементами ListViewItem, поскольку явно это не указано.
    // Объекты, хранящиеся в списке ListView, описываются в виде простого списка, как и в случае ListBox, поэтому ключом к отображению разных данных в различных столбцах служит свойство DisplayMemberBinding класса GridViewColumn. Идея в том, что в каждой строке ListView может находиться составной объект, а в столбцах отображаются свойства или субсвойства этого объекта. Но, в отличие от свойства DisplayMemberPath, определенного в классе ItemsControl, для работы со свойством DisplayMemberBinding необходима привязка к данным
    // Интересно, что GridView автоматически поддерживает кое-какие специальные возможности табличного вида Проводника Windows, а именно:
    // - Разрешается менять порядок столбцов путем перетаскивания их заголовков.
    // - Разрешается изменять размеры столбцов путем перетаскивания их разделителей.
    // - Двойной щелчок по разделителю столбцов приводит к автоматической подгонке их размера под размер содержимого столбца.
    // Однако GridView не поддерживает автоматическую сортировку щелчком по заголовку столбца, что, безусловно, является досадным упущением. Код сортировки объектов в результате щелчка по заголовку столбца совсем не сложен (достаточно воспользоваться вышеупомянутым свойством SortDescriptions), но вот рисовать внутри заголовка стрелочку, индицирующую факт и направление сортировки, придется самостоятельно. В общем и целом, ListView с видом GridView – сильно урезанный вариант элемента DataGrid. Но теперь, когда в WPF 4 появился настоящий элемент DataGrid, нужда в GridView сильно поуменьшилась.

    // Элемент TabControl
    // Следующий селектор, TabControl, полезен для переключения между страницами содержимого. Обычно вкладки располагаются вдоль верхнего края, но свойство TabStripPlacment (типа Dock) позволяет разместить их слева (Left), справа (Right) или снизу (Bottom). 
    // Работать с TabControl просто. Нужно лишь поместить внутрь него какие-нибудь объекты – и каждый объект автоматически окажется на отдельной вкладке.
    // В отличие от других селекторов, первый элемент TabItem по умолчанию оказывается выбранным. Однако в программе можно сделать все вкладки невыбранными, записав значение null в свойство SelectedItem или значение -1 в свойство SelectedIndex.

    // Элемент DataGrid
    // DataGrid – весьма гибкий элемент управления для отображения данных в виде таблицы с несколькими столбцами, допускающей  сортировку, редактирование и многое  другое. Он оптимизирован для связывания  с таблицей базы данных  в памяти (например, типа  System.Data.DataTable из ADO.NET). Мастера Visual Studio и такие технологии, как LINQ to SQL, предельно упрощают такое связывание.
    // Основные типы столбцов, поддерживаемые элементом DataGrid:
    // - DataGridTextColumn – идеален для представления строк, поскольку в обычном режиме используется элемент TextBlock, а в режиме редактирования – элемент TextBox.
    // - DataGridHyperlinkColumn – представляет обычный текст в виде гиперссылки, по которой можно щелкнуть. Отметим, однако, что со щелчком не ассоциируется никакое поведение по умолчанию (например, открытие браузера). Эти действия вы должны обрабатывать явно.
    // - DataGridCheckBoxColumn – идеален для представления булевских значений, поскольку используется элемент CheckBox, который в отмеченном состоянии соответствует значению true, а в сброшенном – значению false.
    // - DataGridComboBoxColumn – идеален для представления перечислений, поскольку в обычном режиме используется элемент TextBlock, а в режиме редактирования – элемент ComboBox, содержащий все возможные значения.
    // В WPF встроен еще один тип столбца:
    // - DataGridTemplateColumn – позволяет задать произвольные шаблоны для представления значения в обычном режиме и в режиме редактирования. Делается это с помощью свойств CellTemplate и CellEditingTemplate.
    
    // Автоматически генерируемые столбцы
    // Если объекты, отображаемые в элементе DataGrid, задаются с помощью свойства ItemsSource, то элемент пытается автоматически сгенерировать соответствующие столбцы. В таком случае для представления строк выбирается столбец типа DataGridTextColumn, для представления URI – столбец типа DataGridHyperlinkColumn, для представления булевских величин – столбец типа DataGridCheckBoxColumn, а для представления перечислений – столбец типа DataGridComboBoxColumn (при этом источник данных для значений перечисления присоединяется автоматически).
    // Если в элементе DataGrid уже были явно определены какие-то столбцы, то автоматически сгенерированные добавляются после них. Отдельные автоматически сгенерированные столбцы можно настроить или удалить, обработав событие AutoGeneratingColumn, которое возникает один раз для каждого столбца. После генерации всех столбцов один раз возникает событие AutoGeneratedColumns.
    // Чтобы вообще отменить автоматическую генерацию столбцов, достаточно присвоить свойству AutoGenerateColumns значение false.

    // Выбор строк и ячеек
    // Элемент DataGrid поддерживает несколько моделей выбора с помощью двух свойств – SelectionMode и SelectionUnit. Свойству SelectionMode можно присвоить значение Single – тогда разрешено выбирать только один объект, или значение Extended – в этом случае можно выбирать несколько объектов (это режим по умолчанию). Определение слова «объект» зависитот значения свойства SelectionUnit: 
    // - Cell – разрешено выбирать только отдельные ячейки.
    // - FullRow – разрешено выбирать только строки целиком.
    // - CellOrRowHeader – разрешено выбирать и то и другое (для выбора всей строки следует щелкнуть по ее заголовку). 
    // В режиме выбора нескольких объектов щелчок с нажатой клавишей Shift позволяет выбирать соседние объекты, а с нажатой клавишей Ctrl – произвольно расположенные объекты.
    // При выборе строк генерируется событие Selected, а свойство SelectedItems содержит коллекцию выбранных объектов. Для элемента DataGrid это была бы коллекция объектов типа Record. При выборе отдельных ячеек генерируется событие SelectedCellChanged, а свойство SelectedCells содержит список структур DataGridCellInfo, в которых хранится информация о соответствующих строках и столбцах. Выбираемые  объекты DataGridRow и DataGridCell также генерируют свои события  Selected, а их свойство IsSelected принимает значение true.
    // Даже если выбрано несколько ячеек или строк, в каждый момент времени фокус может принадлежать только одной ячейке. Получить или установить эту ячейку позволяет свойство CurrentCell. Кроме того, свойство CurrentColumn позволяет определить, в каком столбце находится ячейка CurrentCell, а свойство CurrentItem возвращает объект данных, соответствующий строке, которая содержит ячейку CurrentCell. 
    // Развитая поддержка множественного выбора и операций над выделенными объектами реализована в базовом классе MultiSelector, который наследует классу Selector и был впервые введен в версии WPF 3.5. Другие элементы управления WPF также поддерживают множественный выбор, но только DataGrid наследует классу MultiSelector.

    // Дополнительные настройки
    // Класс DataGrid поддерживает и другие способы настройки, например взаимодействие с буфером обмена, виртуализацию, возможность выводить дополнительную информацию для строк и «замораживать» столбцы.
    // Взаимодействие с буфером обмена.
    // Настроить, какие именно данные копируются из DataGrid в буфер обмена (например, при нажатии Ctrl+C после выбора объектов), позволяет свойство ClipboardCopyMode. Оно может принимать следующие значения:
    // - ExcludeHeader – не включать заголовки столбцов в копируемый текст. Это режим по умолчанию.
    // - IncludeHeader – включать заголовки столбцов в копируемый текст.
    // - None – ничего не копировать в буфер обмена.
    // Виртуализация. 
    // По умолчанию строки DataGrid виртуализируются (объекты UIElement не создаются для строк, невидимых на экране, причем в зависимости от источника данных даже выборка данных для этих строк может откладываться), а столбцы – нет. Для изменения этого поведения предназначены свойства EnableRowVirtualization (если оно равно false, то строки не виртуализируются) и EnableColumnVirtualization (если оно равно true, то столбцы виртуализируются). Свойство EnableColumnVirtualization по умолчанию не равно true, потому что в этом режиме может замедляться обновление изображения при горизонтальной прокрутке.
    // Дополнительная информация для строк. 
    // Элемент DataGrid поддерживает показ дополнительной информации в строках за счет установки свойства RowDetailsTemplate.
    // <DataGrid.RowDetailsTemplate>
    // <DataTemplate>
    // <TextBlock Margin="10" FontWeight="Bold">Details go here.</TextBlock>
    // </DataTemplate>
    // </DataGrid.RowDetailsTemplate>
    // По умолчанию дополнительная информация показывается только для выбранной строки (или строк), но это поведение можно изменить с помощью свойства RowDetailsVisibilityMode, принимающего следующие значения:
    // - VisibleWhenSelected – дополнительная информация показывается только для выбранных строк. Это режим по умолчанию.
    // - Visible – дополнительная информация показывается для всех строк.
    // - Collapsed – дополнительная информация вообще не показывается.
    // Замораживание столбцов.
    // Элемент DataGrid позволяет заморозить любое число столбцов. Это означает, что они не будут выдвинуты за пределы области элемента при горизонтальной прокрутке. Примерно так же заморозка столбцов работает в Microsoft Excel. Но имеется несколько ограничений: замораживать можно только самые левые столбцы и замороженные столбцы нельзя менять местами с незамороженными.
    // Чтобы заморозить один или несколько столбцов, достаточно присвоить свойству FrozenColumnCount любое значение, большее 0. Столбцы, начиная с третьего, можно прокручивать, поэтому- то и не видно заголовка третьего столбца.
    // Можно ли в DataGrid замораживать строки?
    // Нет, такая возможность не предусмотрена. Автоматически заморозить можно только дополнительную информацию для строк. Если свойство AreRowDetailsFrozen равно true, то вся показанная дополнительная информация не смещается при горизонтальной прокрутке.
    
    // Редактирование, добавление и удаление данных
    // 
 






    // !!!


}
