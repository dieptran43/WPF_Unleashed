using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._3_Control_Elements._10_ManyChildElements
{
    /// <summary>
    /// Interaction logic for ManyChildElements.xaml
    /// </summary>
    public partial class ManyChildElements : Window
    {
        public ManyChildElements()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Selectors window = new Selectors();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Menu window = new Menu();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            TreeView window = new TreeView();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            ToolBar window = new ToolBar();
            window.Show();
        }

        private void Button_Click_4(object sender, RoutedEventArgs e)
        {
            StatusBar window = new StatusBar();
            window.Show();
        }
    }

    // Помимо элементов управления содержимым, в WPF есть еще одна крупная категория элементов управления – многодетные элементы, которые могут содержать в качестве непосредственных потомков коллекции объектов, а не один-единственный объект. Все многодетные элементы управления наследуют абстрактному классу ItemsControl, который, как и ContentControl, является прямым подклассом Control.
    // В классе ItemsControl содержимое хранится в свойстве Items (типа ItemCollection). Коллекция может состоять из объектов произвольного типа, по умолчанию они визуализируются так же, как если бы находились внутри однодетного элемента. Иными словами, объекты типа UIElement визуализируются естественным образом, а все остальные типы (без учета шаблонов данных) – в виде текстового блока TextBlock, содержащего строку, которую возвращает метод ToString.
    // Дочерние элементы неявно добавляются в коллекцию Items, потому что Items – свойство содержимого. Этот список визуализируется. Оба элемента UIElement (Button и Expander) отображаются нормально и полностью интерактивны. Три объекта DateTime представляются в соответствии с тем, что возвращает их метод ToString.
    // свойство Items доступно только для чтения. Это означает, что в первоначально пустую коллекцию можно добавлять объекты, из нее можно удалять объекты, но нельзя записать в Items ссылку на совершенно другую коллекцию. В классе ItemsControl имеется еще одно свойство – ItemsSource, – которое поддерживает заполнение элемента объектами из уже существующей произвольной коллекции. 
    // СОВЕТ
    // Чтобы не усложнять изложение, мы в этой главе заполняем многодетные элементы управления только визуальными элементами. Однако предпочтительным является другой подход: поместить в многодетный элемент невизуальные элементы (например, специализированные бизнес-объекты) и с помощью шаблонов данных определить способ их визуализации.
    
    // Общая функциональность
    // Помимо свойств Items и ItemsSource, в классе ItemsControl есть еще несколько интересных свойств, а именно:
    // - HasItems – доступное только для чтения булевское свойство, упрощающее анализ наличия элементов в коллекции из декларативного XAML-кода. В программе на C# можно использовать это свойство или просто проверить значение Items.Count.
    // - IsGrouping – еще одно булевское свойство, доступное только для чтения. Информирует о том, разбиты ли объекты, входящие в элементы управления, на группы верхнего уровня. Группировка производится прямо в классе ItemsCollection, который включает несколько свойств для управления группами и присвоения им имен.
    // - AlternationCount и AlternationIndex – эти два свойства позволяют задать чередующиеся стили объектов-потомков в зависимости от индекса в коллекции. Например, если AlternationCount равно 2, то элементам с четным индексом будет назначен один стиль, а элементам с нечетным индексом – другой.
    // - DisplayMemberPath – строковое свойство; в него можно занести имя свойства каждого объекта (или более сложное выражение), которое изменяет порядок его визуализации. 
    // - ItemsPanel – свойство, позволяющее изменить способ организации объектов внутри многодетного элемента управления, не заменяя полностью его шаблон.
    
    // DisplayMemberPath
    // Поскольку в классах Button и Expander нет свойства DayOfWeek, то они отображаются в виде пустых текстовых блоков TextBlock.
    // Путь к свойству в WPF
    // Свойство DisplayMemberPath поддерживает синтаксис так называемого пути к свойству, который используется в WPF в нескольких местах, в частности для привязки к данным и анимации. Основная идея состоит в том, чтобы записать последовательность из одного или нескольких свойств, которую можно было бы использовать в процедурном коде для получения требуемого значения. Простейший пример пути – имя одного свойства, но если значением свойства является составной объект, то можно обратиться к его свойствам (и т. д.), разделяя отдельные имена свойств точками, как принято в C#. Этот синтаксис поддерживает даже индексаторы и массивы.
    // Представьте, к примеру, объект, в котором определено свойство FirstButton типа Button, причем в текущий момент значением свойства Content кнопки является строка "OK". Тогда значение этой строки ("OK") можно представить таким путем к свойству:
    // FirstButton.Content
    // А следующий путь к свойству представляет длину этой строки (2):
    // FirstButton.Content.Length
    // А такой путь – первый символ строки ('O'):
    // FirstButton.Content[0]
    // Эти выражения вполне соответствуют синтаксису C#, разве что приводить типы не требуется.

    // ItemsPanel
    // Как и в случае всех остальных элементов управления WPF, смыслом многодетных элементов является не их внешний вид, а способ хранения нескольких объектов, а часто также способ логического выбора объектов. Внешний облик всех элементов управления WPF можно изменить, применив другой шаблон, но для многодетных элементов есть и более короткий способ – заменить лишь часть шаблона, отвечающую за организацию хранящихся в нем объектов. Этот мини-шаблон, который еще называют внутренней панелью (items panel), позволяет подменить панель, применяемую для организации объектов, оставив все прочие аспекты элемента управления неизменными.
    // В качестве внутренней панели разрешается использовать любую из панелей (и вообще любой класс, производный от Panel).
    // Как заставить ListBox располагать свои объекты по горизонтали, а не по вертикали?
    // Присутствие ScrollViewer в шаблоне элемента по умолчанию объясняет, откуда берется поведение прокрутки. Управлять тем, как осуществляется прокрутка в многодетном элементе управления, позволяют различные присоединенные свойства элемента ScrollViewer.
    // <ControlTemplate TargetType="{x:Type ListBox}">
    // <Border ...>
    // <ScrollViewer Padding="{TemplateBinding Padding}" Focusable="false">
    // <ItemsPresenter SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"/>
    // </ScrollViewer>
    // </Border>
    // <ControlTemplate.Triggers>
    // ...
    // </ControlTemplate.Triggers>
    // </ControlTemplate>

    // Управление поведением прокрутки
    // На примере списка ListBox приведем подразумеваемые по умолчанию значения следующих свойств:
    // - ScrollViewer.HorizontalScrollBarVisibility – Auto
    // - ScrollViewer.VerticalScrollBarVisibility – Auto
    // - ScrollViewer.CanContentScroll – true
    // - ScrollViewer.IsDeferredScrollingEnabled – false
    // Если в многодетном элементе управления используется виртуализирующая панель и он содержит много сложных объектов, то установка для IsDeferredScrollingEnabled значения true может дать существенный прирост производительности за счет отказа от визуализации промежуточных состояний.
    // Например, Microsoft Outlook именно так прокручивает длинные списки.
    // ListBox – разумеется, не единственный многодетный элемент управления. Многодетные элементы можно разделить на три основных группы, которые обсуждаются в следующих разделах: селекторы, меню и все остальные.

    // Селекторы
    // Селекторами называются многодетные элементы управления, объекты которых можно индексировать и – что более важно – выбирать. Абстрактный класс Selector, производный от ItemsControl, добавляет несколько свойств, необходимых для поддержки выбора. Например, следующие три похожих свойства предназначены для получения и установки текущего выбранного объекта:
    // - SelectedIndex – отсчитываемое от нуля целое число, равное индексу выбранного объекта, или -1, если ничего не выбрано. Объекты нумеруются в порядке добавления в коллекцию.
    // - SelectedItem – сам выбранный объект.
    // - SelectedValue – значение выбранного объекта. По умолчанию оно совпадает с самим объектом, то есть SelectedValue – то же самое, что и SelectedItem. Однако с помощью свойства SelectedValuePath можно задать имя произвольного свойства или даже выражение, которое будет представлять значение объекта (SelectedValuePath работает аналогично DisplayMemberPath).
    // Все три свойства допускают чтение и запись, поэтому с их помощью можно не только получать текущий выбранный объект, но и устанавливать его.
    // В классе Selector определены также два присоединенных свойства, применяемые к отдельным объектам:
    // - IsSelected – булевское свойство, позволяющее выбрать или отменить выбор объекта (либо узнать, в каком состоянии он сейчас находится).
    // - IsSelectionActive – доступное только для чтения булевское свойство, которое сообщает, владеет ли выбранный объект фокусом.
    // В классе Selector имеется также событие SelectionChanged, которое позволяет получать уведомления об изменении выбранного объекта. 
    // В состав WPF входит пять элементов управления, производных от Selector:
    // - ComboBox
    // - ListBox
    // - ListView
    // - TabControl
    // - DataGrid

    // Элемент ComboBox
    // Он очень популярен, потому что занимает мало места на экране. В поле выбора отображается только объект, выбранный в данный момент, а весь остальной список раскрывается по требованию. Чтобы раскрыть или закрыть список, можно щелкнуть мышью, а также нажать сочетание клавиш Alt+стрелка вверх, Alt+стрелка вниз либо клавишу F4.
    // В классе ComboBox определены два события – DropDownOpened и DropDownClosed – и свойство IsDropDownOpen. Все вместе они позволяют реагировать на раскрытие или закрытие списка. Например, можно отложить заполнение ComboBox до момента раскрытия списка – обработав событие DropDownOpened.
    // Отметим, что свойство IsDropDownOpen допускает чтение и запись, то есть с его помощью можно напрямую управлять состоянием раскрытия.
    
    // Режимы работы поля выбора
    // Элемент ComboBox поддерживает режим, в котором пользователь может вводить в поле выбора произвольный текст. Если текст совпадает с каким-то из присутствующих в списке элементов, то этот элемент автоматически становится выбранным. В противном случае ни один элемент не будет выбран, но введенный текст сохраняется в свойстве Text элемента ComboBox, так что программа может получить к нему доступ. Этот режим контролируется двумя неудачно названными свойствами – IsEditable и IsReadOnly, – по умолчанию равными false. Кроме того, имеется свойство StaysOpenOnEdit; если оно равно true, то список остается раскрытым, когда пользователь щелкает по полю выбора (так ведут себя раскрывающиеся списки в Microsoft Office в противоположность стандартным спискам Win32).
    // Если поле выбора является полем ввода, то выбранный объект можно отображать только в виде простой строки. Это не страшно, если в списке ComboBox и так хранятся строки (или однодетные элементы управления, содержащие строки). Но если в списке находятся более сложные объекты, то необходимо сообщить ComboBox, как получить их строковое представление.
    // Понятно, что выводить в поле выбора имя типа "System.Windows.Controls.StackPanel" никуда не годится, и тут приходит на помощь класс TextSearch. В нем определены два присоединенных свойства, позволяющих управлять тем, что отображается в редактируемом поле выбора.
    // В чем разница между свойствами IsEditable и IsReadOnly элемента ComboBox?
    // Если IsEditable равно true, то поле выбора ComboBox превращается в поле ввода. Свойство IsReadOnly управляет тем, можно ли изменять текст в этом поле, – точно так же, как свойство IsReadOnly элемента TextBox. Таким образом, поле IsReadOnly не имеет смысла, если IsEditable не равно true, а тот факт, что IsEditable равно true, еще не означает, что текст в поле выбора можно редактировать.
    // К элементу ComboBox можно присоединить свойство TextSearch.TextPath и тем самым указать, какое свойство (или субсвойство) объекта отображать в поле выбора. Механизм работы такой же, как у свойств DisplayMemberPath и SelectedValuePath; единственное различие заключается в способе использования конечного значения.
    // <ComboBox IsEditable="True" TextSearch.TextPath="Children[1].Children[0].Text">
    // ...
    // </ComboBox>
    // Однако такое решение слишком хрупко – путь к свойству перестанет работать, если изменить структуру объекта. Не обрабатывается также случай разнородных объектов; объекты, не соответствующие структуре TextPath, представляются в поле выбора пустыми строками. 
    // В классе TextSearch есть еще одно присоединенное свойство Text; оно более гибкое, но применяться должно к индивидуальным объектам списка ComboBox. Значением свойства Text может  быть литеральный текст, отображаемый в поле выбора для данного элемента.
    // <ComboBox IsEditable="True">
    // <!-- Объект
    // #1 -->
    // <StackPanel TextSearch.Text="Curtain Call" Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // <!-- Объект
    // #2 -->
    // <StackPanel TextSearch.Text="Fireworks" Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // ...другие
    // объекты...
    // </ComboBox>
    // СОВЕТ
    // Можно подавить применение свойства TextSearch, задав свойство IsTextSearchEnabled элемента ItemsControl равным false. Свойство IsTextSearchCaseSensitive, также определенное в классе ItemsControl (по умолчанию равно false), указывает, надо ли при сравнении введенного текста с текстами присутствующих в списке объектов принимать во внимание регистр букв.
    // Как получить новый выбранный объект в обработчике события SelectionChanged?
    // Событие SelectionChanged предназначено для элементов управления, допускающих выбор нескольких объектов, поэтому для селектора типа ComboBox, позволяющего выбрать только один объект, работать с ним не очень удобно. Передаваемый обработчику события объект типа SelectionChangedEventArgs имеет два свойства типа IList: AddedItems и RemovedItems. Свойство AddedItems содержит множество вновь выбранных объектов, а свойство RemovedItems – множество ранее выбранных объектов. Если разрешено выбирать только один объект, то получить его можно следующим образом:
    // void ComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
    // {
    // if (e.AddedItems.Count > 0)
    // object newSelection = e.AddedItems[0];
    // }
    // Но не следует заранее предполагать, что какие-то элементы вообще выбраны (в приведенном выше коде это проверяется)! Мало того что выбор элемента в списке ComboBox можно отменить программно, так еще это может сделать и пользователь, если IsEditable равно true, а IsReadOnly – false. Если в этом случае пользователь введет в поле выбора значение, не совпадающее ни с одним из присутствующих в списке объектов, то событие SelectionChanged произойдет, но коллекция AddedItems будет пустой.
    // Класс ComboBoxItem
    // <!-- Объект
    // #1 -->
    // <ComboBoxItem TextSearch.Text="Curtain Call">
    // <StackPanel Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // </ComboBoxItem>
    // <!-- Объект
    // #2 -->
    // <ComboBoxItem TextSearch.Text="Fireworks">
    // <StackPanel Orientation="Horizontal" Margin="5">
    // ...
    // </StackPanel>
    // </ComboBoxItem>
    // ...другие объекты...
    // Отметим, что свойство TextSearch.Text теперь нужно присоединять к элементу ComboBoxItem, поскольку StackPanel больше не является самым внешним элементом хранимого объекта. Придется также модифицировать значение свойства TextSearch.TextPath, записав в него путь Content.Children[1].Children[0].Text.
    // А зачем мне самому обертывать объекты в ComboBoxItem?
    // В классе ComboBoxItem есть полезные свойства – IsSelected и IsHighlighted – и полезные события – Selected и Unselected. Применение ComboBoxItem позволяет также избежать странного поведения при показе однодетных элементов управления в поле выбора (когда IsEditable равно false): если объектом в списке ComboBox является однодетный элемент управления, то в поле выбора показывается не весь элемент, а только его свойство Content. Если же содержательный объект обернут в ComboBoxItem (тоже однодетный элемент), то содержимым последнего будет как раз исходный объект, который и требовалось показать. Так как ComboBoxItem – однодетный элемент управления, то его удобно использовать для добавления в список ComboBox простых строк (вместо того, чтобы обертывать их в TextBlock или Label).

    // Элемент ListBox
    // Уже знакомый нам элемент управления ListBox аналогичен ComboBox, только все объекты отображаются прямо в области, занятой элементом (если они не помещаются, то появится полоса прокрутки). 
    // Пожалуй, самая важная особенность ListBox состоит в том, что он поддерживает выбор нескольких объектов. Этим режимом управляет свойство SelectionMode, которое может принимать три значения (определенных в перечислении SelectionMode):
    // - Single – одновременно может быть выбран только один объект, как и в ComboBox. Это значение по умолчанию.
    // - Multiple – одновременно может быть выбрано несколько объектов. Щелчок по невыбранному объекту добавляет его в коллекцию SelectedItems, а щелчок по выбранному объекту удаляет его из этой коллекции. 
    // - Extended – одновременно может быть выбрано несколько объектов, но поведение оптимизировано для выбора одного объекта. Чтобы в этом режиме выбрать несколько объектов, следует во время щелчка мышью удерживать нажатой клавишу Shift (чтобы выбирать соседние элементы) или Ctrl (чтобы выбирать произвольные, необязательно соседние элементы). Точно так же ведет себя элемент управления ListBox в Win32. 
    // Как у ComboBox имеется компаньон ComboBoxItem, так и у ListBox есть компаньон ListBoxItem. С этим классом мы уже встречались в предыдущих главах. На самом деле ComboBoxItem наследует классу ListBoxItem, в котором и определены свойство IsSelected и события Selected и Unselected.
    // Свойства ListBox и множественный выбор
    // Хотя в классе ListBox имеется свойство SelectedItems, которым можно пользоваться вне зависимости от режима SelectionMode, он также наследует от класса Selector свойства SelectedIndex, SelectedItem и SelectedValue, не укладывающиеся в модель множественного выбора.
    // Если выбрано несколько объектов, то свойство SelectedItem просто указывает на первый элемент в коллекции SelectedItems (то есть тот, которым был выбран первым), а свойства SelectedIndex и SelectedValue возвращают индекс и значение этого объекта. Впрочем, для элементов управления, поддерживающих множественный выбор, этими свойствами лучше не пользоваться. Отметим, что в классе ListBox не определены свойства SelectedIndices и SelectedValues. 
    // Совет
    // Прием с использованием свойства TextSearch, продемонстрированный ранее для элемента ComboBox, сохраняет актуальность и для ListBox. Например, если объекты аннотировать соответствующими значениями TextSearch.Text, то при нажатии клавиши F в момент, когда ListBox владеет фокусом, выбранным станет объект Fireworks. Если бы TextSearch не было задано, то нажатие клавиши S привело бы к передаче фокуса списку, потому что S – первая буква в строке System.Windows.Controls.StackPanel. 
    // Как добиться плавной прокрутки ListBox?
    // По умолчанию ListBox прокручивается пообъектно. Поскольку шаг прокрутки рассчитывается на основе высоты объекта, то в случае больших объектов прокрутка может происходить рывками. Чтобы список прокручивался плавно, с шагом в несколько пикселов, не зависящим от высоты объектов, проще всего присвоить значение false свойству ScrollViewer.CanContentScroll, присоединенному к элементу ListBox, как было показано в предыдущей главе. 
    // Однако имейте в виду, что в таком режиме теряется возможность виртуализации списка. Под виртуализацией понимается оптимизация создания дочерних элементов – они создаются только в момент, когда оказываются видны на экране. Виртуализация возможна только в случае, когда для создания объектов, хранящихся в списке, применяется привязка к данным, поэтому установка для свойства CanContentScroll значения false может негативно сказаться на производительности работы списка, привязанного к данным.
    // Как отсортировать объекты в списке ListBox (да и в любом другом элементе типа ItemsControl)?
    // В основе сортировки лежит механизм, реализованный в классе ItemsCollection, поэтому он равным образом применим ко всем элементам, производным от ItemsControl. В классе ItemsCollection имеется свойство SortDescriptions. Это коллекция, которая может содержать сколько угодно объектов типа System.ComponentModel.SortDescription. Каждый такой объект описывает одно свойство, по которому производится сортировка, а также направление сортировки – по возрастанию или по убыванию.
    // Как снабдить объекты в элементе ItemsControl идентификаторами автоматизации, видными в инструментальных средствах, например в программе UI Spy?
    // Самый простой способ снабдить любой элемент, производный от FrameworkElement, идентификатором автоматизации – установить его свойство Name, поскольку именно оно по умолчанию применяется для целей автоматизации. Но если вы хотите назначить элементу идентификатор, отличный от его имени, то просто запишите желаемое значение в присоединенное свойство AutomationProperties.AutomationID (из пространства имен System.Windows.Automation).
    
    // Элемент ListView
    // Элемент управления ListView, производный от ListBox, выглядит и ведет себя, как ListBox, с тем отличием, что по умолчанию установлен режим Extended SelectionMode. Однако класс ListView добавляет также свойство View, которое расширяет возможности настройки внешнего вида, не ограничиваясь одним лишь выбором нестандартной панели ItemsPanel.
    // Свойство View принадлежит типу ViewBase, абстрактному классу. В состав WPF входит один конкретный подкласс этого класса, GridView.
    // В классе GridView имеется свойство содержимого Columns, в котором хранится коллекция объектов GridViewColumn, а также другие свойства, управляющие поведением заголовков столбцов. В WPF определен элемент ListViewItem, производный от ListBoxItem. В данном случае объекты DateTime неявно обернуты элементами ListViewItem, поскольку явно это не указано.
    // Объекты, хранящиеся в списке ListView, описываются в виде простого списка, как и в случае ListBox, поэтому ключом к отображению разных данных в различных столбцах служит свойство DisplayMemberBinding класса GridViewColumn. Идея в том, что в каждой строке ListView может находиться составной объект, а в столбцах отображаются свойства или субсвойства этого объекта. Но, в отличие от свойства DisplayMemberPath, определенного в классе ItemsControl, для работы со свойством DisplayMemberBinding необходима привязка к данным
    // Интересно, что GridView автоматически поддерживает кое-какие специальные возможности табличного вида Проводника Windows, а именно:
    // - Разрешается менять порядок столбцов путем перетаскивания их заголовков.
    // - Разрешается изменять размеры столбцов путем перетаскивания их разделителей.
    // - Двойной щелчок по разделителю столбцов приводит к автоматической подгонке их размера под размер содержимого столбца.
    // Однако GridView не поддерживает автоматическую сортировку щелчком по заголовку столбца, что, безусловно, является досадным упущением. Код сортировки объектов в результате щелчка по заголовку столбца совсем не сложен (достаточно воспользоваться вышеупомянутым свойством SortDescriptions), но вот рисовать внутри заголовка стрелочку, индицирующую факт и направление сортировки, придется самостоятельно. В общем и целом, ListView с видом GridView – сильно урезанный вариант элемента DataGrid. Но теперь, когда в WPF 4 появился настоящий элемент DataGrid, нужда в GridView сильно поуменьшилась.

    // Элемент TabControl
    // Следующий селектор, TabControl, полезен для переключения между страницами содержимого. Обычно вкладки располагаются вдоль верхнего края, но свойство TabStripPlacment (типа Dock) позволяет разместить их слева (Left), справа (Right) или снизу (Bottom). 
    // Работать с TabControl просто. Нужно лишь поместить внутрь него какие-нибудь объекты – и каждый объект автоматически окажется на отдельной вкладке.
    // В отличие от других селекторов, первый элемент TabItem по умолчанию оказывается выбранным. Однако в программе можно сделать все вкладки невыбранными, записав значение null в свойство SelectedItem или значение -1 в свойство SelectedIndex.

    // Элемент DataGrid
    // DataGrid – весьма гибкий элемент управления для отображения данных в виде таблицы с несколькими столбцами, допускающей  сортировку, редактирование и многое  другое. Он оптимизирован для связывания  с таблицей базы данных  в памяти (например, типа  System.Data.DataTable из ADO.NET). Мастера Visual Studio и такие технологии, как LINQ to SQL, предельно упрощают такое связывание.
    // Основные типы столбцов, поддерживаемые элементом DataGrid:
    // - DataGridTextColumn – идеален для представления строк, поскольку в обычном режиме используется элемент TextBlock, а в режиме редактирования – элемент TextBox.
    // - DataGridHyperlinkColumn – представляет обычный текст в виде гиперссылки, по которой можно щелкнуть. Отметим, однако, что со щелчком не ассоциируется никакое поведение по умолчанию (например, открытие браузера). Эти действия вы должны обрабатывать явно.
    // - DataGridCheckBoxColumn – идеален для представления булевских значений, поскольку используется элемент CheckBox, который в отмеченном состоянии соответствует значению true, а в сброшенном – значению false.
    // - DataGridComboBoxColumn – идеален для представления перечислений, поскольку в обычном режиме используется элемент TextBlock, а в режиме редактирования – элемент ComboBox, содержащий все возможные значения.
    // В WPF встроен еще один тип столбца:
    // - DataGridTemplateColumn – позволяет задать произвольные шаблоны для представления значения в обычном режиме и в режиме редактирования. Делается это с помощью свойств CellTemplate и CellEditingTemplate.
    
    // Автоматически генерируемые столбцы
    // Если объекты, отображаемые в элементе DataGrid, задаются с помощью свойства ItemsSource, то элемент пытается автоматически сгенерировать соответствующие столбцы. В таком случае для представления строк выбирается столбец типа DataGridTextColumn, для представления URI – столбец типа DataGridHyperlinkColumn, для представления булевских величин – столбец типа DataGridCheckBoxColumn, а для представления перечислений – столбец типа DataGridComboBoxColumn (при этом источник данных для значений перечисления присоединяется автоматически).
    // Если в элементе DataGrid уже были явно определены какие-то столбцы, то автоматически сгенерированные добавляются после них. Отдельные автоматически сгенерированные столбцы можно настроить или удалить, обработав событие AutoGeneratingColumn, которое возникает один раз для каждого столбца. После генерации всех столбцов один раз возникает событие AutoGeneratedColumns.
    // Чтобы вообще отменить автоматическую генерацию столбцов, достаточно присвоить свойству AutoGenerateColumns значение false.

    // Выбор строк и ячеек
    // Элемент DataGrid поддерживает несколько моделей выбора с помощью двух свойств – SelectionMode и SelectionUnit. Свойству SelectionMode можно присвоить значение Single – тогда разрешено выбирать только один объект, или значение Extended – в этом случае можно выбирать несколько объектов (это режим по умолчанию). Определение слова «объект» зависитот значения свойства SelectionUnit: 
    // - Cell – разрешено выбирать только отдельные ячейки.
    // - FullRow – разрешено выбирать только строки целиком.
    // - CellOrRowHeader – разрешено выбирать и то и другое (для выбора всей строки следует щелкнуть по ее заголовку). 
    // В режиме выбора нескольких объектов щелчок с нажатой клавишей Shift позволяет выбирать соседние объекты, а с нажатой клавишей Ctrl – произвольно расположенные объекты.
    // При выборе строк генерируется событие Selected, а свойство SelectedItems содержит коллекцию выбранных объектов. Для элемента DataGrid это была бы коллекция объектов типа Record. При выборе отдельных ячеек генерируется событие SelectedCellChanged, а свойство SelectedCells содержит список структур DataGridCellInfo, в которых хранится информация о соответствующих строках и столбцах. Выбираемые  объекты DataGridRow и DataGridCell также генерируют свои события  Selected, а их свойство IsSelected принимает значение true.
    // Даже если выбрано несколько ячеек или строк, в каждый момент времени фокус может принадлежать только одной ячейке. Получить или установить эту ячейку позволяет свойство CurrentCell. Кроме того, свойство CurrentColumn позволяет определить, в каком столбце находится ячейка CurrentCell, а свойство CurrentItem возвращает объект данных, соответствующий строке, которая содержит ячейку CurrentCell. 
    // Развитая поддержка множественного выбора и операций над выделенными объектами реализована в базовом классе MultiSelector, который наследует классу Selector и был впервые введен в версии WPF 3.5. Другие элементы управления WPF также поддерживают множественный выбор, но только DataGrid наследует классу MultiSelector.

    // Дополнительные настройки
    // Класс DataGrid поддерживает и другие способы настройки, например взаимодействие с буфером обмена, виртуализацию, возможность выводить дополнительную информацию для строк и «замораживать» столбцы.
    // Взаимодействие с буфером обмена.
    // Настроить, какие именно данные копируются из DataGrid в буфер обмена (например, при нажатии Ctrl+C после выбора объектов), позволяет свойство ClipboardCopyMode. Оно может принимать следующие значения:
    // - ExcludeHeader – не включать заголовки столбцов в копируемый текст. Это режим по умолчанию.
    // - IncludeHeader – включать заголовки столбцов в копируемый текст.
    // - None – ничего не копировать в буфер обмена.
    // Виртуализация. 
    // По умолчанию строки DataGrid виртуализируются (объекты UIElement не создаются для строк, невидимых на экране, причем в зависимости от источника данных даже выборка данных для этих строк может откладываться), а столбцы – нет. Для изменения этого поведения предназначены свойства EnableRowVirtualization (если оно равно false, то строки не виртуализируются) и EnableColumnVirtualization (если оно равно true, то столбцы виртуализируются). Свойство EnableColumnVirtualization по умолчанию не равно true, потому что в этом режиме может замедляться обновление изображения при горизонтальной прокрутке.
    // Дополнительная информация для строк. 
    // Элемент DataGrid поддерживает показ дополнительной информации в строках за счет установки свойства RowDetailsTemplate.
    // <DataGrid.RowDetailsTemplate>
    // <DataTemplate>
    // <TextBlock Margin="10" FontWeight="Bold">Details go here.</TextBlock>
    // </DataTemplate>
    // </DataGrid.RowDetailsTemplate>
    // По умолчанию дополнительная информация показывается только для выбранной строки (или строк), но это поведение можно изменить с помощью свойства RowDetailsVisibilityMode, принимающего следующие значения:
    // - VisibleWhenSelected – дополнительная информация показывается только для выбранных строк. Это режим по умолчанию.
    // - Visible – дополнительная информация показывается для всех строк.
    // - Collapsed – дополнительная информация вообще не показывается.
    // Замораживание столбцов.
    // Элемент DataGrid позволяет заморозить любое число столбцов. Это означает, что они не будут выдвинуты за пределы области элемента при горизонтальной прокрутке. Примерно так же заморозка столбцов работает в Microsoft Excel. Но имеется несколько ограничений: замораживать можно только самые левые столбцы и замороженные столбцы нельзя менять местами с незамороженными.
    // Чтобы заморозить один или несколько столбцов, достаточно присвоить свойству FrozenColumnCount любое значение, большее 0. Столбцы, начиная с третьего, можно прокручивать, поэтому- то и не видно заголовка третьего столбца.
    // Можно ли в DataGrid замораживать строки?
    // Нет, такая возможность не предусмотрена. Автоматически заморозить можно только дополнительную информацию для строк. Если свойство AreRowDetailsFrozen равно true, то вся показанная дополнительная информация не смещается при горизонтальной прокрутке.
    
    // Редактирование, добавление и удаление данных
    // Мы уже видели, что при использовании свойства ItemsSource автоматически поддерживается редактирование данных в отдельных объектах. Поскольку коллекция ItemsSource допускает также добавление и удаление объектов, то DataGrid автоматически поддерживает и эти операции.
    // для получения этой функциональности достаточно обернуть массив списком List<Record>
    // Теперь в сетке DataGrid внизу присутствует пустая строка, в которую в любой момент можно добавить данные. В классе DataGrid определены методы и команды для таких типичных действий, как начало редактирования (клавиша F2), отмена редактирования (клавиша Esc), сохранение результатов редактирования (клавиша Enter) и удаление строки (клавиша Delete).
    // Для предотвращения редактирования следует присвоить свойству IsReadOnly значение true, а чтобы запретить добавление или удаление строк, нужно присвоить значение false свойству CanUserAddRows или CanUserDeleteRows соответственно.
    // Хотя вход в режим редактирования (и переключение ячейки в такой режим) производится автоматически, по ходу дела возникает несколько событий, позволяющих вмешаться в этот процесс: PreparingCellForEdit, BeginningEdit, CellEditEnding/RowEditEnding и InitializeNewItem. 
    // ПРЕДУПРЕЖДЕНИЕ
    // Свойства CanUserAddRows и CanUserDeleteRows могут быть автоматически сброшены в false!
    // В зависимости от значений прочих свойств, свойства CanUserAddRows и CanUserDeleteRows могут оказаться равными false, хотя для них было явно установлено значение true! Например, если свойство IsReadOnly или IsEnabled элемента DataGrid равно false, то будут равны false и оба вышеупомянутых свойства. Есть и менее очевидный случай: если источник данных не поддерживает добавление или удаление (на что указывают свойства CanAddNew и CanRemove, определенные в интерфейсе IEditableCollectionView), то и CanUserAddRows, и CanUserDeleteRows будут равны false.
    
    // Меню
    // В WPF имеются оба элемента, относящихся к меню: Menu и ContextMenu.
    // Это просто еще один вид многодетных элементов, предназначенный для иерархического отображения объектов в виде каскадных выпадающих меню.
    
    // Элемент Menu
    // Элемент Menu располагает хранящиеся в нем объекты по горизонтали в строке характерного серого цвета (по умолчанию). К своему базовому классу ItemsControl класс Menu добавляет только свойство IsMainMenu. Если оно равно true (случай по умолчанию), то меню Menu получает фокус при нажатии клавиши Alt или F10, что соответствует ожиданиям пользователей, привыкших к меню в Win32.
    // Поскольку Menu – обычный многодетный элемент управления, то в качестве объектов в нем может храниться все что угодно, хотя предполагается, что это будут объекты типа MenuItem или Separator.
    // Класс MenuItem относится к многодетным элементам управления с заголовком (наследует классу HeaderedItemsControl) и во многом напоминает однодетные элементы управления с заголовком. В случае MenuItem свойство Header представляет собой основной объект (как правило, текст)
    // Так же как Button и Label, класс MenuItem поддерживает клавиши доступа, обозначаемые предшествующим знаком подчеркивания.
    // Separator – это простой элемент управления, который, будучи помещен в MenuItem, визуализируется в виде горизонтальной черты.
    // Этот класс может использоваться и в двух других многодетных элементах: ToolBar и StatusBar.
    // Хотя Menu – простой элемент управления, класс MenuItem содержит много свойств для настройки своего поведения. Приведем наиболее интересные.
    // - Icon – позволяет добавлять произвольный объект, отображаемый рядом с заголовком Header. Объект Icon визуализируется так же, как Header, хотя обычно представляет собой небольшое изображение.
    // - IsCheckable – наделяет MenuItem поведением флажка CheckBox.
    // - InputGestureText – позволяет аннотировать элемент меню ассоциированным с ним жестом (чаще всего какой-нибудь комбинацией клавиш, например Ctrl+O).
    // В классе MenuItem определено также пять событий: Checked, Unchecked, SubmenuOpened, SubmenuClosed и Click. Обычно для наделения пункта меню поведением применяется обработчик события Click, но можно также записать команду в свойство Command объекта MenuItem.
    // ПРЕДУПРЕЖДЕНИЕ
    // Задание свойства InputGestureText не ассоциирует с MenuItem соответствующую комбинацию клавиш!
    // Чтобы связать с MenuItem комбинацию клавиш, необходимо ассоциировать ее с командой с помощью свойства Command. Если с командой ассоциирован некий жест ввода, то в свойство InputGestureText объекта MenuItem автоматически записывается соответствующая ему строка, то есть текстовое представление комбинации клавиш отображается без каких-либо дополнительных действий.
    // СОВЕТ
    // Когда свойству Command объекта MenuItem присваивается ссылка на объект типа RoutedUICommand, в его свойство Header автоматически записывается значение свойства Text команды. Это поведение можно переопределить, установив заголовок Header явно.
    // Как расположить пункты Menu по вертикали, а не по горизонтали?
    // Поскольку Menu – обычный многодетный элемент управления, можно воспользоваться описанным выше при рассмотрении ListBox приемом – подменой панели ItemsPanel, только подразумеваемую по умолчанию панель следует заменить на StackPanel:
    // <Menu>
    // <Menu.ItemsPanel>
    // <ItemsPanelTemplate>
    // <StackPanel/>
    // </ItemsPanelTemplate>
    // </Menu.ItemsPanel>
    // ...
    // </Menu>
    // Если вы хотите, чтобы пункты меню были еще и повернуты на 90° (как в старых программах из пакета Microsoft Office в случае, когда меню перетаскивается и пристыковывается к левой или правой стороне окна), то воспользуйтесь преобразованием RotateTransform.
    
    // Элемент ContextMenu
    // Элемент ContextMenu работает так же, как Menu; это простой контейнер, предназначенный для хранения пунктов меню MenuItem и разделителей Separator. Однако же включать ContextMenu непосредственно в дерево элементов нельзя. Следует связывать его с элементом управления посредством подходящего присоединенного свойства, например свойства ContextMenu в классах FrameworkElement и FrameworkContentElement.
    // Контекстное меню элемента отображается, когда пользователь щелкает по элементу правой кнопкой мыши  (или нажимает комбинацию клавиш Shift+F10).
    // Помимо ожидаемого свойства IsOpen и событий Opened/Closed, в классе ContextMenu определено еще много свойств для настройки местоположения меню. По умолчанию левый верхний угол меню совпадает с позицией указателя мыши. Но свойство Placement может принимать и другие значения, кроме MousePoint (например, Absolute). К тому же с помощью свойств HorizontalOffset и VerticalOffset можно задавать смещение от указателя по горизонтали и вертикали. 
    // Как сделать, чтобы контекстное меню появлялось при щелчке правой кнопкой мыши по неактивному элементу?
    // Как и ToolTipService, класс ContextMenuService содержит присоединенное свойство ShowOnDisabled специально для этой цели. Используется оно следующим образом:
    // <ListBox ContextMenuService.ShowOnDisabled="True">
    // <ListBox.ContextMenu>
    // ...
    // </ListBox.ContextMenu>
    // ...
    // </ListBox>
    // Напомним, что с классом ToolTip связан статический класс ToolTipService, позволяющий управлять свойствами всплывающей подсказки из элемента, с которым она ассоциирована. Точно так же с классом ContextMenu связан статический класс ContextMenuService, предназначенный для той же цели. В нем имеется несколько присоединенных свойств, соответствующих свойствам, определенным в самом классе ContextMenu.
    
    // Другие многодетные элементы управления
    // Оставшиеся многодетные элементы управления – TreeView, ToolBar и StatusBar – не являются ни селекторами, ни меню, но тем не менее могут содержать неограниченное число произвольных объектов.
    
    // Элемент TreeView
    // TreeView – популярный элемент управления, предназначенный для отображения иерархически организованных данных с возможностью раскрывать и сворачивать узлы дерева.
    // TreeViewItem, как и MenuItem, – многодетный элемент управления с заголовком. В его свойстве Header хранится сам элемент, а в коллекции Items – его подэлементы (предполагается, что они также являются объектами типа TreeViewItem). 
    // В классе TreeViewItem имеются удобные свойства IsExpanded и IsSelected, а также четыре события, соответствующие четырем возможным состояниям этих свойств: Expanded, Collapsed, Selected и Unselected. Кроме того, класс TreeViewItem поддерживает навигацию с помощью клавиатуры: клавиши плюс (+) и минус (–) соответственно раскрывают и сворачивают узел, а клавиши со стрелками, Page Up, Page Down, Home и End дают разные способы передачи фокуса от одного узла другому. 
    // Сравнение классов TreeView и Selector
    // С точки зрения API класс TreeView очень похож на класс Selector, но не является производным от него, потому что для иерархически организованных объектов не существует естественного понятия целочисленного индекса. Поэтому в TreeView определены собственные свойства SelectedItem и SelectedValue (но не SelectedIndex). Также определено событие SelectedItemChanged, вместе с которым обработчику передаются не коллекции, а просто объекты OldValue и NewValue, поскольку TreeView поддерживает выбор только одного объекта.
    // СОВЕТ
    // В версии WPF 4 класс TreeView начал поддерживать виртуализацию, но включать ее нужно явно – путем установки для присоединенного свойства VirtualizingStackPanel.IsVirtualizing объекта TreeView значения true. Этот режим позволяет заметно сэкономить память и повысить производительность прокрутки, когда количество узлов очень велико.
    // ПРЕДУПРЕЖДЕНИЕ
    // Всегда явно обертывайте узлы TreeView элементами TreeViewItem!
    // Очень заманчиво использовать в качестве листовых узлов простые элементы TextBlock, но если вы так поступите, то можете столкнуться с одной тонкостью механизма наследования значений свойств, из-за которой текст в таких элементах, как TextBlock, как бы пропадает. По умолчанию выбор родительского элемента меняет его цвет Foreground на белый, и если текстовые блоки TextBlock являются прямыми логическими потомками этого элемента, то и к ним будет применен белый цвет. (Хотя визуальным родителем каждого текстового блока является неявный элемент TreeViewItem, в механизме наследования свойств приоритет отдается логическому родителю.) Понятно, что на подразумеваемом по умолчанию белом фоне такой текст не виден. Если же сделать TreeViewItem явным (логическим) родителем каждого блока TextBlock, то нежелательный эффект наследования не проявляется.

    // Элемент ToolBar
    // Отметим, что элементы Button и ComboBox на панели инструментов выглядят иначе, чем обычно. Кроме того, разделитель Separator теперь представляется вертикальной линией, а не горизонтальной, как в меню Menu. Элемент ToolBar переопределяет подразумеваемые по умолчанию стили своих дочерних элементов так, чтобы они выглядели привычно для большинства пользователей. 
    // Элементы ToolBar могут находиться в любом месте дерева элементов, но обычно их помещают в специальный контейнер ToolBarTray, производный от FrameworkElement. Объект ToolBarTray содержит коллекцию элементов ToolBar (в своем свойстве содержимого ToolBars) и, если его свойство IsLocked не равно true, позволяет перетаскивать панели инструментов и располагать их в другом месте. (В классе ToolBarTray определено также присоединенное свойство IsLocked, которое можно задавать для отдельных панелей ToolBar.) В классе ToolBarTray имеется свойство Orientation; если присвоить ему значение Vertical, то все содержащиеся в нем панели ToolBar будут ориентированы вертикально.
    // Если панель инструментов ToolBar содержит больше элементов, чем помещается в занимаемой ею области, то лишние попадают в область переполнения. Это всплывающее окно, для открытия которого нужно щелкнуть по стрелочке в конце панели.
    // поведением можно управлять с помощью присоединенного свойства OverflowMode из класса ToolBar. С его помощью можно определить, что элемент должен перемещаться в область переполнения по мере необходимости (AsNeeded – по умолчанию), всегда (Always) или никогда (Never).
    // СОВЕТ
    // Чтобы создать настраиваемую панель инструментов, как в Visual Studio, присвойте свойству ToolBar.OverflowMode значение Never для каждого элемента, затем добавьте элемент Menu с заголовком "_Add or Remove Buttons" (Добавить или удалить кнопки), для которого свойство ToolBar.OverflowMode должно быть равно Always (чтобы он всегда оставался в области переполнения). Далее в это меню можно добавить пункты MenuItem и сделать так, чтобы отметка флажка в таком пункте приводила к добавлению соответствующего пункта на панель инструментов, а сброс флажка – к убиранию элемента с панели.
    // СОВЕТ
    // Если элемент содержит небольшой значок, то имеет смысл задать для него присоединенное свойство RenderOptions.BitmapScalingMode, равное NearestNeighbor. Тогда изображение будет выглядеть гораздо четче, чем в обычном режиме прорисовки. Рассматриваемая в этом разделе панель ToolBar визуализируется именно в таком режиме. Хотя это свойство для удобства присоединено к самому элементу ToolBar, более правильно задавать его для каждой кнопки Button отдельно. Дело в том, что после перемещения в область переполнения кнопка перестает наследовать это свойство от родителя.
    // Настройка навигации с помощью клавиатуры
    // <ToolBar>
    // <Button>A</Button>
    // <Menu>
    // <MenuItem Header="B"/>
    // <MenuItem Header="C"/>
    // </Menu>
    // <Button>D</Button>
    // </ToolBar>
    // Если передать фокус панели ToolBar, а затем несколько раз нажать клавишу Tab, то фокус «застрянет» – будет передаваться от A к B, затем к C, к D и снова к A и далеепо кругу. А если нажимать клавишу со стрелкой влево или вправо, то фокус будет попеременно передаваться B и C.
    // Неиспользуемое свойство Header элемента ToolBar
    // На самом деле ToolBar – многодетный элемент управления с заголовком (как MenuItem и TreeViewItem). Его свойство Header никогда не отображается, но может быть полезно для реализации дополнительных возможностей ToolBarTray. Например, можно добавить контекстное меню, в котором перечислены все панели инструментов ToolBar (представленные своими заголовками Header), дав пользователям возможность добавлять или удалять панели. Или реализовать перемещаемые панели инструментов и показывать заголовок, когда панель «плавает».
    
    // Элемент StatusBar
    // Элемент StatusBar ведет себя, как Menu, но располагает своих потомков по горизонтали. Обычно его помещают вдоль нижнего края окна Window и используют для отображения информации о состоянии.
    // По умолчанию StatusBar переопределяет шаблон элемента управления Separator так, что он отображается в виде вертикальной линии, как на панели инструментов ToolBar. Дочерние элементы StatusBar (кроме Separator) неявно обертываются объектами StatusBarItem, но можно включить их и явно.
    // Как сделать, чтобы секции строки состояния пропорционально растягивались?
    // Очень часто желательно, чтобы отдельные секции строки состояния сохраняли пропорции. Например, левая секция должна занимать 25% ширины  StatusBar, а правая – 75%. Добиться этого эффекта можно, заменив внутреннюю  панель ItemsPanel сеткой Grid и сконфигурировав ее столбцы.
    // Отметим, что к элементам внутри StatusBar необходимо явно присоединять свойство Grid.Column (которое имеет смысл, только если в качестве ItemsPanel используется Grid), иначе все они окажутся в столбце с индексом 0. Кроме того, имейте в виду, что такие свойства компоновки работают только для потомков типа StatusBarItem и Separator. Дело в том, что остальные элементы (Label, ComboBox и Button  в рассматриваемом примере StatusBar) неявно обернуты объектами StatusBarItem, к которым нужные свойства не присоединены. Поэтому, чтобы добиться требуемого эффекта, необходимо обернуть их в StatusBarItem явно. 


    // !!!
}
