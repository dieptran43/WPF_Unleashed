using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._3_Control_Elements._9_1ChildElements
{
    /// <summary>
    /// Interaction logic for OneChildElements.xaml
    /// </summary>
    public partial class OneChildElements : Window
    {
        public OneChildElements()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Button window = new Button();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Label window = new Label();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            GroupBox window = new GroupBox();
            window.Show();
        }
    }

    // Встроенные в WPF элементы управления можно грубо разбить на следующие категории, основанные на иерархии наследования:
    // - Однодетные элементы управления (эта глава)
    // - Многодетные элементы управления (глава 10 «Многодетные элементы управления »)
    // - Диапазонные элементы управления (глава 11 «Изображения, текст и другие элементы управления »)
    // - Все остальное (глава 11) 
    // В этой главе мы рассмотрим однодетные элементы управления, то есть элементы, которые могут содержать всего один объект. Все они являются классами, производными от System.Windows.Controls.ContentControl, и имеют свойство Content типа Object, которое может содержать только один объект (одним из таких элементов является кнопка Button)
    // Поскольку содержимое однодетного элемента управления может быть произвольным объектом, то такой элемент, в принципе, может содержать большое дерево объектов. Но непосредственный потомок может быть только один. Помимо Content, в классе ContentControl есть еще один интересный член – булевское свойство HasContent. Оно возвращает false, если Content равно null, и true в противном случае.
    // Есть три основных разновидности однодетных элементов управления:
    // - Кнопки
    // - Простые контейнеры
    // - Контейнеры с заголовками
    // Почему в классе ContentControl определено свойство HasContent? Ведь сравнение Content==null ничуть не сложнее, чем HasContent==false!
    // Добро пожаловать в мир WPF API, который не всегда выглядит, как привычные .NET API! С точки зрения языка C# свойство HasContent избыточно. Но с точки зрения XAML оно очень полезно. Например, с его помощью гораздо проще реализовать триггер свойства, который устанавливает различные значения свойства, когда HasContent становится равным true.
    // Класс Window, также является однодетным элементомуправления. Его свойству Content обычно присваивается ссылка на какую-нибудь панель Panel, например Grid, так что внутри может находиться сколь угодно сложный пользовательский интерфейс.
    // Свойство Content и произвольные объекты
    // Раз значением свойства Content может быть любой управляемый объект, то, естественно, возникает вопрос, что произойдет, если в роли содержимого выступает невизуальный объект, например Hashtable или TimeZone. Ответ довольно прост: если содержимое является объектом класса, производного от UIElement, то оно визуализируется методом OnRender этого класса. Иначе, если к элементу применим шаблон данных, этот шаблонможет определять визуализацию от имени данного объекта. Или же вызывается метод ToString объекта-содержимогои возвращенный им текст рисуется внутри элемента TextBlock.

    // Кнопки
    // Базовая кнопка – это однодетный элемент управления, по которому можно щелкнуть, но нельзя щелкнуть дважды. Это поведение инкапсулировано в абстрактном классе ButtonBase, которому наследуют несколько разных элементов управления.
    // В классе ButtonBase имеется событие Click и определено, что понимается под «щелчком». Как и для обычных кнопок Windows, щелчок может возникать в результате нажатия и последующего отпускания левой кнопки мыши или нажатия клавиши Enter либо пробела, если кнопка владеет фокусом.
    // В классе ButtonBase определено также булевское свойство IsPressed на случай, если вам вдруг понадобится выполнить какие-то действия, когда кнопка нажата (то есть левая кнопка мыши или клавиша пробела нажата, но еще не отпущена).
    // Однако самым интересным свойством ButtonBase является ClickMode. Оно может принимать значения, определенные в перечислении ClickMode, и управляет тем, при каких условиях генерируется событие Click. Возможные значения: Release (по умолчанию), Press и Hover.
    // Click и другие события
    // Чтобы сгенерировать событие Click, класс ButtonBase анализирует такие более примитивные события, как MouseLeftButtonDown и MouseLeftButtonUp. Если ClickMode равно Release или Press, то ни одно из этих примитивных событий не всплывает дальше элемента, производного от ButtonBase, потому что ButtonBase присваивает свойству MouseButtonEventArgs. Handled значение true. В режиме Hover по той же причине не всплывают события MouseEnter и MouseLeave. Если вы все же хотите обрабатывать примитивные события мыши для элемента, производного от ButtonBase, то должны либо обрабатывать Preview-версию события (PreviewMouseLeftButtonDown, PreviewMouseLeftButtonUp и т. д.), либо присоединить свой обработчик в процедурном коде с помощью перегруженного варианта метода AddHandler, который игнорирует пометку события как обработанного. 
    // - Button
    // - RepeatButton
    // - ToggleButton
    // - CheckBox
    // - RadioButton

    // Класс Button
    // Класс Button в WPF добавляет к тому, что уже дает ButtonBase, два простых понятия: кнопка отмены и кнопка по умолчанию. Оба удобны для применения в диалоговых окнах. Если для некоторой кнопки, находящейся внутри диалогового окна (то есть окна Window, показанного методом ShowDialog), свойство Button.IsCancel равно true, то при нажатии этой кнопки окно автоматически закрывается и свойство DialogResult принимает значение false. Если свойство Button.IsDefault равно true, то нажатие клавиши Enter приводит к активизации этой кнопки, если только у нее явно не отобран фокус.
    // В чем разница между свойствами IsDefault и IsDefaulted класса Button?
    // Свойство IsDefault доступно для чтения и записи и определяет, будет ли данная кнопка считаться кнопкой по умолчанию. С другой стороны, свойство IsDefaulted (с неудачно выбранным именем) предназначено только для чтения. Оно показывает, что кнопка по умолчанию в данный момент находится в таком состоянии, что нажатие клавиши Enter приведет к ее активизации. Другими словами, IsDefaulted равно true только при выполнении следующих условий: IsDefault равно true и фокусом владеет либо сама кнопка по умолчанию, либо элемент TextBox (для которого AcceptsReturn равно false). Последнее условие позволяет клавише Enter нажать кнопку по умолчанию, не покидая элемент TextBox.
    // Как нажать кнопку из программы?
    // Классу Button, как и многим другим элементам управления WPF, соответствует класс в пространстве имен System.Windows.Automation.Peers, предназначенный для поддержки автоматизации пользовательского интерфейса: ButtonAutomationPeer. Для кнопки с именем myButton его можно использовать следующим образом
    // ButtonAutomationPeer bap = new ButtonAutomationPeer(myButton);
    // IInvokeProvider iip = bap.GetPattern(PatternInterface.Invoke)
    // as IInvokeProvider;
    // iip.Invoke(); // Это обращение приводит к нажатию кнопки
    // В подобных классах автоматизации есть несколько членов, которые чрезвычайно полезны для автоматизации тестирования и предоставления дополнительных возможностей.

    // Класс RepeatButton
    // Класс RepeatButton ведет себя так же, как Button, но продолжает генерировать событие Click до тех пор, пока кнопка нажата. (Кроме того, в нем нет понятия кнопки по умолчанию и кнопки отмены, так как он наследует непосредственно ButtonBase.) Частота генерации событий Click зависит от значений свойств Delay и Interval, которые по умолчанию равны SystemParameters.KeyboardDelay и SystemParameters.KeyboardSpeed соответственно.
    // Поведение RepeatButton на первый взгляд может показаться странным, но оно полезно (и является стандартным) для кнопок, которые при каждом нажатии увеличивают или уменьшают некоторое значение. Например, кнопки на концах полосы прокрутки демонстрируют именно такое поведение, когда вы щелкаете по ним и не отпускаете кнопку мыши. Другой пример: если бы вы захотели написать элемент «числовой счетчик » (пока не включенный в WPF), то, наверное, использовали бы пару элементов RepeatButton для управления числовым значением. Класс RepeatButton находится в пространстве имен System.Windows.Controls.Primitives, поскольку,скорее всего, он найдет применение только в составных элементах управления, а не сам по себе.

    // Класс ToggleButton
    // ToggleButton – это «залипающая » кнопка, которая сохраняет свое состояние после нажатия (понятия кнопки по умолчанию и кнопки отмены для нее тоже не определены). При первом щелчке свойство IsChecked становится равным true, при следующем – возвращается в false. По умолчанию ToggleButton выглядит точно так же, как Button и RepeatButton. 
    // В классе ToggleButton имеется также свойство IsThreeState; если оно равно true, то IsChecked может принимать три разных значения: true, false или null. На самом деле свойство IsChecked принадлежит типу Nullable<Boolean> (bool? в языке C#). В трехпозиционном режиме первый щелчок устанавливает для IsChecked значение true, второй – null, третий – false и т. д. Чтобы изменить порядок перехода состояний, можно либо перехватывать щелчки, обрабатывая Preview-версии событий мыши, и вручную присваивать свойству IsChecked требуемое значение, либо создать свой подкласс и переопределить в нем метод OnToggle класса ToggleButton, реализовав в нем нужную вам логику.
    // Помимо свойства IsChecked, в классе ToggleButton определено по одному событию для каждого значения IsChecked: Checked для true, Unchecked для false и Indeterminate для null. Может показаться странным, что не определено единственное событие IsCheckedChanged, но, как выясняется, наличие трех отдельных событий удобно в случае декларативной разметки.
    
    // Класс CheckBox
    // - У него имеется единственный вложенный элемент, задаваемый в разметке (в отличие от стандартного флажка).
    // - Для него определено понятие «нажатия » с помощью мыши или клавиатуры.
    // - После нажатия он сохраняет состояние: отмечен или сброшен.
    // - Он поддерживает трехпозиционный режим, в котором состояние циклически переключается между вариантами «отмечен », «неизвестно » и «сброшен ».
    // Класс CheckBox наследует ToggleButton и переопределяет лишь стиль по умолчанию
    // Поддержка клавиатуры в классе CheckBox
    // Класс CheckBox поддерживает одно дополнительное поведение, отсутствующее в ToggleButton, – в целях совместимости с малоизвестной особенностью флажков в Win32. Если флажок CheckBox владеет фокусом, то нажатие клавиши плюс (+) отмечает его, а клавиши минус (–) – сбрасывает! Отметим, что это работает, только если свойство IsThreeState равно false.
    
    // Класс RadioButton
    // Его уникальная особенность заключается в поддержке взаимного исключения. Если несколько элементов RadioButton помещены в одну группу, то в любой момент времени отмеченным может быть только один из них. Включение какого-то одного переключателя RadioButton – даже из программы – автоматически выключает все остальные переключатели в той же группе. На самом деле у пользователя даже нет возможности выключить какой-то элемент RadioButton, щелкнув по нему; выключение возможно только из программы. Таким образом, элемент RadioButton предназначен для формулирования вопроса, имеющего несколько вариантов ответа.
    // Но если требуется сгруппировать переключатели каким-то особым образом, то можно воспользоваться свойством GroupName, значением которого является строка. Все переключатели с одним и тем же значением GroupName помещаются в одну группу (при условии, что у них общий логический корень). Это позволяет группировать переключатели, принадлежащие разным родителям
    
    // Простые контейнеры
    // В WPF имеется несколько встроенных однодетных элементов управления, для которых, в отличие от кнопки, не определено понятие щелчка. У каждого из них есть свои уникальные особенности.
    // - Label
    // - ToolTip
    // - Frame

    // Класс Label
    // Label (метка) – классический элемент управления, который, как и в предшествующих технологиях, может содержать текст. Но, поскольку это однодетный элемент управления в смысле WPF, то в свойстве Content может находиться произвольное содержимое – Button, Menu и т. д., – хотя на практике метка все-таки используется в основном для представления текста.
    // WPF позволяет размещать текст на экране разными способами, например в элементе TextBlock. Уникальная особенность метки – поддержка клавиш доступа. В тексте метки можно выделить одну букву, так что нажатие соответствующей ей комбинации клавиш доступа – эта буква в сочетании с клавишей Alt – будет обрабатываться особым образом. Точнее, можно назначить произвольный элемент, который получит фокус при нажатии этой комбинации. Чтобы выделить букву (которая в зависимости от настроек Windows может быть подчеркнута), достаточно поместить перед ней знак подчеркивания. А чтобы назначить соответствующий целевой элемент, нужно задать свойство метки Target (типа UIElement). 
    // Совет
    // Такие элементы управления, как Label и Button, поддерживают клавиши доступа путем специальной обработки знака подчеркивания перед буквой, как, например, в названиях _Open или Save_As. (В Win32 и Windows Forms для этой цели применяется знак амперсанда [&], но подчеркивание значительно удобнее в контексте XML.) Если требуется, чтобы в тексте присутствовал сам знак подчеркивания, то надо записать его два раза подряд, например __Open или Save __As. 
    
    // Класс ToolTip
    // Элемент ToolTip нельзя помещать в дерево элементов UIElement непосредственно. Он должен быть присвоен свойству ToolTip отдельного элемента (это свойство определено в классах FrameworkElement и FrameworkContentElement). 
    // СОВЕТ
    // Если задается свойство ToolTip некоторого элемента, то элемент ToolTip можно вообще опустить! Это свойство имеет тип Object, и если присвоить ему ссылку на любой объект, отличный от ToolTip, то система автоматически создаст объект ToolTip и в качестве его содержимого будет использовать значение свойства. 
    // <Button>
    // OK
    // <Button.ToolTip>
    // Clicking this will submit your request.
    // </Button.ToolTip>
    // </Button>
    // и даже так:
    // <Button Content="OK" ToolTip="Clicking this will submit your request."/>
    // Хотя ToolTip может содержать интерактивные элементы управления, в частности кнопки, они никогда не получают фокус и щелчок или какие-либо иные действия с ними не дают никакого эффекта.
    // В классе ToolTip определены события Open и Closed на случай, если вы захотите что-то сделать при появлении и исчезновении подсказки.
    // Иногда желательно, чтобы один и тот же элемент ToolTip применялся к нескольким элементам управления, но при этом вел себя по-разному в зависимости от того, к чему присоединен. Для таких случаев предусмотрен статический класс ToolTipService.
    // Например, свойство ShowDuration определяет, как долго подсказка должна находиться на экране, когда указатель мыши находится над соответствующим элементом, а свойство InitialShowDelay задает время между приостановкой движения мыши и моментом появления подсказки.
    // Как сделать, чтобы всплывающая подсказка появлялась при задержке указателя мыши над неактивным элементом?
    // Просто воспользуйтесь присоединенным свойством ShowOnDisabled из класса ToolTipService.
    // <Button ToolTipService.ShowOnDisabled="True">
    // </Button>
    // А в C# следует вызвать статический метод, соответствующий присоединенному свойству.
    // ToolTipService.SetShowOnDisabled(myButton, true);
    // Как принудительно закрыть всплывающую подсказку?
    // Присвоить false ее свойству IsOpen.

    // Класс Frame
    // В элементе управления Frame может находиться произвольное содержимое, как и во всех остальных однодетных элементах управления. Однако он изолирует свое содержимое от остальной части пользовательского интерфейса.
    // Раз уж речь зашла о HTML, то претензии Frame на всеобщее признание связаны с тем, что он может визуализировать не только WPF-, но и HTML-содержимое. В классе Frame имеется свойство Source типа System.Uri, которому можно присвоить ссылку на любую страницу HTML (или XAML). 
    // <Frame Source="http://www.adamnathan.net"/>
    // Совет
    // При использовании Frame для переходов между веб-страницами не забывайте обрабатывать событие NavigationFailed, которое происходит при возникновении ошибки, и устанавливать для свойства NavigationFailedEventArgs.Handled значение true. В противном случае необработанное исключение (например, WebException) будет возбуждаться в другом потоке. Объект NavigationFailedEventArgs, который передается обработчику, среди прочего предоставляет доступ к объекту исключения.
    // Frame – это навигационный контейнер со встроенным механизмом запоминания истории, пригодный для отображения как HTML-, так и XAML-содержимого. Поэтому можно считать элемент Frame более гибкой версией элемента управления ActiveX Microsoft Web Browser или обертывающего его элемента WPF WebBrowser.
    // Совет
    // По сравнению с фреймами Frame элемент управления WPF WebBrowser (появившийся в WPF 3.5 SP1) предлагает более развитые средства для работы с HTML. Он поддерживает визуализацию HTML-разметки, представленной строкой в памяти или потоком Stream, а также интерактивное взаимодействие с HTML DOM и сценарии. Кроме того, он дает возможность включать Silverlight-содержимое в WPF-приложение: достаточно задать URL, указывающий на XAP-файл Silverlight. Отметим, что WebBrowser не является однодетным элементом управления; он не может содержать другие элементы WPF в качестве непосредственных потомков.
    // Свойство Content элемента Frame
    // Хотя Frame – однодетный элемент управления и имеет свойство Content, он не рассматривает его как свойство содержимого в смысле XAML. Иными словами, элемент Frame в XAML не поддерживает наличие дочернего элемента. Свойство Content необходимо задавать явно следующим образом
    // <Frame>
    // <Frame.Content>
    // ...
    // </Frame.Content>
    // </Frame>
    // По словам разработчиков WPF, для того, чтобы предотвратить некорректное использование свойства Content класса Frame, потому что типичным и ожидаемым способом работы с фреймом является задание свойства Source, указывающего на внешний файл. А единственная причина, по которой Frame сделан однодетным элементом управления, – необходимость сохранить совместимость с классом NavigationWindow, который рассматривался в главе 7. Отметим, что если заданы оба свойства Source и Content, то предпочтение отдается Content.

    // Контейнеры с заголовками
    // Следующие два элемента управления в этом отношении слегка отличаются, потому что добавляют к основному содержимому настраиваемый пользователем заголовок.
    // Они наследуют подклассу ContentControl, который называется HeaderedContentControl и добавляет свойство Header типа Object.

    // Класс GroupBox
    // Как правило, GroupBox применяется для охвата нескольких элементов, но поскольку это однодетный элемент управления, то у него может быть всего один непосредственный потомок. Поэтому обычно дочерним элементом GroupBox делают какой-то промежуточный элемент, способный содержать несколькопотомков. Для этой цели идеально подходит панель, например StackPanel.
    // Как и Content, свойство Header может ссылаться на произвольный объект, и если это объект класса, производного от UIElement, то отображается он естественным образом.

    // Класс Expander
    // Элемент Expander может заинтриговать, потому что это единственный из рассматриваемых в данной главе элементов управления, не имеющий аналогов в предшествующих технологиях конструирования пользовательских интерфейсов, в том числе в Windows Forms! Expander очень похож на GroupBox, но содержит кнопку, которая позволяет сворачивать и разворачивать внутреннее содержимое
    // В классе Expander определено свойство IsExpanded и события Expanded/Collapsed. Кроме того, он позволяет задать направление развертывания (Up, Down, Left, Right) с помощью свойства ExpandDirection.
    // Кнопка внутри Expander в действительности представляет собой элемент ToggleButton с измененным стилем. Помимо Expander, еще в нескольких составных элементах используются примитивные элементы управления, такие как ToggleButton и RepeatButton.


    // !!!
}
