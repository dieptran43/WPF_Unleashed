using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._3_Control_Elements._11_ImageTextOther
{
    /// <summary>
    /// Interaction logic for ImageTextOther.xaml
    /// </summary>
    public partial class ImageTextOther : Window
    {
        public ImageTextOther()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Image window = new Image();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            TextInk window = new TextInk();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            Documents window = new Documents();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            Spans window = new Spans();
            window.Show();
        }

        private void Button_Click_4(object sender, RoutedEventArgs e)
        {
            Comments window = new Comments();
            window.Show();
        }

        private void Button_Click_5(object sender, RoutedEventArgs e)
        {
            RangeControls window = new RangeControls();
            window.Show();
        }

        private void Button_Click_6(object sender, RoutedEventArgs e)
        {
            CalendarControls window = new CalendarControls();
            window.Show();
        }
    }

    // Элемент управления Image
    // Класс System.Windows.Controls.Image позволяет включать в пользовательский интерфейс изображения (в формате BMP, PNG, GIF, JPG и др.). В нем имеется свойство Source типа System.Windows.Media.ImageSource, но благодаря конвертеру типа System.Windows.Media.ImageSourceConverter его можно задавать в XAML в виде простой строки, например:
    // <Image Source="zoom.gif"/>
    // Свойство ImageSource может указывать на изображения, представленные URL- адресом, хранящиеся в файловой системе и даже внедренные в сборку.
    // В классе Image определены те же самые свойства Stretch и StretchDirection – они позволяют управлять масштабированием.
    // К элементу Image можно присоединить свойство RenderOptions.BitmapScalingMode, задающее компромисс между скоростью и качеством визуализации. Из всех принимаемых им значений наиболее важным является NearestNeighbor – это режим масштабирования растрового изображения по ближайшей соседней точке, при котором изображение становится более четким.
    // <Image RenderOptions.BitmapScalingMode="NearestNeighbor" Source="zoom.gif"/>
    // СОВЕТ
    // Вместо того чтобы пользоваться конвертером типа для преобразования строкового имени файла в объект ImageSource, можно явно присвоить свойству Source объекта Image ссылку на объект одного из подклассов ImageSource, что открывает дополнительные возможности. Например, в подклассе BitmapImage есть ряд свойств, таких как DecodePixelWidth и DecodePixelHeight, с помощью которых можно задать размер изображения, меньший естественного, и тем самым сэкономить память – иногда довольно ощутимо. Подкласс FormatConvertedBitmap позволяет изменять формат пикселов Image, создавая различные эффекты, например переход к полутоновому изображению.
    // <StackPanel Orientation="Horizontal">
    // <!-- Нормальное изображение, формат пикселов Pbgra32: -->
    // <Image Source="photo.jpg" />
    // <!-- Полутоновое изображение:
    // -->
    // <Image>
    // <Image.Source>
    // <FormatConvertedBitmap Source="photo.jpg" DestinationFormat="Gray32Float" />
    // </Image.Source>
    // </Image>
    // <!-- Черно-белое изображение:
    // -->
    // <Image>
    //    <Image.Source>
    // <FormatConvertedBitmap Source="photo.jpg" DestinationFormat="BlackWhite" />
    // </Image.Source>
    // </Image>
    // </StackPanel>
    // Длинный перечень возможных форматов определен в перечислении System.Windows.Media.PixelFormats.
    
    // Элементы управления Text и Ink
    // Помимо элементов TextBlock и Label WPF содержит еще ряд элементов для отображения и редактирования текста – посредством как клавиатурного набора, так и рукописного ввода с помощью стилуса. В этом разделе мы чуть подробнее рассмотрим элемент TextBlock, а также поговорим о следующих элементах:
    // - TextBox
    // - RichTextBox
    // - PasswordBox
    // - InkCanvas
    // Главное, о чем нужно знать, – это присоединенное свойство TextOptions.TextFormattingMode. Его можно задавать как для отдельных текстовых элементов, так и – что практикуется чаще – для родительского элемента, например Window; в последнем случае оно распространяется на визуализацию текста во всем дереве элементов-потомков. Присвоив свойству TextFormattingMode значение Display, вы включите новый механизм визуализации текста в WPF 4, в котором применяются метрики текста, совместимые с GDI. С точки зрения четкости текста основная особенность этого механизма состоит в том, что каждый глиф позиционируется на границе пикселов (а его ширина кратна ширине пиксела). 
    // Присоединенному свойству TextOptions.TextRenderingMode можно присвоить значение ClearType, Grayscale, Aliased или Auto – для управления режимом сглаживания текста (antialiasing). При заданном значении Auto (по умолчанию) будет действовать режим ClearType, если эта технология не отключена на данном компьютере, в противном случае – режим Grayscale.
    // Далее свойству TextOptions.TextHintingMode можно присвоить значение Fixed, Animated или Auto – для оптимизации отображения в зависимости от того, является текст стационарным или анимированным.
    // Не следует ли всегда задавать значение Display свойства TextFormattingMode, чтобы оптимизировать визуализацию текста?
    // Нет. Если текст отображается достаточно крупным кеглем (FontSize порядка 15 или больше), то режим Ideal дает такое же четкое изображение, как режим Display, а глифы располагаются лучше. Но еще важнее то, что в случае применения к тексту геометрического преобразования режим Display оказывается хуже, поскольку выравнивание на границы пикселов больше не применяется. 
    // Но для типичных меток, отображаемых мелким шрифтом, у режима Display нет конкурентов.

    // Элемент TextBlock
    // У элемента TextBlock есть ряд простых свойств, модифицирующих его внешний вид, например FontFamily, FontSize, FontStyle, FontWeight и FontStretch. Но главный сорприз TextBlock заключается в том, что его свойством содержимого является не Text, а коллекция объектов Inlines. Хотя показанная ниже разметка дает тот же самый результат, что и установка свойства Text, в действительности мы устанавливаем другое свойство:
    // <!-- Здесь устанавливается свойство TextBlock.Inlines: -->
    // <TextBlock>Text in a TextBlock</TextBlock>
    // эквивалентно
    // <TextBlock><Run Text="Text in a TextBlock"/></TextBlock>
    // эквивалентно 
    // <TextBlock><Run>Text in a TextBlock</Run></TextBlock>
    // Однако в классе Run имеется несколько свойств форматирования, позволяющих переопределить соответствующие свойства, установленные в родительском элементе TextBlock, а именно: FontFamily, FontSize, FontStretch, FontStyle, FontWeight, Foreground и TextDecorations. 
    // TextBlock и пустое пространство
    // Если содержимое TextBlock устанавливается с помощью свойства Text, то все символы пробела сохраняются. Если же оно устанавливается с помощью свойства Inlines в XAML, то пустое пространство не сохраняется. Начальные и конечные пробелы при этом игнорируются, а соседние пробелы заменяются одним 
    // СОВЕТ
    // При добавлении содержимого в свойство Inlines элемента TextBlock его неформатированное представление дописывается в конец свойства Text. Поэтому программа по-прежнему может пользоваться свойством Text, даже если явно устанавливается только Inlines.
    // Явно и неявно заданные фрагменты Run
    // <TextBlock>Text in<LineBreak/>a TextBlock</TextBlock>
    // эквивалентно
    // <TextBlock><Run>Text in</Run><LineBreak/><Run>a TextBlock</Run></TextBlock>

    // Элемент TextBox
    // В отличие от большинства других элементов управления в WPF, содержимое TextBox хранится не в виде объекта типа System.Object, а в строковом свойстве Text.
    // Хотя на первый взгляд TextBox выглядит очень просто, в него встроена весьма развитая функциональность, привязки для команд Cut, Copy, Paste, Undo и Redo и даже проверка правописания!
    // В классе TextBox определено несколько методов и свойств для выбора различных частей текста (выделенного фрагмента, по номеру строку и т. д.), а также методы для поиска физической точки в тексте по номеру строки и символа и наоборот. Определены также события TextChanged и SelectionChanged. 
    // Если на размер элемента TextBox не налагает ограничений окружение (и он не задан явно), то элемент растет по мере добавления в него текста. Если же ширина TextBox ограничена, то можно установить режим переноса строк, присвоив свойству TextWrapping значение Wrap или WrapWithOverflow. В режиме Wrap содержимое ни при каких условиях не может выйти за пределы области, занятой элементом, даже если придется разорвать строку в середине слова. В режиме WrapWithOverflow строка разрывается, только если есть такая возможность, так что длинные слова могут выйти за границы области.
    // Как сделать, чтобы элемент TextBox поддерживал ввод нескольких строк текста?
    // Если присвоить свойству AcceptsReturn значение true, то при нажатии клавиши Enter будет создаваться новая строка. Отметим, что TextBox в любом случае поддерживает создание многострочных текстов из программы. Если записать в свойство Text текст, содержащий символы NewLine, то он отобразится в виде нескольких строк вне зависимости от значения AcceptsReturn.
    // Проверка правописания
    // Чтобы включить проверку правописания в TextBox (или RichTextBox), необходимо присвоить присоединенному свойству SpellCheck.IsEnabled значение true.
    
    // Элемент RichTextBox
    // Элемент RichTextBox предоставляет больше возможностей, чем TextBox, поскольку может содержать форматированный текст
    // У RichTextBox и TextBox общий базовый класс (TextBoxBase), поэтому многие возможности, описанные выше для TextBox, применимы и к RichTextBox. Но некоторые средства TextBox реализованы в RichTextBox более полно. Там, где TextBox предоставляет лишь простые целочисленные свойства CaretIndex, SelectionStart и SelectionEnd, RichTextBox предлагает свойство CaretPosition типа TextPointer и свойство Selection типа TextSelection. Кроме того, содержимое RichTextBox хранится в свойстве Document типа FlowDocument, а не в простом строковом свойстве Text. Содержимое может даже включать объекты типа UIElement, с которыми можно взаимодействовать и которые генерируют события, если свойство IsDocumentEnabled элемента RichTextBox имеет значение true.
    
    // Элемент PasswordBox
    // Элемент PasswordBox – это упрощенный вариант TextBox, предназначенный для ввода пароля. Вместо вводимых символов в нем отображаются кружочки.
    // Если вам не нравятся кружочки, можете выбрать другой символ с помощью свойства PasswordChar.
    // Текст элемента PasswordBox хранится в строковом свойстве Password. В действительности для более надежной защиты применяется специальный класс System.Security.SecureString. Содержимое объекта типа SecureString шифруется и намеренно стирается, тогда как объекты System.String не шифруются и могут оставаться в куче неопределенно долгое время, пока не будут убраны сборщиком мусора.
    // При изменении пароля генерируется событие TextboxPasswordChanged. Его обработчик имеет тип RoutedEventHandler, то есть вместе с событием не передается информация о старом и новом паролях. Если нужно узнать текущий пароль, можно просто опросить внутри обработчика свойство Password. 

    // Элемент InkCanvas
    // Основная задача поразительно гибкого элемента InkCanvas – предоставить средства для рукописного ввода
    // В режиме по умолчанию InkCanvas позволяет просто писать или рисовать на своей поверхности. При работе со стилусом заостренный конец рисует, а обратный конец стирает. Каждый нанесенный штрих запоминается в виде объекта System.Windows.Ink.Stroke, а все такие объекты сохраняются в коллекции Strokes. Но InkCanvas позволяет также хранить любое число произвольных объектов типа UIElement в коллекции Children (это его свойство содержимого).
    // Здесь я воспользовался очень интересным свойством SizeToContent – если в этом режиме вы начнете рисовать за пределами окна, то объект Window автоматически изменит размер так, чтобы поместились все штрихи! 
    // Элемент InkCanvas поддерживает несколько режимов, которые можно независимо применять к заостренному концу стилуса (или к мыши) – посредством свойства EditingMode – и к обратному его концу – с помощью свойства EditingModeInverted. Предназначенное только для чтения свойство ActiveEditingMode сообщает, какой режим действует в данный момент. Все три эти свойства имеют тип перечисления InkCanvasEditingMode, в котором определены следующие значения:
    // - Ink – рисование штрихов мышью или стилусом. Это подразумеваемое по умолчанию значение свойства EditingMode.
    // - InkAndGesture – аналогично Ink, но распознает также жесты пользователя. Список поддерживаемых жестов (Up, Down, Circle, ScratchOut, Tap и др.) определен в перечислении System.Windows.Ink.ApplicationGesture. 
    // - GestureOnly – только распознает жесты, никакие штрихи не рисуются.
    // - EraseByStroke – стирает весь штрих, которого коснулся стилус. Это подразумеваемое по умолчанию значение свойства EditingModeInverted.
    // - EraseByPoint – стирает только часть штриха, находящуюся непосредственно под стилусом (как обычный ластик).
    // - Select – выделяет штрихи или другие элементы UIElement при касании, так чтобы впоследствии сразу ко всем можно было применить операцию удаления, перемещения или изменения размеров в границах InkCanvas.
    // - None – никак не реагирует на попытки ввода данных мышью или стилусом.
    
    // Документы
    // В WPF имеется обширный набор классов для создания, просмотра, модификации, организации и хранения высококачественных документов. В настоящем разделе мы будем говорить о так называемых потоковых документах. Такой документ (представленный объектом типа FlowDocument) содержит текст и другие данные, которые требуется расположить так, чтобы оптимально использовалось отведенное под документ место. Например, на мониторахс широким экраном можно автоматически добавлять дополнительные колонки.

    // Создание потоковых документов
    // Класс FlowDocument наследует классу FrameworkContentElement, аналогу FrameworkElement, ориентированному на работу с содержимым. Все элементы типа FrameworkContentElement, как и элементы типа FrameworkElement, поддерживают привязку к данным, анимацию и другие механизмы WPF, но не участвуют в механизме компоновки. При отображении на экране элементы FrameworkContentElement располагаются внутри какого-то элемента FrameworkElement.
    // Как поддержка потоковых документов в WPF соотносится со спецификацией XML Paper Specification (XPS)?
    // В отличие от документов с динамической компоновкой, описываемых в этом разделе, XPS-документы имеют фиксированную компоновку и одинаково выглядят как на экране, так и на бумаге. 
    
    // Простой потоковый документ
    // Есть два основных типа элементов TextElement – Block и Inline (оба класса являются абстрактными, производными от TextElement). Block занимает прямоугольную область, которая может разрываться только при переходе на другую страницу, а Inline – заполняемую текстом область, которая, в принципе, может оказаться и непрямоугольной (перетекать из конца одной строки в начало следующей). Элемент FlowDocument может содержать только блоки Block в качестве дочерних элементов.(Его свойство содержимого называется Blocks и имеет тип BlocksCollection.)
    
    // Класс Block
    // В WPF есть пять типов блоков:
    // - Paragraph – содержит коллекцию Inlines, которая обычно и составляет содержание документа. В XAML содержимым элемента Paragraph часто бывает простой текст, но внутри система обертывает этот текст объектом класса Run, производного от Inline, который и добавляется в коллекцию Inlines – так же, как в случае TextBlock.
    // - Section – группирует один или несколько блоков, не вводя никакой дополнительной структуры. Это удобно, когда нужно применить к нескольким блокам одно и то же значение некоторого свойства, например Background или Foreground.
    // - List – представляет коллекцию объектов типа ListItem в виде маркированного, нумерованного или простого списка. Каждый ListItem может содержать коллекцию блоков Block, так что создание типичного списка List подразумевает помещение объекта Paragraph внутрь каждого ListItem. Свойство MarkerStyle (типа TextMarkerStyle) позволяет задать различные стили форматирования маркеров – Box, Circle, Disc (подразумевается по умолчанию) и Square – и номеров – Decimal, LowerLatin, UpperLatin, LowerRoman и UpperRoman. Чтобы получить простой список, нужно присвоить свойству MarkerStyle значение None.
    // - Table – располагает содержимое в виде таблицы из строк и столбцов, наподобие Grid, но все же ближе к HTML-таблице. Элементы Table, в отличие от Grid, могут содержать только блоки Block (и элементы, описывающие структуру таблицы). 
    // - BlockUIContainer – содержит единственный элемент UIElement. Поэтому BlockUIContainer – ключ к размещению разнообразного WPF-содержимого внутри FlowDocument: изображений Image, видео, содержащегося внутри MediaElement, кнопок Button, трехмерной графики внутри элемента Viewport3D и т. д.

    // Класс Inline
    // Элементы Inline могут находиться внутри Paragraph, позволяя добавлять к тексту эффектное форматирование.
    // <Paragraph>Here are some highlights of WPF:</Paragraph>
    // эквивалентен такому коду на C#:
    // Paragraph p = new Paragraph(new Run("Here are some highlights of WPF:"));
    // Остальные встраиваемые в абзацы элементы Inline можно разбить на три категории: отрезки (span), заякоренные блоки и все остальное.
    // Отрезки. Наиболее распространенными отрезками являются элементы Bold, Italic, Underline и уже знакомый Hyperlink.
    // отрезки позволяют применять нужный эффект к более мелким участкам текста, чем целый абзац.
    // СОВЕТ
    // Так как TextBlock хранит свое содержимое в виде коллекции Inline, то можно было бы заменить теги Paragraph в показанной выше разметке фрагментами с тегами TextBlock, и все работало бы по-прежнему. С другой стороны, элемент Label такую разметку не поддерживает. 
    // Заякоренные блоки. WPF содержит два подкласса Inline, необычных тем, что они используются как контейнеры для элементов Block. Это классы Figure и Floater – оба наследующие абстрактному классу AnchoredBlock.
    // Элемент Floater – упрощенный вариант Figure.
    // Прочие элементы Inline. Два оставшихся элемента Inline не имеют ничего общего за исключением того факта, что они не наследуют ни одному из классов Span или AnchoredBlock. Один из них – LineBreak, который играет роль символа новой строки. Если поместить пустой элемент LineBreak между двумя символами в абзаце, то второй из них окажется в начале новой строки. 
    // СОВЕТ
    // Чтобы вставить в FlowDocument разрыв не строки, а страницы, задайте свойство BreakPageBefore для того элемента Paragraph, перед которым нужно перейти на новую страницу. Свойство BreakPageBefore определено в классе Block, так что применимо также к Section, List, BlockUIContainer и Table. 
    // И последний класс, производный от Inline, – это InlineUIContainer, который отличается от BlockUIContainer лишь тем, что может быть вложен внутрь Paragraph и будет размещаться в одном потоке с остальным текстом. чаще всего его применяют для того, чтобы включить в поток небольшое изображение.
    
    // Отображение потоковых документов
    // Выше уже упоминалось, что элемент FlowDocument можно отображать (и редактировать) внутри RichTextBox. Хотя редактирование можно запретить, установив для элемента RichTextBox свойство IsReadOnly равным true, RichTextBox не задумывался как основной элемент для чтения документов.
    // Вместо этого WPF предлагает три дополнительных элемента для отображения потоковых документов. Поначалу разобраться в них, возможно, и нелегко, но различия достаточно понятны:
    // - FlowDocumentScrollViewer – отображает документ как один непрерывный файл с полосой прокрутки, как в режиме веб-документа в Microsoft Word (аналогично доступному только для чтения RichTextBox, помещенному в ScrollViewer). 
    // - FlowDocumentPageViewer – отображает документ в виде набора отдельных страниц, как в режиме полноэкранного чтения в Microsoft Word.
    // - FlowDocumentReader – объединяет FlowDocumentScrollViewer и FlowDocumentPageViewer в один элемент управления и предлагает дополнительную функциональность, в частности встроенный текстовый поиск. (Такой элемент управления вы получаете по умолчанию, если сделаете FlowDocument корневым элементом XAML-файла.)
    // - Отметим, что FlowDocumentScrollViewer не содержит инструментов для управления масштабом, как остальные два элемента, но их можно добавить, присвоив свойству IsToolBarVisible значение true. 

    // Добавление комментариев
    // Конструировать свой интерфейс для ввода комментариев утомительно, но не слишком трудно. На помощь приходит класс AnnotationService в пространстве имен System.Windows.Annotations, в котором имеются команды для всех нужных функций 
    // - CreateTextStickyNoteCommand присоединяет новый текстовый элемент StickyNoteControl в качестве комментария к выделенному тексту.
    // - CreateInkStickyNoteCommand присоединяет новый рукописный элемент StickyNoteControl в качестве комментария к выделенному тексту.
    // - DeleteStickyNotesCommand удаляет выделенные в данный момент элементы StickyNoteControl.
    // - CreateHighlightCommand подсвечивает выделенный текст цветом, переданным команде в качестве параметра.
    // - ClearHighlightsCommand удаляет подсветку с выделенного в данный момент текста.
    // СОВЕТ
    // Элементы StickyNoteControl, которыми представлены комментарии, – это полноценные элементы управления WPF (находятся в пространстве имен System.Windows.Controls). Поэтому их внешний облик можно полностью изменить, задав другой шаблон. 

    // Диапазонные элементы управления
    // Диапазонный элемент просто хранит и отображает числовое значение, принадлежащее определенному диапазону.
    // Большую часть своей функциональности диапазонные элементы наследуют от абстрактного класса RangeBase. В нем определены свойства типа double, в которых хранятся текущее значение и границы диапазона: Value, Minimum, Maximum. Там же определено событие ValueChanged.

    // Элемент ProgressBar
    // По умолчанию свойство Minimum элемента ProgressBar равно 0, а свойство Maximum – 100. Он добавляет к своему базовому классу RangeBase еще два свойства:
    // - IsIndeterminate – если оно равно true, то в ProgressBar показывается обобщенная анимация, при этом значения свойств Minimum, Maximum и Value не учитываются. Это удобно, когда вы не знаете заранее, сколько времени займет операция, или ленитесь написать код, необходимый для показа реального положения вещей!
    // - Orientation – по умолчанию равно Horizontal, но может быть сделано равным Vertical, тогда индикатор будет двигаться сверху вниз, а не слева направо. Мне не доводилось встречать приложения, в которых индикаторы выполнения имеют вид «термометра », если не считать старомодных полноэкранных установщиков. Но если очень хочется, это свойство позволяет добиться такого эффекта!
    // Как с помощью ProgressBar показать, что операция приостановлена или остановлена из-за ошибки?
    // К сожалению, в элементе WPF ProgressBar такая возможность не реализована. Если вы хотите получить подобный эффект, то должны будете создать новые шаблоны для этих состояний 

    // Элемент Slider
    // Элемент Slider (ползунок) несколько сложнее, чем ProgressBar, так как позволяет изменять текущее значение, перемещая ползунок на любое число необязательных делений.
    // По умолчанию значение Minimum для него равно 0, а значение Maximum – 10. Кроме того, в классе Slider определено свойство Orientation (по умолчанию равное Horizontal), а также ряд свойств для задания положения и частоты делений, положения и точности всплывающих подсказок ToolTip, которые показывают текущее значение по мере перемещения ползунка, и признак, говорящий о том, должен ли ползунок точно совмещаться с дискретными делениями или может перемещаться плавно. Для работы с клавиатурой в классе Slider имеются также свойства Delay и Interval, которые по своему поведению очень похожи на одноименные свойства элемента RepeatButton. 
    // Чтобы появились деления, необходимо присвоить свойству TickPlacement значение TopLeft, BottomRight или Both. Странные названия объясняются желанием учесть обе ориентации Slider. Когда TickPlacement равно BottomRight, деления располагаются под ползунком, если он ориентирован горизонтально, и справа от него – если вертикально. Аналогично, когда TickPlacement равно TopLeft, деления располагаются над ползунком, если он ориентирован горизонтально, и слева от него – если вертикально.
    // У элемента Slider есть одна интересная особенность – он умеет отображать меньший диапазон внутри текущего
    // Если свойство IsSelectionRangeEnabled равно true, то свойствам SelectionStart и SelectionEnd можно присвоить значения границ такого «поддиапазона». Эта возможность позволяет сделать ползунок похожим на тот, что используется в Windows Media Player, где закрашенная область показывает, какая часть воспроизводимого файла уже загружена.
    
    // Календарные элементы управления
    // В WPF 4 появилось два новых календарных элемента управления, позволяющих очень наглядно выбирать и отображать даты: Calendar и DatePicker.

    // Элемент Calendar
    // Свойство DisplayDate элемента Calendar (типа DateTime) по умолчанию инициализируется текущей датой. Чтобы отключить подсветку, присвойте свойству IsTodayHighlighted значение false.
    // В зависимости от свойства SelectionMode в календаре можно выделять одну или несколько дат:
    // - SingleDate – в любой момент времени может быть выделена только одна дата, которая хранится в свойстве SelectedDate. Это режим по умолчанию.
    // - SingleRange – можно выделять несколько дат, но они должны образовывать один непрерывный диапазон. Выделенные даты хранятся в свойстве SelectedDates.
    // - MultipleRange – выделенные даты не обязаны быть соседними, они хранятся в свойстве SelectedDates. 
    // - None – выделять даты вообще нельзя.
    // Можно вместо этого указать диапазоны, в которых запрещено выделять даты, хотя они и отображаются. Для этого служит свойство BlackoutDates, содержащее коллекцию объектов типа CalendarDateRange.
    // СОВЕТ
    // Типом свойства BlackoutDates является класс CalendarBlackoutDatesCollection, производный от ObservableCollection<CalendarDateRange>. В нем есть один особенно полезный метод – AddDatesInPast. Обратившись к нему, можно запретить все даты раньше текущей. Но поскольку вызвать его можно только в процедурном коде, иногда проще явно указать элемент CalendarDateRange, задав в нем DateTime.MinValue (1 января 0001 года) в качестве значения Start и DateTime.Today минус один день – в качестве значения End.
    // Свойство FirstDayOfWeek класса Calendar предназначено для культур, в которых первым днем недели считается воскресенье.
    // В классе Calendar имеются также события, отражающие все существенные изменения: DisplayDateChanged, DisplayModeChanged, SelectionModeChanged и SelectedDatesChanged.

    // Элемент DatePicker
    // Еще один календарный элемент – DatePicker – по существу, представляет собой поле TextBox для отображения и ввода даты, с которым ассоциирован всплывающий элемент Calendar, позволяющий изменять дату визуально.
    // DatePicker обладает теми же свойствами и событиями, что и Calendar, за исключением свойств DisplayMode, SelectionMode и соответствующих им событий изменения. Для всплывающего календаря всегда установлены режимы DisplayMode=Month и SelectionMode=SingleDate. Поскольку выделить можно только одну дату, то вместо события SelectedDatesChanged в классе DatePicker определено событие SelectedDateChanged.
    // Булевское свойство IsDropDownOpen позволяет открывать и закрывать всплывающий календарь из программы, а также опрашивать его текущее состояние. События CalendarOpened и CalendarClosed генерируются, когда календарь соответственно открывается или закрывается. Свойство SelectedDateFormat определяет формат строки, помещаемой в TextBox после выбора даты в календаре. По умолчанию оно равно Short, что соответствует формату 4/20/2012. Можно задать значение Long, что даст представление в виде Friday, April 20, 2012. Строку, отображаемую в поле TextBox, можно установить или получить с помощью свойства Text.


    // !!!
}
