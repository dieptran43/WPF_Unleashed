using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._1_Basic_Information._2_XAML
{
    /// <summary>
    /// Interaction logic for XAML.xaml
    /// </summary>
    public partial class XAML : Window
    {
        public XAML()
        {
            InitializeComponent();
        }

        // - Язык XAML может стать очень компактным средством описания пользовательского интерфейса и других иерархий объектов.
        // - XAML позволяет легко отделить внешний вид приложения от его внутренней логики, что сильно упрощает последующее сопровождение, даже если команда разработчиков состоит всего из одного человека.
        // - Код на XAML легко скопировать в различные средства разработки, например Visual Studio, Expression Blend или какую-нибудь небольшую автономную программу, и сразу увидеть результат без какой либо компиляции.
        // - Именно код XAML генерируют практически все средства разработки, связанные с WPF.

        // Существует несколько способов выполнить написанные на XAML примеры
        // - Сохраните текст примера в файле с расширением .xaml и откройте его в Internet Explorer (для Windows Vista или более поздней либо для Windows XP с установленным каркасом .NET 3.0 или более поздней версией). Можно также использовать Firefox, если установлено соответствующее дополнение. Но по умолчанию браузер будет использовать версию WPF, установленную вместе с операционной системой, а не WPF 4. 
        // - Скопируйте текст примера в какую-нибудь простую инструментальную программу, например XAMLPAD2009, предлагаемую вместе с исходным кодом к этой главе, или Kaxaml (http://kaxaml.com), хотя на момент написания книги последняя еще не была модернизирована для работы с WPF 4.
        // - Создайте WPF-проект в Visual Studio и замените содержимое главного окна Window или элемента Page текстом примера; иногда может понадобиться внести в код некоторые изменения.


        // Определение XAML
        // XAML – сравнительно простой декларативный язык программирования общего назначения, предназначенный для конструирования  инициализации объектов.
        // можно говорить о WPF XAML, о Silverlight XAML и о других типах XAML-файлов.
        // Функциональность XAML, недоступная из процедурного кода:
        // - Создание полного набора шаблонов. В процедурном коде можно создавать шаблоны с помощью класса FrameworkElementFactory, но выразительные возможности этого подхода ограничены.
        // - Использование конструкции x:Shared="False", заставляющей WPF возвращать новый экземпляр при каждом обращении к элементу из словаря ресурсов.
        // - Отложенное создание объектов внутри словаря ресурсов. Это важно для оптимизации производительности и доступно только с помощьюскомпилированного XAML-кода. 

        // Элементы и атрибуты
        // В спецификации XAML определены правила отображения пространств имен, типов, свойств и событий .NET на пространства имен, элементы и атрибуты XML.
        // XAML:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK"/>
        // C#:
        // System.Windows.Controls.Button b = new System.Windows.Controls.Button();
        // b.Content = "OK";
    
        // Изменим код создания кнопки, задав не только свойство Content, но и обработчик события Click.
        // XAML:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK" Click="button_Click"/>
        // C#:
        // System.Windows.Controls.Button b = new System.Windows.Controls.Button();
        // b.Click += new System.Windows.RoutedEventHandler(button_Click);
        // b.Content = "OK";

        // Порядок обработки свойств и событий
        // Во время выполнения обработчики событий присоединяются до установки свойств объектов, объявленных в XAML-коде (за исключением описанного ниже свойства Name, которое устанавливается сразу после конструирования объекта). Поэтому при генерации событий в ответ на установку свойств можно не думать о порядке записи атрибутов в XAML.
        // Установка нескольких свойств и присоединение нескольких обработчиков событий обычно производятся в порядке задания атрибутов свойств и событий в объектном элементе. К счастью, на практике этот порядок не важен, поскольку согласно принципам проектирования в .NET порядок установки свойств объекта класса не должен иметь значения, и то же самое относится к порядку присоединения обработчиков событий.

        // Пространства имен
        // Наименее очевидный аспект при сравнении XAML-кода с эквивалентным кодом на С# – отображение пространства имен XML http://schemas.microsoft.com/ winfx/2006/xaml/presentation на пространство имен .NET System.Windows. Controls. В действительности отображение на это и другие пространства имен WPF жестко зашито в сборках WPF, точнее в нескольких экземплярах атрибута XmlnsDefinitionAttribute.
        // Так, в XAML-файлах для WPF обычно указывается второе пространство имен с префиксом x (записывается в виде xmlns:x, а не просто xmlns): xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        // Это пространство имен языка XAML, которое отображается на типы в пространстве имен System.Windows.Markup;

        // Неявные пространства имен .NET
        // Чтобы код было проще читать, лучше объявлять наиболее часто используемое пространство имен XML (называемое также основным) без префикса, для всех дополнительных пространств имен выбирать короткие префиксы. 

        // В процессе развития образовалось несколько пространств имен WPF XML


        // Элементы свойств
        // XAML предлагает альтернативный (менее компактный) синтаксис для установки составных свойств – элементы свойств. Выглядит это следующим образом:
        // Теперь свойство Content устанавливается с помощью XML-элемента, а не XML- атрибута, а результат эквивалентен коду на С#. Точка в выражении Button. Content позволяет отличить элемент свойства от объектного элемента.
        // Элементы свойств всегда имеют вид ИмяТипа. ИмяСвойства и обязательно вложены в объектный элемент вида ИмяТипа.
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK" Background="White"/>
        // эквивалентно
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // OK
        // </Button.Content>
        // <Button.Background>
        // White
        // </Button.Background>
        // </Button>

        // Конвертеры типов
        // В таких случаях компилятор или анализатор XAML должен найти конвертер типа, который умеет преобразовывать строковое значение в нужный тип.
        // Использование конвертеров типов в процедурном коде
        // Поиск конвертеров типов
        // при установке свойства Background кнопки Button в XAML-коде применяется конвертер типа BrushConverter, поскольку свойство Background имеет тип System.Windows. Media.Brush, в определении которого задан следующий атрибут:
        //[TypeConverter(typeof(BrushConverter)), ...]
        //public abstract class Brush : ...
        //{
        //...
        //}
        // для установки свойства FontSize кнопки используется конвертер типа FontSizeConverter, потому что это свойство (определенное в базовом классе Control) снабжено следующим атрибутом:
        // [TypeConverter(typeof(FontSizeConverter)), ...]
        // public double FontSize
        // {
        // get { ... }
        // set { ... }
        // }

        // Расширения разметки
        // Если значение атрибута заключено в фигурные  скобки {}, то компилятор или анализатор XAML считает  его значение расширением разметки, а не обычной строкой (или чем-то, нуждающимся в конвертере типов)
        //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //Background="{x:Null}"
        //Height="{x:Static SystemParameters.IconHeight}"
        //Content="{Binding Path=Height, RelativeSource={RelativeSource Self}}"/>
        // Первый идентификатор в каждом заключенном в фигурные скобки значении – имя класса расширения разметки, который должен наследовать классу MarkupExtension.
        // По принятому соглашению имена таких классов оканчиваются словом Extension, но в XAML его можно опускать. В данном примере NullExtension (записано в виде x:Null) и StaticExtension (записано в виде x:Static) – классы из пространства имен System.Windows. Markup, поэтому для их поиска необходимо указывать префикс x.
        // синтаксис и использование расширений разметки в XAML очень напоминает способ определения атрибутов.

        // Экранирование фигурных скобок
        // Если строковое значение атрибута свойства начинается открывающей фигурной скобкой, то ее следует экранировать, чтобы анализатор не счел ее началом расширения разметки. Это можно сделать, поставив перед ней пустую пару фигурных скобок, как в следующем примере:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="{}{Это не расширение разметки!}"/>
        // В качестве альтернативы можно использовать синтаксис элемента свойства, поскольку в этом контексте фигурные скобки не имеют специального смысла.
        //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //<Button.Content>
        //{Это не расширение
        //разметки!}
        //</Button.Content>
        //</Button>
        // Расширения разметки и процедурный код


        // Дочерние объектные элементы
        // Объектные элементы могут поддерживать наличие дочерних объектных элементов (а не только элементов свойств, которые с точки зрения XAML не являются дочерними). Объектный элемент может иметь потомков трех разных типов: значение свойства содержимого, элементы коллекции или значение, тип которого может быть преобразован в тип объектного элемента.
        
        // Свойство Content
        // В большинстве классов WPF имеется свойство (задаваемое с помощью атрибута), значением которого является содержимое данного XML-элемента. Оно называется свойством содержимого и в действительности представляет собой просто удобный способ сделать XAML-представление более компактным.
        // Для свойства Content кнопки Button имеется специальное соглашение (что очень кстати), поэтому описание
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
        // Content="OK"/>
        // можно представить в следующем виде:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // OK
        // </Button>
        // А составное содержимое Button, например
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // <Rectangle Height="40" Width="40" Fill="Black"/>
        // </Button.Content>
        // </Button>
        // можно переписать так:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Rectangle Height="40" Width="40" Fill="Black"/>
        // </Button>
        // Нигде не требуется, чтобы свойство содержимого называлось именно Content; так, в классах ComboBox, ListBox и TabControl (все из пространства имен System. Windows. Controls) свойство содержимого названо Items. 

        // Элементы коллекций
        // Язык XAML позволяет добавлять элементы в два основных вида коллекций, поддерживающих индексирование: списки и словари.
        // Списки
        // Списком считается любая коллекция, в которой реализован интерфейс System.Collections.IList, например System.Collections.ArrayList и многочисленные классы коллекций, определенные в WPF
        // <ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <ListBox.Items>
        // <ListBoxItem Content="Item 1"/>
        // <ListBoxItem Content="Item 2"/>
        // </ListBox.Items>
        // </ListBox>
        // Далее, поскольку Items – свойство содержимого для ListBox, то XAML-код можно еще сократить:
        //<ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //<ListBoxItem Content="Item 1"/>
        //<ListBoxItem Content="Item 2"/>
        //</ListBox>
        
        // Словари
        // Коллекция System.Windows.ResourceDictionary используется в WPF очень часто, в чем мы убедимся в главе 12 «Ресурсы ». Этот класс реализует интерфейс System.Collections.IDictionary, а значит, поддерживает добавление, удаление и перечисление пар ключ/значение в процедурном коде, как любая хеш-таблица.
        // В XAML в любую коллекцию, реализующую интерфейс IDictionary, можно добавить пару ключ/значение.
        // <ResourceDictionary
        // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        // <Color x:Key="1" A="255" R="255" G="255" B="255"/>
        // <Color x:Key="2" A="0" R="0" G="0" B="0"/>
        // </ResourceDictionary>
        // Списки, словари и анализатор XAML2009

        // Еще о преобразовании типов
        // Потомком объектного элемента может быть обычный текст, как в следующем объявлении элемента SolidColorBrush на XAML:
        // <SolidColorBrush>White</SolidColorBrush>
        // Эта запись эквивалентна следующей:
        // <SolidColorBrush Color="White"/>
        // даже несмотря на то, что Color не описано как свойство содержимого.
        // В данном случае первый фрагмент работает потому, что существует конвертер типа, умеющий преобразовывать такие строки, как "White" (или "white", или "#FFFFFF") в объект типа SolidColorBrush.


        //!!!
        // - Атрибут .net
        // - Расширение разметки
        // - Повторить основные элеметы XAML
        // - Пересмотреть еще раз главу, разобрать основы XAML
        // - Попробовать все примеры с главы, c# <-> XAML соответствия
        // - найти книгу с которой можно копипастить без редактирования
    }
}
