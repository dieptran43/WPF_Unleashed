using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using System.IO;
using System.Windows.Markup;

namespace WPF_Unleashed._1_Basic_Information._2_XAML
{
    /// <summary>
    /// Interaction logic for XAML.xaml
    /// </summary>
    public partial class XAML : Window
    {
        public XAML()
        {
            InitializeComponent();

            System.Windows.Controls.Button b = new System.Windows.Controls.Button();
            b.Content = "Cancel";

            System.Windows.Controls.Button b1 = new System.Windows.Controls.Button();
            b1.Click += new System.Windows.RoutedEventHandler(button_Click);
            b1.Content = "OK";

            // WPF XML: xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" <-> System.Windows.Controls, и не только, все пространства имен соответствующие wpf
            // XAML: xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" <-> System.Windows.Markup
            // пространство имен winfx/2006 на самом деле означает «версия  3.0 или более поздняя », пространство имен netfx/2007 – «версия 3.5 или более поздняя » и т. д.

            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"> объектный элемент 
            //    <Button.Content> "." позволяет отличить элемент свойства от объектного элемента.
            //        <Rectangle Height="40" Width="40" Fill="Black"/>
            //    </Button.Content>
            //</Button>

            // Элементы свойств всегда имеют вид ИмяТипа. ИмяСвойства и обязательно вложены в объектный элемент вида ИмяТипа.
            // У элементов свойств не может быть собственных атрибутов (за одним исключением – атрибут x:Uid используется для локализации).
            
            // В следующем примере для Button с помощью атрибутов устанавливаются два свойства (Content и Background).

            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //    Content="OK" Background="White"/>

            // То же самое можно записать иначе, задав упомянутые свойства с помощью элементов:

            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //<Button.Content>
            //OK
            //</Button.Content>
            //<Button.Background>
            //White
            //</Button.Background>
            //</Button>

            // лучше использовать форму с атрибутами – это короче

            // Например, при установке свойства Background кнопки Button в XAML-коде применяется конвертер типа BrushConverter, поскольку свойство Background имеет тип System.Windows.Media.Brush, в определении которого задан следующий атрибут:
            //[TypeConverter(typeof(BrushConverter)), ...]
            //public abstract class Brush : ...
            //{
            //...
            //}

            // Если значение атрибута заключено в фигурные скобки {}, то компилятор или анализатор XAML считает его значение расширением разметки, а не обычной строкой.
            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            //    Background="{x:Null}" // класс расширения разметки
            //    Height="{x:Static SystemParameters.IconHeight}" // класс расширения разметки позиционный параметр
            //    Content="{Binding Path=Height, RelativeSource={RelativeSource Self}}"/>
            // Path, RelativeSource - именованые параметры.
            // Первый идентификатор в каждом заключенном в фигурные скобки значении – имя класса расширения разметки, который должен наследовать классу MarkupExtension.
            // По принятому соглашению имена таких классов оканчиваются словом Extension, но в XAML его можно опускать.
            // В данном примере NullExtension (записано в виде x:Null) и StaticExtension (записано в виде x:Static) – классы из пространства имен System.Windows.Markup, поэтому для их поиска необходимо указывать префикс x.
            // Но класс Binding (имя которого не оканчивается словом Extension) находится в пространстве имен System.Windows.Data, поэтому его следует искать в пространстве имен XML, подразумеваемом по умолчанию.
            // Если расширение разметки поддерживает такой синтаксис, ему можно передавать параметры, разделенные запятой. Позиционные параметры (например, SystemParameters.IconHeight) рассматриваются как строковые аргументы для соответствующего конструктора класса расширения. 
            // Именованные параметры (в данном примере Path и RelativeSource) позволяют устанавливать в конструируемом объекте расширения разметки свойства с соответствующими именами.
            // Если вы знакомы с атрибутами .NET (это популярный механизм расширения каркаса), то, возможно, заметили что синтаксис и использование расширений разметки в XAML очень напоминает способ определения атрибутов.

            // В предыдущем объявлении элемента Button расширение NullExtension позволяет в качестве кисти Background (свойство Background) задавать null, хотя конвертер типа BrushConverter (и, кстати, многие другие конвертеры) такую возможность не поддерживает.
            // Расширение StaticExtension позволяет использовать в XAML статические свойства, поля, константы и элементы перечисления вместо явного прописывания литералов.
            // Расширение Binding подробно рассматривается в главе 13 «Привязка к данным ». Оно позволяет присвоить свойству Content значение, равное значению свойства Height.

            // Экранирование фигурных скобок
            // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //    Content="{}{Это не расширение разметки!}"/>

            // В качестве альтернативы можно использовать синтаксис элемента свойства, поскольку в этом контексте фигурные скобки не имеют специального смысла. Предыдущий пример может быть переписан в следующем виде:
            
            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //<Button.Content>
            //    {Это не расширение разметки!}
            //</Button.Content>
            //</Button>

            // Поскольку расширения разметки – это просто классы с конструкторами по умолчанию, то их можно использовать в элементах свойств.

            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
            //<Button.Background>
            //<x:Null/>
            //</Button.Background>
            //<Button.Height>
            //<x:Static Member="SystemParameters.IconHeight"/>
            //</Button.Height>
            //<Button.Content>
            //<Binding Path="Height">
            //<Binding.RelativeSource>
            //<RelativeSource Mode="Self"/>
            //</Binding.RelativeSource>
            //</Binding>
            //</Button.Content>
            //</Button>

            // Расширения разметки и процедурный код
            // компилятор или анализатор XAML, который предполагает, что любое расширение разметки устанавливает нужные значение во время выполнения (вызывая метод ProvideValue).

            // Дочерние объектные элементы
            // Объектный элемент может иметь потомков трех разных типов: значение свойства содержимого, элементы коллекции или значение, тип которого может быть преобразован в тип объектного элемента.
            // Свойство Content
            // свойство содержимого
            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //    Content="OK"/>
            // эквивалентно
            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //    OK
            //</Button>

            // а составное содержимое:
            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //<Button.Content>
            //    <Rectangle Height="40" Width="40" Fill="Black"/>
            //</Button.Content>
            //</Button>
            // эквивалентно:
            //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //    <Rectangle Height="40" Width="40" Fill="Black"/>
            //</Button>
            // в классах ComboBox, ListBox и TabControl (все из пространства имен System.Windows.Controls) свойство содержимого названо Items.

            // Элементы коллекций:
            // списки 
            // Списком считается любая коллекция, в которой реализован интерфейс System.Collections.IList, например System.Collections.ArrayList и многочисленные классы коллекций, определенные в WPF.
            //<ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //    <ListBox.Items>
            //        <ListBoxItem Content="Item 1"/>
            //        <ListBoxItem Content="Item 2"/>
            //    </ListBox.Items>
            //</ListBox>

            System.Windows.Controls.ListBox listbox = new System.Windows.Controls.ListBox();
            System.Windows.Controls.ListBoxItem item1 = new System.Windows.Controls.ListBoxItem();
            System.Windows.Controls.ListBoxItem item2 = new System.Windows.Controls.ListBoxItem();
            item1.Content = "Item 1";
            item2.Content = "Item 2";
            listbox.Items.Add(item1);
            listbox.Items.Add(item2);

            //<ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //<ListBoxItem Content="Item 1"/>
            //<ListBoxItem Content="Item 2"/>
            //</ListBox>

            // словари
            // Коллекция System.Windows.ResourceDictionary используется в WPF очень часто. 
            // Этот класс реализует интерфейс System.Collections.IDictionary, а значит, поддерживает добавление, удаление и перечисление пар ключ/значение в процедурном коде, как любая хеш-таблица.

            System.Windows.ResourceDictionary d = new System.Windows.ResourceDictionary();
            System.Windows.Media.Color color1 = new System.Windows.Media.Color();
            System.Windows.Media.Color color2 = new System.Windows.Media.Color();
            color1.A = 255; color1.R = 255; color1.G = 255; color1.B = 255;
            color2.A = 0; color2.R = 0; color2.G = 0; color2.B = 0;
            d.Add("1", color1);
            d.Add("2", color2);

            //<ResourceDictionary
            //xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
            //<Color x:Key="1" A="255" R="255" G="255" B="255"/>
            //<Color x:Key="2" A="0" R="0" G="0" B="0"/>
            //</ResourceDictionary>

            // Преобразовния типов
            // Потомком объектного элемента может быть обычный текст, как в следующем объявлении элемента SolidColorBrush на XAML:
            // <SolidColorBrush>White</SolidColorBrush>
            // Эта запись эквивалентна следующей:
            // <SolidColorBrush Color="White"/>

            // Расширяемая часть XAML
            // Например, если в классе нет ни конструктора по умолчанию, ни полезных открытых свойств, то им нельзя будет напрямую воспользоваться в XAML
            // Сборки WPF помечены атрибутом XmlnsDefinitionAttribute, который отображает содержащиеся в них пространства имен .NET на пространство имен XML в XAML-файле.
            // System.Collections.Hashtable h = new System.Collections.Hashtable();
            // h.Add("key1", 7);
            // h.Add("key2", 23);
            // XAML:
            //<collections:Hashtable
            //xmlns:collections="clr-namespace:System.Collections;assembly=mscorlib"
            //xmlns:sys="clr-namespace:System;assembly=mscorlib"
            //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
            //<sys:Int32 x:Key="key1">7</sys:Int32>
            //<sys:Int32 x:Key="key2">23</sys:Int32>
            //</collections:Hashtable>
            
            // Директива clr-namespace позволяет использовать пространство имен .NET непосредственно в XAML.
            // Правила обработки потомков объектных элементов в XAML
            // 1. Если тип реализует интерфейс IList, вызвать IList.Add для каждого дочернего элемента.
            // 2. Иначе, если тип реализует интерфейс IDictionary, вызвать IDictionary.Add для каждого дочернего элемента, используя в качестве ключа значение атрибута x:Key, а в качестве значения – сам элемент. 
            // 3. Иначе, если у родителя есть свойство содержимого (помеченное атрибутом System.Windows.Markup.ContentPropertyAttribute) и тип дочернего элемента совместим с этим свойством, считать дочерний элемент значением этого свойства.
            // 4. Иначе, если дочерний элемент является простым текстом и существует конвертер типа, который может преобразовать этот текст в тип родителя (и при этом для родителя не установлены никакие свойства), подать дочерний элемент на вход конвертера типа, а полученный результат считать экземпляром родителя.
            // 5. Иначе считать содержимое неизвестным, что может являться поводом для возбуждения исключения.

            // Сочетание XAML и процедурного кода
            // В состав WPF входит анализатор XAML, работающий на этапе выполнения. Он представлен двумя классами в пространстве имен System.Windows.Markup: XamlReader и XamlWriter.
            // Класс XamlReader
            // Перегруженные варианты метода XamlReader.Load разбирают XAML-код, создают соответствующие объекты .NET и возвращают экземпляр, представляющий корневой элемент.

            if (false)
            {
                Window window = null;
                using (FileStream fs = new FileStream("C:\\Git\\WPF_Unleashed\\WPF_Unleashed\\1_Basic Information\\2_XAML\\XAML.xaml.", FileMode.Open, FileAccess.Read))
                {
                    // Получить корневой элемент. Мы знаем, что это Window
                    window = (Window)XamlReader.Load(fs);
                }
                StackPanel panel = (StackPanel)window.Content;
                Button okButton = (Button)panel.Children[4];
                // Однако метод LoadAsync ведет себя несколько странно. Он работает в потоке пользовательского интерфейса, многократно обращаясь к методу Dispatcher.BeginInvoke (WPF пытается разбить работу на отрезки продолжительностью 200 мс).К тому же обработка производится асинхронно, только если в корневом узле XAML установлен атрибут x:SynchronousMode="Async". В противном случае LoadSync загружает XAML в синхронном режиме, ничего не сообщая об этом.  

                // Именование элементов XAML
                // <Button x:Name="okButton">OK</Button>
                // Находим кнопку OK, зная только ее имя 
                Button okButton1 = (Button)window.FindName("okButton");
            }
            // Например, в классах FrameworkElement и FrameworkContentElement имеется свойство Name, поэтому они помечены атрибутом RuntimeNameProperty("Name"). Это означает, что для таких элементов можно просто задать свойство Name, не используя синтаксис x:Name. 

            // для ссылки на именованный  элемент можно использовать расширение разметки Binding в значении свойства:
            //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //<Label Target="{Binding ElementName=box}" Content="Enter _text:"/>
            //<TextBox Name="box"/>
            //</StackPanel>

            // новое, более простое расширение разметки System.Windows.Markup.Reference, которое позволяет искать элементы на этапе синтаксического разбора, а не выполнения.
            //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
            //<Label Target="{x:Reference box}" Content="Enter _text:"/>
            //<TextBox Name="box"/>
            //</StackPanel>

            // Кроме того, если свойство помечено конвертером типа System.Windows.Markup.NameReferenceConverter (как в данном случае), то строковое имя неявно преобразуется в экземпляр, на который ведет ссылка:
            //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
            //<Label Target="box" Content="Enter _text:"/>
            //<TextBox Name="box"/>
            //</StackPanel>
            
            // Компиляция XAML
            // Компиляция XAML включает три шага: преобразование XAML-файла в специальный двоичный формат, включение результата в создаваемую сборку в качестве двоичного ресурса и создание инфраструктуры, которая автоматически подключает XAML к процедурному коду. 
            // первым делом нужно задать подкласс для корневого элемента в XAML-файле. Это можно сделать с помощью ключевого слова Class, определенного в пространстве имен XAML. Например:
            //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            //x:Class="MyNamespace.MyWindow">
            //...
            //</Window>
            // x:Class="MyNamespace.MyWindow">
            // (code-behind file).
            // Ключевое слово partial в определении класса важно, поскольку реализация класса распределена по нескольким файлам.
            // Если не поддерживаються частичные классы - x:Subclass
            //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            //x:Class="MyNamespace.MyWindow" x:Subclass="MyNamespace.MyWindow2">
            //...
            //</Window>

            // BAML-файл (MyWindow.baml), который по умолчанию внедряется в сборку в качестве двоичного ресурса.
            // С#-файл (MyWindow.g.cs), который компилируется и включается в сборку, как любой другой файл с исходным кодом.

            // BAML
            // Генерируемый исходный код
            // XAML2009

            // Полная поддержка универсальных классов
            // Словарные ключи произвольного типа
            // Встроенные системные типы данных
            // Создание объектов с помощью конструктора с аргументами
            // В XAML2009 можно создать объект этого класса с помощью конструктора, принимающего в качестве параметра простую строку:
            // <sys:Version x:Arguments="4.0.30319.1"/>, строка XAML соответствует созданию обьекта.
            // вызов конструктора, который принимает 4 параметра:
            //<sys:Version>
            //<x:Arguments>
            //<x:Int32>4</x:Int32>
            //<x:Int32>0</x:Int32>
            //<x:Int32>30319</x:Int32>
            //<x:Int32>1</x:Int32>
            //</x:Arguments>
            //</sys:Version>

            // Создание экземпляров с помощью фабричных методов
            //<Label xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation
            //xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml
            //xmlns:sys="clr-namespace:System;assembly=mscorlib">
            //<sys:Guid x:FactoryMethod="sys:Guid.NewGuid"/>
            //</Label>

            // Гибкость присоединения обработчиков событий
            // <Button Click="{custom:DelegateFinder Click}"/>

            // Трюки с классами чтения и записи XAML
            // Новая сборка System.Xaml содержит абстрактные базовые классы System.Xaml.XamlReader и System.Xaml.XamlWriter
            // Считыватели (производныеот System.Xaml.XamlReader):
            // • System.Xaml.XamlXmlReader – читает XML-код (из System.Xml.XmlReader, System.IO.TextReader, System.IO.Stream или из файла, заданного своим именем в виде строки).
            // • System.Xaml.XamlObjectReader – читает существующий граф объектов. 
            // • System.Windows.Baml2006.Baml2006Reader – читает BAML-код (в WPF все еще используется формат 2006 года).
            // • System.Xaml.XamlBackgroundReader – обертывает другой объект XamlReader, реализуя двойную буферизацию, что позволяет считывателю работать не в том же потоке, что записыватель.
            // Записыватели (производные от System.Xaml.XamlWriter):
            // • System.Xaml.XamlXmlWriter – записывает XML (используя System.Xml.XmlWriter,System.IO.TextWriter или Stream).
            // • System.Xaml.XamlObjectWriter – создает граф объектов.

            //!!!
            // Разобрать более детально потом, если будет время и необходимость

            //!!!
            // - Атрибут .net +-, разобрать более детально. 
            AttributeTest();
            // - Расширение разметки +
            // - Повторить основные элеметы XAML +
            // - Пересмотреть еще раз главу, разобрать основы XAML +
            // - Попробовать все примеры с главы, c# <-> XAML соответствия +
            // - найти книгу с которой можно копипастить без редактирования ...
            // - FileStream + 
            // - using +
            UsingTest();
            // - partial class +
            PartialTest();
            // - Универсальный класс +-, разобрать более детально.
            UniversalTest();
            // - x:TypeArguments +
            // - XamlXmlReader
            // - XamlXmlWriter
            // Разобрать потом если будет время и необходимость...
            // - x:FactoryMethod +
        }

        public static void AttributeTest()
        {
            // Атрибуты обеспечивают эффективный способ связывания метаданных или декларативной информации с кодом (сборками, типами, методами, свойствами и т. д.). После того как атрибут будет связан с программной сущностью, он может быть запрошен во время выполнения с помощью техники, называемой рефлексией.
            // Атрибуты имеют следующие свойства:
            // - Атрибуты добавляют в программу метаданные. Метаданные представляют собой сведения о типах, определенных в программе.Все сборки .NET содержат заданный набор метаданных, описывающих типы и члены типов, определенных в сборке.Для задания необходимых дополнительных сведений можно добавить атрибуты
            // - Один или несколько атрибутов могут применяться к сборкам, модулям или более мелким программным элементам, таким как классы и свойства.
            // - Программа может проверить собственные метаданные или метаданные в других программах с помощью рефлексии.

            // Атрибуты могут быть размещены в большинстве объявлений, хотя определенный атрибут может ограничить типы объявлений, в которых он допустим.В C# атрибут задается путем размещения его имени, заключенного в квадратные скобки ([]), перед объявлением сущности, к которой он относится
            SampleClass myClass = new SampleClass();
            // Чтобы отличать атрибуты от других элементов платформы .NET Framework, используется соглашение, по которому все имена атрибутов заканчиваются словом "Attribute" ("атрибут").Однако нет необходимости указывать суффикс атрибута при его использовании в коде.Например, [DllImport] эквивалентен [DllImportAttribute], однако DllImportAttribute является фактическим именем атрибута в платформе .NET Framework.

            // Многие атрибуты имеют параметры, которые могут быть позиционными, неименованными или именованными.

            //[DllImport("user32.dll")]
            //[DllImport("user32.dll", SetLastError=false, ExactSpelling=false)]
            //[DllImport("user32.dll", ExactSpelling=false, SetLastError=false)]
            // Первый параметр — имя библиотеки DLL — является позиционным и всегда стоит на первом месте; остальные являются именованными.В этом случае оба именованных параметра по умолчанию имеют значение "false" и могут быть пропущены.

            // Целевым объектом атрибута является сущность, к которой относится атрибут.Например, атрибут может относиться к классу, отдельному методу или целой сборке.По умолчанию атрибут относится к тому элементу, перед которым он указан.Однако можно явным образом определить, к чему относится атрибут, — например, к методу, его параметру или возвращаемому значению.
            // [target : attribute-list]

            //Следующий список содержит несколько общих случаев использования атрибутов в коде:
            // - Пометка метода веб-службы с помощью атрибута WebMethod для указания на возможность вызова метода с помощью протокола SOAP.Дополнительные сведения см. в разделе WebMethodAttribute.
            // - Описание способов упаковки параметров методов при взаимодействии с машинным кодом.Дополнительные сведения см. в разделе MarshalAsAttribute.
            // - Описание свойств COM для классов, методов и интерфейсов.
            // - Вызов неуправляемого кода с помощью класса DllImportAttribute.
            // - Описание сборки с помощью заголовка, версии, описания или торгового знака.
            // - Указание того, какие члены класса должны быть сериализованы при сохранении.
            // - Описание порядка сопоставления членов класса и XML-узлов при XML-сериализации.
            // - Описание требований безопасности к методам.
            // - Указание характеристик, используемых для обеспечения безопасности.
            // - Управление оптимизацией с помощью JIT-компилятора для того, чтобы отладка кода оставалась простой.
            // - Получение сведений об объекте, вызывающем метод.

            // Атрибуты обеспечивают эффективный способ связывания метаданных или декларативной информации с кодом.
            // !!! more example
            // http://habrahabr.ru/post/140842/
        }

        public static void UsingTest()
        {
            // Предоставляет удобный синтаксис, обеспечивающий правильное использование объектов IDisposable.
            // Как правило, при использовании объекта IDisposable его следует объявить и создать в операторе using.Оператор using соответствующим образом вызывает метод Dispose в объекте и (если он используется как описано выше) приводит к выводу объекта из области действия сразу после вызова Dispose. В рамках блока using объект доступен только для чтения и не может быть изменен или переназначен.

            //using (Font font1 = new Font("Arial", 10.0f))
            //{
            //    byte charset = font1.GdiCharSet;
            //}

            // Оператор using гарантирует вызов метода Dispose, даже если при вызове методов в объекте происходит исключение.Такого же результата можно достичь при размещении объекта в блоке try и последующем вызове метода Dispose в блоке finally; фактически, это способ преобразования оператора using компилятором.

        }

        public static void PartialTest()
        {
            // Имеется возможность разделить определение класса или структуры, интерфейса или метода между двумя или более исходными файлами.Каждый исходный файл содержит определение типа или метода, и все части объединяются при компиляции приложения.

            // Существует несколько ситуаций, при которых желательно разделение определения класса:
            // - При работе над большими проектами распределение класса между различными файлами позволяет нескольким программистам работать с ним одновременно.
            // - При работе с использованием автоматически создаваемого источника код можно добавлять в класс без повторного создания файла источника.Система Visual Studio использует этот подход при создании форм Windows Forms, программы оболочки веб-службы и т.д.Можно создать программу, использующую эти классы, без необходимости изменения файла, созданного системой Visual Studio.
            // - Чтобы разделить определение класса, используйте модификатор ключевого слова partial, как показано ниже:
            Employee e = new Employee();
            e.DoWork();
            e.GoToLunch();
            // Если какая-либо из частей объявлена абстрактной, то весь тип будет считаться абстрактным.Если какая-либо из частей объявлена запечатанной, то весь тип будет считаться запечатанным.Если какая-либо из частей объявляет базовый тип, то весь тип будет наследовать данный класс.
            // Модификатор partial нельзя использовать для объявлений делегата или перечисления.

            // При компиляции атрибуты определений разделяемого типа объединяются.В качестве примера рассмотрим следующие объявления:

            // Следующие элементы объединяются изо всех определений разделяемого типа:
            // - XML-комментарии;
            // - интерфейсы;
            // - атрибуты параметров универсального типа;
            // - атрибуты классов;
            // - members

            // Ограничения:
            // - Все определения разделяемого типа, являющиеся частями одного и того же типа, должны изменяться с использованием модификатора partial
            // - Модификатор partial должен находиться непосредственно перед ключевыми словами class, struct или interface.
            // - В определениях разделяемого типа могут присутствовать вложенные разделяемые типы.
            // - Все определения разделяемого типа, являющиеся частями одного и того же типа, должны быть определены в одной сборке и в одном модуле (EXE-файл или DLL-файл).Разделяемые определения не могут находиться в разных модулях.
            // - Имя класса и параметры универсального типа должны соответствовать всем определениям разделяемого типа.Универсальные типы могут быть разделяемыми.Все объявления разделяемого типа должны использовать одинаковые имена параметров в одном и том же порядке.
            // - Приведенные ниже ключевые слова необязательно должны присутствовать в определении разделяемого типа, но если они присутствуют в одном определении разделяемого типа, то не должны конфликтовать с ключевыми словами, указанными в других определениях того же разделяемого типа:
            // public, private, protected, internal, abstract, sealed, базовый класс, модификатор new (вложенные части), универсальные ограничения

            // Разделяемые методы.
            // Разделяемый класс или структура могут содержать разделяемый метод.Одна часть класса содержит сигнатуру метода.В той же или в другой части можно определить дополнительную реализацию.Если реализация не предоставлена, то метод и все вызовы метода удаляются во время компиляции.
            // Как и разделяемые классы, разделяемые методы позволяют организовать совместную работу автоматически созданного кода и кода, созданного человеком, без дополнительных затрат во время выполнения.

            // - Объявления разделяемого метода должны начинаться с контекстно-зависимого ключевого слова partial, а метод должен возвращать значение типа void.
            // - Разделяемые методы могут иметь параметры ref, но не могут иметь параметры out.
            // - Разделяемые методы неявно имеют модификатор private и поэтому не могут иметь модификатор virtual.
            // - Разделяемые методы не могут иметь модификатор extern, поскольку наличие тела определяет, выполняется ли их определение или реализация.
            // - Разделяемые методы могут иметь модификаторы static и unsafe.
            // - Разделяемые типы могут быть универсальными.Ограничения помещаются в ту часть обяъвления разделяемого метода, где находится определение, и могут дополнительно повторяться в разделе реализации.Имена параметров и типов параметров необязательно должны совпадать в объявлении реализации и в объявлении определения.
            // - Можно использовать делегат в качестве определенного и реализованного разделяемого метода, но его нельзя использовать в качестве разделяемого метода, который только определен.
        }

        public static void UniversalTest()
        {
            // Универсальные классы инкапсулируют операции, не относящиеся к какому-либо определенному типу данных.Чаще всего универсальные классы используются с коллекциями, такими как связанные списки, хэш-таблицы, очереди, стеки, деревья и т.п.Такие операции как добавление элементов в коллекцию или их удаление осуществляются одинаково вне зависимости от типа хранящихся данных.
            // При создании собственных универсальных классов следует учитывать следующее:
            // - Какие типы преобразовывать в параметры.
            // - Какие ограничения применяются к параметрам типов
            // - Следует ли разделять поведение универсального класса на базовые классы и подклассы.
        }

        private void button_Click(object sender, RoutedEventArgs e)
        {
            
        }

        // - Язык XAML может стать очень компактным средством описания пользовательского интерфейса и других иерархий объектов.
        // - XAML позволяет легко отделить внешний вид приложения от его внутренней логики, что сильно упрощает последующее сопровождение, даже если команда разработчиков состоит всего из одного человека.
        // - Код на XAML легко скопировать в различные средства разработки, например Visual Studio, Expression Blend или какую-нибудь небольшую автономную программу, и сразу увидеть результат без какой либо компиляции.
        // - Именно код XAML генерируют практически все средства разработки, связанные с WPF.

        // Существует несколько способов выполнить написанные на XAML примеры
        // - Сохраните текст примера в файле с расширением .xaml и откройте его в Internet Explorer (для Windows Vista или более поздней либо для Windows XP с установленным каркасом .NET 3.0 или более поздней версией). Можно также использовать Firefox, если установлено соответствующее дополнение. Но по умолчанию браузер будет использовать версию WPF, установленную вместе с операционной системой, а не WPF 4. 
        // - Скопируйте текст примера в какую-нибудь простую инструментальную программу, например XAMLPAD2009, предлагаемую вместе с исходным кодом к этой главе, или Kaxaml (http://kaxaml.com), хотя на момент написания книги последняя еще не была модернизирована для работы с WPF 4.
        // - Создайте WPF-проект в Visual Studio и замените содержимое главного окна Window или элемента Page текстом примера; иногда может понадобиться внести в код некоторые изменения.


        // Определение XAML
        // XAML – сравнительно простой декларативный язык программирования общего назначения, предназначенный для конструирования  инициализации объектов.
        // можно говорить о WPF XAML, о Silverlight XAML и о других типах XAML-файлов.
        // Функциональность XAML, недоступная из процедурного кода:
        // - Создание полного набора шаблонов. В процедурном коде можно создавать шаблоны с помощью класса FrameworkElementFactory, но выразительные возможности этого подхода ограничены.
        // - Использование конструкции x:Shared="False", заставляющей WPF возвращать новый экземпляр при каждом обращении к элементу из словаря ресурсов.
        // - Отложенное создание объектов внутри словаря ресурсов. Это важно для оптимизации производительности и доступно только с помощьюскомпилированного XAML-кода. 

        // Элементы и атрибуты
        // В спецификации XAML определены правила отображения пространств имен, типов, свойств и событий .NET на пространства имен, элементы и атрибуты XML.
        // XAML:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK"/>
        // C#:
        // System.Windows.Controls.Button b = new System.Windows.Controls.Button();
        // b.Content = "OK";
    
        // Изменим код создания кнопки, задав не только свойство Content, но и обработчик события Click.
        // XAML:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK" Click="button_Click"/>
        // C#:
        // System.Windows.Controls.Button b = new System.Windows.Controls.Button();
        // b.Click += new System.Windows.RoutedEventHandler(button_Click);
        // b.Content = "OK";

        // Порядок обработки свойств и событий
        // Во время выполнения обработчики событий присоединяются до установки свойств объектов, объявленных в XAML-коде (за исключением описанного ниже свойства Name, которое устанавливается сразу после конструирования объекта). Поэтому при генерации событий в ответ на установку свойств можно не думать о порядке записи атрибутов в XAML.
        // Установка нескольких свойств и присоединение нескольких обработчиков событий обычно производятся в порядке задания атрибутов свойств и событий в объектном элементе. К счастью, на практике этот порядок не важен, поскольку согласно принципам проектирования в .NET порядок установки свойств объекта класса не должен иметь значения, и то же самое относится к порядку присоединения обработчиков событий.

        // Пространства имен
        // Наименее очевидный аспект при сравнении XAML-кода с эквивалентным кодом на С# – отображение пространства имен XML http://schemas.microsoft.com/ winfx/2006/xaml/presentation на пространство имен .NET System.Windows. Controls. В действительности отображение на это и другие пространства имен WPF жестко зашито в сборках WPF, точнее в нескольких экземплярах атрибута XmlnsDefinitionAttribute.
        // Так, в XAML-файлах для WPF обычно указывается второе пространство имен с префиксом x (записывается в виде xmlns:x, а не просто xmlns): xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        // Это пространство имен языка XAML, которое отображается на типы в пространстве имен System.Windows.Markup;

        // Неявные пространства имен .NET
        // Чтобы код было проще читать, лучше объявлять наиболее часто используемое пространство имен XML (называемое также основным) без префикса, для всех дополнительных пространств имен выбирать короткие префиксы. 

        // В процессе развития образовалось несколько пространств имен WPF XML


        // Элементы свойств
        // XAML предлагает альтернативный (менее компактный) синтаксис для установки составных свойств – элементы свойств. Выглядит это следующим образом:
        // Теперь свойство Content устанавливается с помощью XML-элемента, а не XML- атрибута, а результат эквивалентен коду на С#. Точка в выражении Button. Content позволяет отличить элемент свойства от объектного элемента.
        // Элементы свойств всегда имеют вид ИмяТипа. ИмяСвойства и обязательно вложены в объектный элемент вида ИмяТипа.
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK" Background="White"/>
        // эквивалентно
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // OK
        // </Button.Content>
        // <Button.Background>
        // White
        // </Button.Background>
        // </Button>

        // Конвертеры типов
        // В таких случаях компилятор или анализатор XAML должен найти конвертер типа, который умеет преобразовывать строковое значение в нужный тип.
        // Использование конвертеров типов в процедурном коде
        // Поиск конвертеров типов
        // при установке свойства Background кнопки Button в XAML-коде применяется конвертер типа BrushConverter, поскольку свойство Background имеет тип System.Windows. Media.Brush, в определении которого задан следующий атрибут:
        //[TypeConverter(typeof(BrushConverter)), ...]
        //public abstract class Brush : ...
        //{
        //...
        //}
        // для установки свойства FontSize кнопки используется конвертер типа FontSizeConverter, потому что это свойство (определенное в базовом классе Control) снабжено следующим атрибутом:
        // [TypeConverter(typeof(FontSizeConverter)), ...]
        // public double FontSize
        // {
        // get { ... }
        // set { ... }
        // }

        // Расширения разметки
        // Если значение атрибута заключено в фигурные  скобки {}, то компилятор или анализатор XAML считает  его значение расширением разметки, а не обычной строкой (или чем-то, нуждающимся в конвертере типов)
        //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //Background="{x:Null}"
        //Height="{x:Static SystemParameters.IconHeight}"
        //Content="{Binding Path=Height, RelativeSource={RelativeSource Self}}"/>
        // Первый идентификатор в каждом заключенном в фигурные скобки значении – имя класса расширения разметки, который должен наследовать классу MarkupExtension.
        // По принятому соглашению имена таких классов оканчиваются словом Extension, но в XAML его можно опускать. В данном примере NullExtension (записано в виде x:Null) и StaticExtension (записано в виде x:Static) – классы из пространства имен System.Windows. Markup, поэтому для их поиска необходимо указывать префикс x.
        // синтаксис и использование расширений разметки в XAML очень напоминает способ определения атрибутов.

        // Экранирование фигурных скобок
        // Если строковое значение атрибута свойства начинается открывающей фигурной скобкой, то ее следует экранировать, чтобы анализатор не счел ее началом расширения разметки. Это можно сделать, поставив перед ней пустую пару фигурных скобок, как в следующем примере:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="{}{Это не расширение разметки!}"/>
        // В качестве альтернативы можно использовать синтаксис элемента свойства, поскольку в этом контексте фигурные скобки не имеют специального смысла.
        //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //<Button.Content>
        //{Это не расширение
        //разметки!}
        //</Button.Content>
        //</Button>
        // Расширения разметки и процедурный код


        // Дочерние объектные элементы
        // Объектные элементы могут поддерживать наличие дочерних объектных элементов (а не только элементов свойств, которые с точки зрения XAML не являются дочерними). Объектный элемент может иметь потомков трех разных типов: значение свойства содержимого, элементы коллекции или значение, тип которого может быть преобразован в тип объектного элемента.
        
        // Свойство Content
        // В большинстве классов WPF имеется свойство (задаваемое с помощью атрибута), значением которого является содержимое данного XML-элемента. Оно называется свойством содержимого и в действительности представляет собой просто удобный способ сделать XAML-представление более компактным.
        // Для свойства Content кнопки Button имеется специальное соглашение (что очень кстати), поэтому описание
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
        // Content="OK"/>
        // можно представить в следующем виде:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // OK
        // </Button>
        // А составное содержимое Button, например
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // <Rectangle Height="40" Width="40" Fill="Black"/>
        // </Button.Content>
        // </Button>
        // можно переписать так:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Rectangle Height="40" Width="40" Fill="Black"/>
        // </Button>
        // Нигде не требуется, чтобы свойство содержимого называлось именно Content; так, в классах ComboBox, ListBox и TabControl (все из пространства имен System. Windows. Controls) свойство содержимого названо Items. 

        // Элементы коллекций
        // Язык XAML позволяет добавлять элементы в два основных вида коллекций, поддерживающих индексирование: списки и словари.
        // Списки
        // Списком считается любая коллекция, в которой реализован интерфейс System.Collections.IList, например System.Collections.ArrayList и многочисленные классы коллекций, определенные в WPF
        // <ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <ListBox.Items>
        // <ListBoxItem Content="Item 1"/>
        // <ListBoxItem Content="Item 2"/>
        // </ListBox.Items>
        // </ListBox>
        // Далее, поскольку Items – свойство содержимого для ListBox, то XAML-код можно еще сократить:
        //<ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //<ListBoxItem Content="Item 1"/>
        //<ListBoxItem Content="Item 2"/>
        //</ListBox>
        
        // Словари
        // Коллекция System.Windows.ResourceDictionary используется в WPF очень часто, в чем мы убедимся в главе 12 «Ресурсы ». Этот класс реализует интерфейс System.Collections.IDictionary, а значит, поддерживает добавление, удаление и перечисление пар ключ/значение в процедурном коде, как любая хеш-таблица.
        // В XAML в любую коллекцию, реализующую интерфейс IDictionary, можно добавить пару ключ/значение.
        // <ResourceDictionary
        // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        // <Color x:Key="1" A="255" R="255" G="255" B="255"/>
        // <Color x:Key="2" A="0" R="0" G="0" B="0"/>
        // </ResourceDictionary>
        // Списки, словари и анализатор XAML2009

        // Еще о преобразовании типов
        // Потомком объектного элемента может быть обычный текст, как в следующем объявлении элемента SolidColorBrush на XAML:
        // <SolidColorBrush>White</SolidColorBrush>
        // Эта запись эквивалентна следующей:
        // <SolidColorBrush Color="White"/>
        // даже несмотря на то, что Color не описано как свойство содержимого.
        // В данном случае первый фрагмент работает потому, что существует конвертер типа, умеющий преобразовывать такие строки, как "White" (или "white", или "#FFFFFF") в объект типа SolidColorBrush.

        // Расширяемая часть XAML
        // Поскольку XAML предназначен для работы с системой типов .NET, то его можно использовать практически с любым объектом .NET (и даже с COM-объектами благодаря интероперабельности с COM), в том числе определенным вами. При этом совершенно неважно, относятся ли эти объекты к пользовательскому интерфейсу.
        // если в классе нет ни конструктора по умолчанию, ни полезных открытых свойств, то им нельзя будет напрямую воспользоваться в XAML
        // Сборки WPF помечены атрибутом XmlnsDefinitionAttribute, который отображает содержащиеся в них пространства имен .NET на пространство имен XML в XAML-файле
        // System.Collections.Hashtable h = new System.Collections.Hashtable();
        // h.Add("key1", 7);
        // h.Add("key2", 23);
        // А вот как его можно представить в XAML:
        // <collections:Hashtable
        //­­xmlns:collections="clr-namespace:System.Collections;assembly=mscorlib"
        //­­xmlns:sys="clr-namespace:System;assembly=mscorlib"
        //­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        //­­<sys:Int32 x:Key="key1">7</sys:Int32>
        //­­<sys:Int32 x:Key="key2">23</sys:Int32>
        //</collections:Hashtable>
        // Директива clr­namespace позволяет использовать пространство имен .NET непосредственно в XAML. 
        // - Дочерние элементы можно добавлять в родительскую хеш-таблицу Hashtable с помощью стандартного синтаксиса XAML x:key, поскольку Hashtable, как и другие классы коллекций в .NET Framework, реализует интерфейс IDicti­ona­ry начиная с версии 1.0.
        // - Тип System.Int32 можно использовать столь простым образом, поскольку уже существует конвертер типа, умеющий преобразовывать строку в целое число. Объясняется это тем, что конвертеры типов, поддерживаемые XAML, – всего лишь подклассы класса System.ComponentModel.TypeConverter, который также существует со времени версии .NET Framework 1.0. Это тот же механизм преобразования типов, что используется в Windows Forms (и позволяет, например, вводить в сетке свойств в Visual Studio строки, которые преобразуются в подходящий тип).

        // Правила обработки потомков объектных элементов в XAML
        // 1. Если тип реализует интерфейс IList, вызвать IList.Add для каждого дочернего элемента.
        // 2. Иначе, если тип реализует интерфейс IDictionary, вызвать IDictionary.Add для каждого дочернего элемента, используя в качестве ключа значение атрибута x:Key, а в качестве значения – сам элемент. (Правда, анализатор XAML2009 проверяет IDictionary раньше IList и поддерживает также другие интерфейсы коллекций, о чем упоминалось выше.)
        // 3. Иначе, если у родителя есть свойство содержимого (помеченное атрибутом System.Win­dows.Markup.ContentPropertyAttribute) и тип дочернего элемента совместим с этим свойством, считать дочерний элемент значением этого свойства.
        // 4. Иначе, если дочерний элемент является простым текстом и существует конвертер типа, который может преобразовать этот текст в тип родителя (и при этом для родителя не установлены никакие свойства), подать дочерний элемент на вход конвертера типа, а полученный результат считать экземпляром родителя.
        // 5. Иначе считать содержимое неизвестным, что может являться поводом для возбуждения исключения.


        // Сочетание XAML и процедурного кода
        // Загрузка и разбор XAML во время выполнения
        // В состав WPF входит анализатор XAML, работающий на этапе выполнения. Он представлен двумя классами в пространстве имен System.Win­dows.Markup:
        // Xaml­Reader и XamlWriter.

        // Класс XamlReader
        // Так, если XAML-файл MyWindow.xaml в текущем каталоге содержит в качестве корневого узла объект Window (подробно рассматриваемый в главе 7 «Структурирование и развертывание приложения»), то для загрузки и получения объекта Window можно использовать следующий код:
        // Window window = null;
        //using (FileStream fs = ­­new FileStream("MyWindow.xaml", FileMode.Open, FileAccess.Read))
        //{
        //­­// По­лу­чить кор­не­вой эле­мент. Мы зна­ем, что это Window
        //­­window = (Window)XamlReader.Load(fs);
        //}
        // Найти кнопку OK, перебирая дочерние элементы (мы
        // пользуемся априорными знаниями о структуре документа!)
        //StackPanel panel = (StackPanel)window.Content;
        //Button okButton = (Button)panel.Children[4];
        // К счастью, XAML поддерживает именование элементов, поэтому их можно находить и использовать посредством процедурного кода.
        // В классе XamlReader определен также метод экземпляра LoadAsync, который загружает и разбирает XAML-код асинхронно. Этим методом имеет смысл пользоваться, например, чтобы не «подвешивать» пользовательский интерфейс на время, пока загружается большой XAML-файл или производится загрузка по сети.
        // К тому же обработка производится асинхронно, только если в корневом узле XAML установлен атрибут x:SynchronousMode="Async"

        // Именование элементов XAML
        // В пространстве имен XAML определено ключевое слово Name, которое позволяет назначить имя любому элементу.
        // <Button x:Name="okButton">OK</Button>
        // Находим кнопку OK, зная только ее имя
        // Button okButton = (Button)window.FindName("okButton");
        // Метод FindName имеется не только в классе Window. Он определен в классах Frame­workElement и FrameworkContentElement, которые являются базовыми для многих важных классов WPF.
        // Синтаксис x:Name можно использовать для именования элементов, но в некоторых классах определено специальное свойство, которое можно рассматривать как имя элемента (оно назначается с помощью атрибута System.Win­dows.Markup.Run­ti­me­Name­Pro­per­tyAttribute). Например, в классах FrameworkElement и Frame­workCon­tent­Element имеется свойство Name, поэтому они помечены атрибутом Run­ti­meNa­meProperty("Name"). Это означает, что для таких элементов можно просто задать свойство Name, не используя синтаксис x:Name
        // Во всех версиях WPF для ссылки на именованный элемент можно использовать расширение разметки Binding в значении свойства:
        //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //­­<Label Target="{Binding ElementName=box}" Content="Enter _text:"/>
        //­­<TextBox Name="box"/>
        //</StackPanel>

        // WPF 4 включает новое, более простое расширение разметки Sys­tem.Win­dows.Markup.Reference, которое позволяет искать элементы на этапе синтаксического разбора, а не выполнения. Его можно использовать следующим образом:
        //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        //­­<Label Target="{x:Reference box}" Content="Enter _text:"/>
        //­­<TextBox Name="box"/>
        //</StackPanel>

        // Кроме того, если свойство помечено конвертером типа System.Win­dows.Markup.Name­Re­fe­ren­ceConverter (как в данном случае), то строковое имя неявно преобразуется в экземпляр, на который ведет ссылка:
        //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //­­<Label Target="box" Content="Enter _text:"/>
        //­­<TextBox Name="box"/>
        //</StackPanel>

        // Компиляция XAML
        // Компиляция XAML включает три шага: преобразование XAML-файла в специальный двоичный формат, включение результата в создаваемую сборку в качестве двоичного ресурса и создание инфраструктуры, которая автоматически подключает XAML к процедурному коду.
        // Однако в типичном случае, когда XAML-файл компилируется и сочетается с процедурным кодом, первым делом нужно задать подкласс для корневого элемента в XAMLфайле. Это можно сделать с помощью ключевого слова Class, определенного в пространстве имен XAML. Например:
        //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //x:Class="MyNamespace.MyWindow">
        //­­...
        //</Window>

        // Поддержка откомпилированного XAML-кода в произвольном .NET-языке
        // Для использования откомпилированного XAML-кода в произвольном .NET-совместимом языке программирования необходимо выполнение двух требований: наличие соответствующего поставщика CodeDom и целевого файла MSBiuld. Кроме того, желательна (но не обязательна) поддержка в языке частичных классов.
        //namespace MyNamespace
        //{
        //­­partial class MyWindow : Window
        //­­{
        //­­­­public MyWindow()
        //­­­­{
        //­­­­­­// Не­об­хо­ди­мо для за­груз­ки со­дер­жи­мо­го, оп­ре­де­лен­но­го в XAML­фай­ле!
        //­­­­­­InitializeComponent();
        //­­­­­­...
        //­­­­}
        //­­­­Здесь мо­гут быть лю­бые чле­ны...
        //­­}
        //}
        // Этот файл часто называют застраничным (code­behind file). Если в XAML-коде имеются ссылки на обработчики событий (в таких атрибутах событий, как Click для Button), то именно здесь их следует определить.
        // Ключевое слово partial в определении класса важно, поскольку реализация класса распределена по нескольким файлам. Если .NET-совместимый язык не поддерживает частичные классы (как, например, С++/CLI и J#), то в XAMLфайле необходимо задать также ключевое слово Subclass в корневом элементе:
        //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //x:Class="MyNamespace.MyWindow" x:Subclass="MyNamespace.MyWindow2">
        //­­...
        //</Window>
        // Таким образом, разделение реализации между двумя файлами моделируется с помощью наследования.
        // Visual Studio автоматически создает XAML-файл с атрибутом x:Class в корневом элементе и застраничный исходный файл, содержащий частичное определение класса, а также связывает их между собой, чтобы они правильно обрабатывались при построении проекта.
        // <ItemGroup>
        //­­<Page Include="MyWindow.xaml"/>
        //</ItemGroup>
        //<ItemGroup>
        //­­<Compile Include="MyWindow.xaml.cs">
        //­­­­<DependentUpon>MyWindow.xaml</DependentUpon>
        //­­­­<SubType>Code</SubType>
        //­­</Compile>
        //</ItemGroup>
        // Для такого проекта система построения генерирует несколько файлов в ходе обработке MyWindow.xaml, в том числе:
        // - BAML-файл (MyWindow.baml), который по умолчанию внедряется в сборку в качестве двоичного ресурса.
        // - С#-файл (MyWindow.g.cs), который компилируется и включается в сборку, как любой другой файл с исходным кодом.
        // Атрибут x:Class разрешается использовать только в компилируемых XAMLфайлах. Но иногда можно скомпилировать XAML-файл и без этого атрибута. Это просто означает, что соответствующий застраничный файл отсутствует, так что пользоваться средствами, нуждающимися в процедурном коде, нельзя. Поэтому добавление в проект Visual Studio XAML-файла без атрибута x:Class – хороший способ воспользоваться всеми преимуществами компиляции XAML в плане повышения производительности и удобства развертывания без создания ненужного застраничного файла.

        // BAML
        // Аббревиатура BAML расшифровывается как Binary Application Markup Language (Двоичный язык разметки приложений).
        // По существу, BAML – это деталь реализации процедуры компиляции XAML.

        // Когда-то здесь был CAML…

        // Генерируемый исходный код
        // В процессе компиляции XAML кое-какой процедурный код все же генерируется (если использовался атрибут x:Class), но это всего лишь «клей», аналогичный тому, что пришлось бы писать для загрузки и разбора независимого XAML-файла во время исполнения программы. Таким файлам присваивается суффикс вида .g.cs (или .g.vb), где g означает «сгенерированный» (generated).
        // Каждый сгенерированный исходный файл содержит частичное определение класса, указанного в атрибуте x:Class корневого объектного элемента. В нем находятся поля (по умолчанию internal) для каждого именованного элемента в XAML-файле, при этом в качестве имени поля используется имя элемента.
        // Там же находится метод InitializeComponent, который выполняет всю рутинную работу по загрузке внедренного BAML-ресурса, присваиванию полям экземпляров объектов, первоначально определенных в XAML-файле, и присоединению обработчиков событий (если они были специфицированы в XAML).
        // Нужно только не забыть вызвать метод InitializeComponent в конструкторе своего застраничного класса.

        // Не забывайте вызывать метод InitializeComponent в конструкторе своего застраничного класса!
        // все поля, представляющие именованные объектные элементы, будут равны null.

        // Процедурный код внутри XAML
        // Для этого предназначено ключевое слово Code из пространства имен XAML:
        //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //­­­­­­­­x:Class="MyNamespace.MyWindow">
        //­­<Button Click="button_Click">OK</Button>
        //<x:Code><![CDATA[
        //void button_Click(object sender, RoutedEventArgs e)
        //{
        //this.Close();
        //}
        //]]></x:Code>
        //</Window>
        // При компиляции такого XAML-файла содержимое элемента x:Code копируется в частичный класс, находящийся в .g.cs-файле. Отметим, что процедурный язык в XAML-файле не указывается; он определяется проектом, содержащим этот файл.
        // Так не нужно делать!
        
        // Можно ли BAML декомпилировать обратно в XAML?
        // можно вызвать статический метод System.Win­dows.Application.LoadComponent, который загружает нужный объект из BAML:
        //System.Uri uri = new System.Uri("/WpfApplication1;component/MyWindow.xaml", ­­System.UriKind.Relative);
        //Window window = (Window)Application.LoadComponent(uri);
        // На самом деле автоматически генерируемый Visual Studio метод InitializeComponent вызывает именно метод Appli­cati­on.LoadComponent для загрузки внедренного BAML-кода, правда, другой перегруженный вариант.
        // Имея корневой элемент, мы можем воспользоваться классом System.Win­dows.Markup.XamlWriter, чтобы получить XAML-представление этого элемента (а следовательно, и всех его потомков). Класс XamlWriter содержит пять перегруженных вариантов статического метода Save; самый простой принимает экземпляр объекта и возвращает соответствующий XAML-код в виде строки:
        // string xaml = XamlWriter.Save(window);

        // Введение в XAML2009
        // Полная поддержка универсальных классов
        // с#
        // public class PhotoCollection : ObservableCollection<Photo> { }
        // XAML:
        //<custom:PhotoCollection>
        //­­<custom:Photo .../>
        //­­<custom:Photo .../>
        //</custom:PhotoCollection>
        // В XAML2009 атрибут x:TypeArguments может употребляться в любом элементе, поэтому, скажем, объекты класса ObservableCollection<Photo> допустимо создавать непосредственно в XAML:
        //<collections:ObservableCollection TypeArguments="custom:Photo">
        //­­<custom:Photo .../>
        //­­<custom:Photo .../>
        //</collections:ObservableCollection>

        // Словарные ключи произвольного типа
        // В XAML2009 преобразование типов применяется и к значениям атрибута x:Key, поэтому в словарь можно добавлять значения с нестроковыми ключами, не прибегая к расширениям разметки. Например:
        //<collections:Dictionary x:TypeArguments="x:Int32, x:String">
        //­­<x:String x:Key="1">One</x:String>
        //­­<x:String x:Key="2">Two</x:String>
        //</collections:Dictionary>
        // Здесь предполагается, что collections отображается на пространство имен Sys­tem.Collections.Generic.

        // Отключение преобразования типов для нестроковых словарных ключей
        // Для обратной совместимости в классе XamlObjectWriter из XAML2009 имеется возможность отключить новый механизм автоматического преобразования типов. Это свойство XamlObjectWriterSettings.PreferUnconvertedDictionaryKeys. Принимая значение true, System.Xaml не будет конвертировать ключи, если словарь реализует неуниверсальный интерфейс IDictionary, при условии, что:
        // - System.Xaml уже потерпел неудачу при вызове метода IDictionary.Add для того же экземпляра, или
        // - словарь принадлежит известному типу .NET Framework, и System.Xaml точно знает, что для него необходимо преобразование.

        // Встроенные системные типы данных
        // В XAML2006 использовать встроенные типы данных .NET, например String или Int32, было неудобно, так как требовалось ссылаться на пространство имен System из сборки mscorlib; мы уже видели, как это выглядит:
        // <sys:Int32 xmlns:sys="clr­namespace:System;assembly=mscorlib">7</sys:Int32>
        // <x:Int32>7</x:Int32>

        // Создание объектов с помощью конструктора с аргументами
        // В XAML2009 появилось новое ключевое слово x:Arguments, которое позволяет задать один или несколько аргументов для передачи конструктору класса.
        // <sys:Version x:Arguments="4.0.30319.1"/>
        //<sys:Version>
        //<x:Arguments>
        //<x:Int32>4</x:Int32>
        //<x:Int32>0</x:Int32>
        //<x:Int32>30319</x:Int32>
        //<x:Int32>1</x:Int32>
        //</x:Arguments>
        //</sys:Version>

        // Создание экземпляров с помощью фабричных методов
        // С помощью нового ключевого слова x:FactoryMethod в XAML2009 можно создать экземпляр класса, вообще не имеющего открытых конструкторов. x:Facto­ry­Method позволяет указать произвольный открытый статический метод, который возвращает объект нужного типа. Например, в следующем XAML-коде используется объект типа Guid, возвращаемый статическим методом Guid.NewGuid:
        //<Label xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation
        //­­­­­­­xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml
        //­­­­­­­xmlns:sys="clr­namespace:System;assembly=mscorlib">
        //­­<sys:Guid x:FactoryMethod="sys:Guid.NewGuid"/>
        //</Label>

        //<Label xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation
        //­­­­­­­xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml
        //­­­­­­­xmlns:sys="clr­namespace:System;assembly=mscorlib"
        //­­­­­­­xmlns:interop=
        //­­­­­­­­­"clr­namespace:System.Runtime.InteropServices;assembly=mscorlib">
        //<sys:Exception x:FactoryMethod="interop:Marshal.GetExceptionForHR">
        //<x:Arguments>
        //<x:Int32>0x80004001</x:Int32>
        //</x:Arguments>
        //</sys:Exception>
        //</Label>

        // Гибкость присоединения обработчиков событий
        // <Button Click="{custom:DelegateFinder Click}"/>

        // Определение новых свойств
        // в XAML2009 появилось два новых элемента – x:Members и x:Property, – которые позволяют определять дополнительные свойства непосредственно на XAML. но не приемлима с wpf.

        // Трюки с классами чтения и записи XAML
        // Мы уже видели, как читать и записывать XAML-код с помощью методов XamlReader.Load и XamlWriter.Save из пространства имен System.Windows.Markup.
        // Новая сборка System.Xaml содержит абстрактные базовые классы System.Xaml.XamlReader и System.Xaml.XamlWriter

        // Обзор
        // Класс XamlReader предназначен для генерации потока логических узлов XAML из произвольного источника
        // а XamlWriter на входе получает такой поток узлов и выводит его произвольным способом.
        // Считыватели (производные от System.Xaml.XamlReader):
        // - System.Xaml.XamlXmlReader – читает XML-код (из System.Xml.XmlReader, System.IO.TextReader, System.IO.Stream или из файла, заданного своим именем в виде строки).
        // - System.Xaml.XamlObjectReader – читает существующий граф объектов.
        // - System.Windows.Baml2006.Baml2006Reader – читает BAML-код (в WPF все еще используется формат 2006 года).
        // - System.Xaml.XamlBackgroundReader – обертывает другой объект XamlReader, реализуя двойную буферизацию, что позволяет считывателю работать не в том же потоке, что записыватель. 
        // Записыватели (производные от System.Xaml.XamlWriter):
        // - System.Xaml.XamlXmlWriter – записывает XML (используя System.Xml.XmlWriter, System.IO.TextWriter или Stream).
        // - System.Xaml.XamlObjectWriter – создает граф объектов.

        // Описанная в этом разделе функциональность применима главным образом к вариантам XAML, не относящимся к WPF!
        // Почему для чтения XAML-файлов лучше использовать XamlXmlReader, а не просто XmlReader? Разве XAML не является диалектом XML?
        // XamlXmlReader в действительности пользуется классом XmlReader, но дополнительно обеспечивает еще две важные возможности.
        // - Абстрагирует различия в представлениях XML, эквивалентных с точки зрения XAML.
        // - Порождает поток узлов XAML, совместимый с любым записывателем XAML и содержащий дополнительную информацию, которая отсутствует в исходном XML.
        // Первая возможность существенна для сокращения работы, связанной с чтением XAML. Например, следующие три фрагмента XAML-кода выражают одну и ту же концепцию – кнопку Button, для которой свойство Content содержит строку "ОК": 
        // <!-- Неявная установка свойства содержимого: -->
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // OK
        // </Button>
        // <-- Установка свойства с помощью синтаксиса элементов: -->
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // OK
        // </Button.Content>
        // </Button>
        // <!-- Установка свойства с помощью синтаксиса атрибутов: -->
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK"/>

        // Циклы обработки узлов
        // Простой цикл обработки узлов
        // while (reader.Read())
        // {
        // writer.WriteNode(reader);
        // }

        // !!! check includes
        //public static object ConvertXmlStringToObjectGraph(string xmlString)
        //{
        //    // String -> TextReader -> XamlXmlReader
        //    using (TextReader textReader = new StringReader(xmlString))
        //    using (XamlXmlReader reader = new XamlXmlReader(textReader, System.Windows.Markup.XamlReader.GetWpfSchemaContext()))
        //    using (XamlObjectWriter writer = new XamlObjectWriter(reader.SchemaContext))
        //    {
        //        // Простой цикл обработки узлов
        //        while (reader.Read())
        //        {
        //            writer.WriteNode(reader);
        //        }
        //        // По завершении работы XamlObjectWriter здесь будет
        //        // находиться экземпляр корневого объекта
        //        return writer.Result;
        //    }
        //}

        // Чтение XAML
        // Самым важным свойством XamlReader, которое имеет смысл анализировать при записи узла в цикле, является NodeType, способное принимать одно из восьми перечисляемых значений:
        // - StartObject – считыватель позиционирован в начале явно представленного объекта, например открывающего тега XML-элемента или расширения разметки, указанного в качестве значения свойства.
        // - GetObject – считыватель позиционирован в начале неявного объекта, например коллекции, которая в XAML явно не представлена, хотя ее элементы присутствуют (как в примере ListBox, приведенном в разделе «Элементы коллекций»).
        // - EndObject – считыватель позиционирован в конце объекта (который ранее встречался в виде StartObject или GetObject). Каждому узлу StartObject или GetObject соответствует узел EndObject, который встретится в потоке позже.
        // - StartMember – считыватель позиционирован в начале некоторого члена объекта: свойства (присоединенного или нет), события (присоединенного или нет) либо директивы XAML, например x:Key. Каждый атрибут принадлежит некоторому родительскому объекту, поэтому узлу StartMember обязательно предшествует узел StartObject или GetObject. Отметим, что в XML неважно, задан ли член с помощью синтаксиса атрибута свойства или элемента свойства, – в любом случае он является членом, а не объектом.
        // - EndMember – считыватель позиционирован в конце члена объекта (для которого ранее встречался узел StartMember). Каждому узлу StartMember обязательно соответствует находящийся далее в потоке узел EndMember. 
        // - Value – считыватель позиционирован в начале значения члена объекта. Поскольку каждое значение ассоциировано с каким-то членом, то невозможно появление узла Value до соответствующего ему StartMember (и предшествующего ему узла StartObject или GetObject).
        // - NamespaceDeclaration – считыватель позиционирован на объявлении пространства имен XML (которое ассоциирует пространство имен с префиксом). Отметим, что такой узел непосредственно предшествует узлу StartObject, который «содержит » эти объявления. Это может показаться удивительным, но, учитывая, что объявления пространств имен предоставляют контекст даже для корневого элемента, важно, чтобы контекст был определен предварительно.
        // None – считыватель позиционирован на чем-то, не являющемся реальным узлом, например находящемся в конце файла. Узлы такого типа можно без опаски игнорировать.
        // В классе XamlReader определены четыре важных свойства, которые позволяют извлекать нужные данные об узле любого типа: Type, Member, Value и Namespace.
        // Когда свойство HasLineInfo равно true, можно получить данные о номере строки и позиции в ней, обратившись к свойствам LineNumber и LinePosition соответственно.

        // Откуда берутся экземпляры XamlType и XamlMember, обнаруживаемые считывателями XAML?
        // Эти классы представляют собой специфическую для XAML форму отражения .NET.
        // Разобрать Поток узлов XAML

        // Совместимость разметки

        // Запись в объекты
        // Производятся две модификации:
        // - Убираются все члены, относящиеся к событиям, так как если обработчик события не найден, то XamlObjectWriter возбуждает исключение, например,с таким сообщением: Failed to create a 'Click' from the text 'button_Click'. Отметим, что в классе XamlObjectWriter имеется свойство RootObjectInstance, которому можно присвоить объект с подходящими обработчиками событий, но проще всего эти события просто выкинуть – для инструмента экспериментирования с XAML такой подход вполне приемлем. Кроме этого, убирается атрибут x:Class, потому что в автономном XAML-коде он недопустим.
        // - Элемент Window конвертируется в Page. В главе 7 эти элементы рассматриваются подробно, но смысл в том, что элемент Window не может быть потомком другого элемента, а XAMLPAD2009 всегда пытается присоединить корневой объект в качестве непосредственного потомка своего собственного пользовательского интерфейса. Существуют и другие способы справиться с этой трудностью (например, увидев, что корневым элементом является Window, создавать из него окно), но описанной выше замены одного узла XAML другим для учебного примера достаточно.

        //public static object ConvertXmlStringToMorphedObjectGraph(string xmlString)
        //{
        //­­// String­­> TextReader­­> XamlXmlReader
        //­­using (TextReader textReader = new StringReader(xmlString))
        //­­using (XamlXmlReader reader = new XamlXmlReader(textReader,
        //­­­­­­­­­­­System.Win­dows.Markup.XamlReader.GetWpfSchemaContext()))
        //­­using (XamlObjectWriter writer = new XamlObjectWriter(reader.SchemaContext))
        //­­{
        //­­­­// Цикл об­ра­бот­ки уз­лов
        //­­­­while (reader.Read())
        //­­­­{
        //// Пропустить события и x:Class
        //if (reader.NodeType == XamlNodeType.StartMember &&
        //reader.Member.IsEvent || reader.Member == XamlLanguage.Class)
        //{
        //reader.Skip();
        //}
        //if (reader.NodeType == XamlNodeType.StartObject &&
        //reader.Type.UnderlyingType == typeof(Window))
        //{
        //// Преобразовать Window в Page
        //writer.WriteStartObject(new XamlType(typeof(Page),
        //reader.SchemaContext));
        //}
        //    else
        //{
        //// В противном случае вывести узел без изменений
        //writer.WriteNode(reader);
        //}
        //­­­­}
        //­­­­// По за­вер­ше­нии ра­бо­ты XamlObjectWriter здесь бу­дет
        //­­­­// эк­зем­п­ляр кор­не­во­го объ­ек­та
        //­­­­return writer.Result;
        //­­}
        //}

        // Запись в формате XML
        //public static string RewriteXaml(string xmlString)
        //{
        //­­// String­­> TextReader­­> XamlXmlReader
        //­­using (TextReader textReader = new StringReader(xmlString))
        //­­using (XamlXmlReader reader = new XamlXmlReader(textReader))
        //­­// TextWriter­­> XmlWriter­­> XamlXmlWriter
        //­­using (StringWriter textWriter = new StringWriter())
        //­­using (XmlWriter xmlWriter = XmlWriter.Create(textWriter,
        //­­­­­­­­­­­new XmlWriterSettings { Indent = true, OmitXmlDeclaration = true }))
        //­­using (XamlXmlWriter writer = new XamlXmlWriter(xmlWriter,
        //­­­­­­­­­­­reader.SchemaContext))
        //­­{
        //­­­­// Про­стой цикл об­ра­бот­ки уз­лов
        //­­­­while (reader.Read())
        //­­­­{
        //­­­­­­writer.WriteNode(reader);
        //­­­­}
        //­­­­return textWriter.ToString();
        //­­}
        //}

        // XamlServices
        // Чтобы пользователю приходилось писать меньше кода, самые распространенные случаи употребления средств чтения и записи XAML инкапсулированы в простые статические методы, определенные в классе System.Xaml.XamlSer­vices, а именно:
        // - Load – есть несколько перегруженных вариантов, принимающих имя файла в виде строки, объекты Stream, TextReader, XmlReader или XamlReader. Все они возвращают корень соответствующего графа объектов, как и прежний метод XamlReader.Load. Внутри Load вся работа производится объектами XamlXmlReader и XamlObjectWriter.
        // - Parse – как и Load, метод Parse возвращает корень графа объектов, но на входе принимает XAML-содержимое в виде строки. Внутри он создает из этой строки объект StringReader, затем XmlReader и наконец XamlXmlReader, от имени которого можно уже вызвать метод Load. Таким образом, Parse аналогичен методу ConvertXmlStringToObjectGraph
        // - Save – принимает на входе объект и, в зависимости от перегруженного варианта, возвращает его содержимое в виде строки, объекта Stream, Text­Writer, XmlWriter либо XamlWriter или даже сохраняет содержимое объекта прямо в текстовом файле. Внутри Save создает экземпляры Xaml­Object­Re­ader и XamlXmlWriter (если только ему уже не передан объект XamlWriter). Он присваивает свойствам Indent и OmitXmlDeclaration объекта XamlWriter значение true.
        // - Transform – выполняет тривиальный цикл обработки узлов, применяя считыватель и записыватель, которые ему переданы.

        //public static void Transform(XamlReader reader, XamlWriter writer)
        //{
        //­­IXamlLineInfo producer = reader as IXamlLineInfo;
        //­­IXamlLineInfoConsumer consumer = writer as IXamlLineInfoConsumer;
        //­­bool transferLineInfo = (producer != null && producer.HasLineInfo &&
        //­­­­­­­­­­­­­­­­­­­­­­­­­­­consumer != null && consumer.ShouldProvideLineInfo);
        //­­// Улуч­шен­ный цикл об­ра­бот­ки уз­лов
        //­­while (reader.Read())
        //­­{
        //­­­­// Передать информацию о строке
        //if (transferLineInfo && producer.LineNumber > 0)
        //consumer.SetLineInfo(producer.LineNumber, producer.LinePosition);
        //­­­­writer.WriteNode(reader);
        //­­}
        //}

        //public static object ConvertXmlStringToObjectGraph(string xmlString)
        //{
        //­­// String­­> TextReader­­> XamlXmlReader
        //­­using (TextReader textReader = new StringReader(xmlString))
        //­­using (XamlXmlReader reader = new XamlXmlReader(textReader,
        //­­­­­­­­­­­System.Win­dows.Markup.XamlReader.GetWpfSchemaContext()))
        //­­using (XamlObjectWriter writer = new XamlObjectWriter(reader.SchemaContext))
        //­­{
        //// Цикл обработки узлов
        //XamlServices.Transform(reader, writer);
        //­­
        //­­­­// По за­вер­ше­нии ра­бо­ты XamlObjectWriter здесь бу­дет
        //­­­­// эк­зем­п­ляр кор­не­во­го объ­ек­та
        //­­return writer.Result;
        //­­}
        //}

        // Берегитесь подводных камней XamlServices в WPF XAML!
        //public static string RewriteXaml(string xmlString)
        //{
        //­­return XamlServices.Save(XamlServices.Parse(xmlString));
        //}
        // приведенный код просто не работает, поскольку XamlObjectWriter в настоящее время не поддерживает WPF-объекты. Можно было бы вместо этого воспользоваться более старыми классами XamlReader и XamlWriter:
        //return System.Win­dows.Markup.XamlWriter.Save(­­System.Win­dows.Markup.XamlReader.Parse(xmlString));
        // Или, если нужна красивая печать:
        // using (StringWriter textWriter = new StringWriter())
        // using (XmlWriter xmlWriter = XmlWriter.Create(textWriter, new XmlWriterSettings { Indent = true, OmitXmlDeclaration = true }))
        //{
        //­­System.Win­dows.Markup.XamlWriter.Save(
        //­­­­System.Win­dows.Markup.XamlReader.Parse(xmlString), xmlWriter);
        //­­return textWriter.ToString();
        //}

        // Набор инструментов Microsoft XAML Toolkit построенный на основе классов из пространства имен System.Xaml, предлагает несколько очень интересных возможностей, например интеграцию XAML с инструментом FxCop и объектную модель документа XAML.

        // Ключевые слова XAML
        // Специальные атрибуты, определенные консорциумом W3C
        // xml:space для управления разбором пробелов и xml:lang для объявления языка и культуры документа
        // Ключевые слова из пространства имен языка XAML со стандартным префиксом x
        // x:AsyncRecords - Атрибут корневого элемента - Управляет размером блока при асинхронной загрузке XAML
        // X:Arguments - Атрибут или вложенный элемент - Задает аргумент (или несколько аргументов, если употребляется в качестве элемента), передаваемый конструктору элемента. При использовании в сочетании с x:FactoryMethod задает аргумент(ы) фабричного метода 
        // X:Boolean - Представляет класс System.Boolean
        // X:Byte - Представляет класс System.Byte
        // x:Char - Представляет класс System.Char
        // x:Class - Определяет для корневого элемента класс, производный от типа элемента. Может сопровождаться необязательным префиксом пространства имен .NET
        // x:ClassAttributes - Не используется в WPF; содержит атрибуты, относящиеся к Windows Workflow Foundation
        // x:ClassModifier - Определяет видимость класса, указанного в x:Class (по умолчанию открытого). Значение атрибута должно быть задано в терминах используемого процедурного языка (например public или inter­nal для С#)
        // x:Code - Окружает процедурный код, включаемый в класс, указанный в x:Class.
        // x:ConnectionId - Не для открытого применения
        // x:Decimal - Представляет System.Decimal
        // x:Double - Представляет System.Double
        // x:FactoryMethod - Определяет статический метод, вызываемый для получения экземпляра элемента вместо конструктора
        // x:FieldModifier - Определяет видимость поля, генерируемого для элемента (по умолчанию internal). Как и в случае x:ClassModifier, значение этого атрибута должно быть задано в терминах процедурного языка (например, public, private, … для С#)
        // x:Int16 - Представляет System.Int16
        // x:Int32 - Представляет System.Int32
        // x:Int64 - Представляет System.Int64
        // x:Key - Задает ключ элемента при добавлении в словарь родителя
        // x:Members - Определяет дополнительные члены корневого класса, заданного в x:Class
        // x:Name - Задает имя поля, генерируемого для элемента, по которому на него можно ссылаться из процедурного кода
        // x:Object - Представляет System.Object
        // x:Property - Определяет свойство внутри элемента x:Members
        // x:Shared - Может принимать значение false для запрета использования одного экземпляра ресурса в нескольких местах (см. главу 12)
        // x:Single - Представляет System.Single
        // x:String - Представляет System.String
        // x:Subclass - Определяет подкласс класса, заданного в x:Class, в котором хранится содержимое, определенное в XAML. В качестве необязательного префикса можно указать пространство имен .NET (используется с языками, не поддерживающими частичные классы)
        // x:SynchronousMode - Определяет, может ли содержимое XAML загружаться асинхронно
        // x:TimeSpan - Представляет System.TimeSpan
        // x:TypeArguments - Делает класс универсальным (как List<T>), конкретизируемым указанными аргументами (например, List<Int32> или List<String>). Может содержать список аргументов конкретизации через запятую. Типам, отсутствующим в пространстве имен по умолчанию, должен предшествовать префикс пространств имен XML
        // x:Uid - Помечает элемент идентификатором для локализации (см. главу 12)
        // x:Uri - Представляет System.Uri
        // x:XData - Произвольный остров данных XML, который остается непрозрачным для анализатора XAML

        // элементы пространства имен XAML, которые можно принять за ключевые слова, хотя на самом деле это расширения разметки (реальные классы .NET в пространстве имен System.Win­dows.Markup). Суффикс Extension в именах классов опущен, поскольку они обычно используются без суффикса.
        // x:Array - Представляет массив .NET. Потомками элемента x:Array являются элементы массива. В элементе должен присутствовать атрибут x:Type, определяющий тип массива
        // x:Null - Представляет ссылку null
        // x:Reference - Ссылка на именованный элемент. Должен присутствовать единственный позиционный параметр, задающий имя этого элемента
        // x:Static - Ссылка на любое статическое свойство, поле, константу или элемент перечисления, определенные в процедурном коде. При компиляции XAML это может быть даже неоткрытый член, определенный в той же сборке. Строка Member должна быть квалифицирована префиксом пространства имен XML, если тип не находится в пространстве имен по умолчанию
        // x:Type - Представляет экземпляр типа System.Type так же, как оператор typeof в С#. Строка TypeName должна быть квалифицирована префиксом пространства имен XML, если тип не находится в пространстве имен по умолчанию

        // Резюме
        // Возражение 1: XML слишком многословен, долго набирать
        // Возражение 2: системы, основанные на XML, низкопроизводительны
    }
}
