using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._1_Basic_Information._2_XAML
{
    /// <summary>
    /// Interaction logic for XAML.xaml
    /// </summary>
    public partial class XAML : Window
    {
        public XAML()
        {
            InitializeComponent();
        }

        private void okButton_Click(object sender, RoutedEventArgs e)
        {

        }

        // - Язык XAML может стать очень компактным средством описания пользовательского интерфейса и других иерархий объектов.
        // - XAML позволяет легко отделить внешний вид приложения от его внутренней логики, что сильно упрощает последующее сопровождение, даже если команда разработчиков состоит всего из одного человека.
        // - Код на XAML легко скопировать в различные средства разработки, например Visual Studio, Expression Blend или какую-нибудь небольшую автономную программу, и сразу увидеть результат без какой либо компиляции.
        // - Именно код XAML генерируют практически все средства разработки, связанные с WPF.

        // Существует несколько способов выполнить написанные на XAML примеры
        // - Сохраните текст примера в файле с расширением .xaml и откройте его в Internet Explorer (для Windows Vista или более поздней либо для Windows XP с установленным каркасом .NET 3.0 или более поздней версией). Можно также использовать Firefox, если установлено соответствующее дополнение. Но по умолчанию браузер будет использовать версию WPF, установленную вместе с операционной системой, а не WPF 4. 
        // - Скопируйте текст примера в какую-нибудь простую инструментальную программу, например XAMLPAD2009, предлагаемую вместе с исходным кодом к этой главе, или Kaxaml (http://kaxaml.com), хотя на момент написания книги последняя еще не была модернизирована для работы с WPF 4.
        // - Создайте WPF-проект в Visual Studio и замените содержимое главного окна Window или элемента Page текстом примера; иногда может понадобиться внести в код некоторые изменения.


        // Определение XAML
        // XAML – сравнительно простой декларативный язык программирования общего назначения, предназначенный для конструирования  инициализации объектов.
        // можно говорить о WPF XAML, о Silverlight XAML и о других типах XAML-файлов.
        // Функциональность XAML, недоступная из процедурного кода:
        // - Создание полного набора шаблонов. В процедурном коде можно создавать шаблоны с помощью класса FrameworkElementFactory, но выразительные возможности этого подхода ограничены.
        // - Использование конструкции x:Shared="False", заставляющей WPF возвращать новый экземпляр при каждом обращении к элементу из словаря ресурсов.
        // - Отложенное создание объектов внутри словаря ресурсов. Это важно для оптимизации производительности и доступно только с помощьюскомпилированного XAML-кода. 

        // Элементы и атрибуты
        // В спецификации XAML определены правила отображения пространств имен, типов, свойств и событий .NET на пространства имен, элементы и атрибуты XML.
        // XAML:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK"/>
        // C#:
        // System.Windows.Controls.Button b = new System.Windows.Controls.Button();
        // b.Content = "OK";
    
        // Изменим код создания кнопки, задав не только свойство Content, но и обработчик события Click.
        // XAML:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK" Click="button_Click"/>
        // C#:
        // System.Windows.Controls.Button b = new System.Windows.Controls.Button();
        // b.Click += new System.Windows.RoutedEventHandler(button_Click);
        // b.Content = "OK";

        // Порядок обработки свойств и событий
        // Во время выполнения обработчики событий присоединяются до установки свойств объектов, объявленных в XAML-коде (за исключением описанного ниже свойства Name, которое устанавливается сразу после конструирования объекта). Поэтому при генерации событий в ответ на установку свойств можно не думать о порядке записи атрибутов в XAML.
        // Установка нескольких свойств и присоединение нескольких обработчиков событий обычно производятся в порядке задания атрибутов свойств и событий в объектном элементе. К счастью, на практике этот порядок не важен, поскольку согласно принципам проектирования в .NET порядок установки свойств объекта класса не должен иметь значения, и то же самое относится к порядку присоединения обработчиков событий.

        // Пространства имен
        // Наименее очевидный аспект при сравнении XAML-кода с эквивалентным кодом на С# – отображение пространства имен XML http://schemas.microsoft.com/ winfx/2006/xaml/presentation на пространство имен .NET System.Windows. Controls. В действительности отображение на это и другие пространства имен WPF жестко зашито в сборках WPF, точнее в нескольких экземплярах атрибута XmlnsDefinitionAttribute.
        // Так, в XAML-файлах для WPF обычно указывается второе пространство имен с префиксом x (записывается в виде xmlns:x, а не просто xmlns): xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        // Это пространство имен языка XAML, которое отображается на типы в пространстве имен System.Windows.Markup;

        // Неявные пространства имен .NET
        // Чтобы код было проще читать, лучше объявлять наиболее часто используемое пространство имен XML (называемое также основным) без префикса, для всех дополнительных пространств имен выбирать короткие префиксы. 

        // В процессе развития образовалось несколько пространств имен WPF XML


        // Элементы свойств
        // XAML предлагает альтернативный (менее компактный) синтаксис для установки составных свойств – элементы свойств. Выглядит это следующим образом:
        // Теперь свойство Content устанавливается с помощью XML-элемента, а не XML- атрибута, а результат эквивалентен коду на С#. Точка в выражении Button. Content позволяет отличить элемент свойства от объектного элемента.
        // Элементы свойств всегда имеют вид ИмяТипа. ИмяСвойства и обязательно вложены в объектный элемент вида ИмяТипа.
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK" Background="White"/>
        // эквивалентно
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // OK
        // </Button.Content>
        // <Button.Background>
        // White
        // </Button.Background>
        // </Button>

        // Конвертеры типов
        // В таких случаях компилятор или анализатор XAML должен найти конвертер типа, который умеет преобразовывать строковое значение в нужный тип.
        // Использование конвертеров типов в процедурном коде
        // Поиск конвертеров типов
        // при установке свойства Background кнопки Button в XAML-коде применяется конвертер типа BrushConverter, поскольку свойство Background имеет тип System.Windows. Media.Brush, в определении которого задан следующий атрибут:
        //[TypeConverter(typeof(BrushConverter)), ...]
        //public abstract class Brush : ...
        //{
        //...
        //}
        // для установки свойства FontSize кнопки используется конвертер типа FontSizeConverter, потому что это свойство (определенное в базовом классе Control) снабжено следующим атрибутом:
        // [TypeConverter(typeof(FontSizeConverter)), ...]
        // public double FontSize
        // {
        // get { ... }
        // set { ... }
        // }

        // Расширения разметки
        // Если значение атрибута заключено в фигурные  скобки {}, то компилятор или анализатор XAML считает  его значение расширением разметки, а не обычной строкой (или чем-то, нуждающимся в конвертере типов)
        //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //Background="{x:Null}"
        //Height="{x:Static SystemParameters.IconHeight}"
        //Content="{Binding Path=Height, RelativeSource={RelativeSource Self}}"/>
        // Первый идентификатор в каждом заключенном в фигурные скобки значении – имя класса расширения разметки, который должен наследовать классу MarkupExtension.
        // По принятому соглашению имена таких классов оканчиваются словом Extension, но в XAML его можно опускать. В данном примере NullExtension (записано в виде x:Null) и StaticExtension (записано в виде x:Static) – классы из пространства имен System.Windows. Markup, поэтому для их поиска необходимо указывать префикс x.
        // синтаксис и использование расширений разметки в XAML очень напоминает способ определения атрибутов.

        // Экранирование фигурных скобок
        // Если строковое значение атрибута свойства начинается открывающей фигурной скобкой, то ее следует экранировать, чтобы анализатор не счел ее началом расширения разметки. Это можно сделать, поставив перед ней пустую пару фигурных скобок, как в следующем примере:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="{}{Это не расширение разметки!}"/>
        // В качестве альтернативы можно использовать синтаксис элемента свойства, поскольку в этом контексте фигурные скобки не имеют специального смысла.
        //<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //<Button.Content>
        //{Это не расширение
        //разметки!}
        //</Button.Content>
        //</Button>
        // Расширения разметки и процедурный код


        // Дочерние объектные элементы
        // Объектные элементы могут поддерживать наличие дочерних объектных элементов (а не только элементов свойств, которые с точки зрения XAML не являются дочерними). Объектный элемент может иметь потомков трех разных типов: значение свойства содержимого, элементы коллекции или значение, тип которого может быть преобразован в тип объектного элемента.
        
        // Свойство Content
        // В большинстве классов WPF имеется свойство (задаваемое с помощью атрибута), значением которого является содержимое данного XML-элемента. Оно называется свойством содержимого и в действительности представляет собой просто удобный способ сделать XAML-представление более компактным.
        // Для свойства Content кнопки Button имеется специальное соглашение (что очень кстати), поэтому описание
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
        // Content="OK"/>
        // можно представить в следующем виде:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // OK
        // </Button>
        // А составное содержимое Button, например
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // <Rectangle Height="40" Width="40" Fill="Black"/>
        // </Button.Content>
        // </Button>
        // можно переписать так:
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Rectangle Height="40" Width="40" Fill="Black"/>
        // </Button>
        // Нигде не требуется, чтобы свойство содержимого называлось именно Content; так, в классах ComboBox, ListBox и TabControl (все из пространства имен System. Windows. Controls) свойство содержимого названо Items. 

        // Элементы коллекций
        // Язык XAML позволяет добавлять элементы в два основных вида коллекций, поддерживающих индексирование: списки и словари.
        // Списки
        // Списком считается любая коллекция, в которой реализован интерфейс System.Collections.IList, например System.Collections.ArrayList и многочисленные классы коллекций, определенные в WPF
        // <ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <ListBox.Items>
        // <ListBoxItem Content="Item 1"/>
        // <ListBoxItem Content="Item 2"/>
        // </ListBox.Items>
        // </ListBox>
        // Далее, поскольку Items – свойство содержимого для ListBox, то XAML-код можно еще сократить:
        //<ListBox xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //<ListBoxItem Content="Item 1"/>
        //<ListBoxItem Content="Item 2"/>
        //</ListBox>
        
        // Словари
        // Коллекция System.Windows.ResourceDictionary используется в WPF очень часто, в чем мы убедимся в главе 12 «Ресурсы ». Этот класс реализует интерфейс System.Collections.IDictionary, а значит, поддерживает добавление, удаление и перечисление пар ключ/значение в процедурном коде, как любая хеш-таблица.
        // В XAML в любую коллекцию, реализующую интерфейс IDictionary, можно добавить пару ключ/значение.
        // <ResourceDictionary
        // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        // <Color x:Key="1" A="255" R="255" G="255" B="255"/>
        // <Color x:Key="2" A="0" R="0" G="0" B="0"/>
        // </ResourceDictionary>
        // Списки, словари и анализатор XAML2009

        // Еще о преобразовании типов
        // Потомком объектного элемента может быть обычный текст, как в следующем объявлении элемента SolidColorBrush на XAML:
        // <SolidColorBrush>White</SolidColorBrush>
        // Эта запись эквивалентна следующей:
        // <SolidColorBrush Color="White"/>
        // даже несмотря на то, что Color не описано как свойство содержимого.
        // В данном случае первый фрагмент работает потому, что существует конвертер типа, умеющий преобразовывать такие строки, как "White" (или "white", или "#FFFFFF") в объект типа SolidColorBrush.

        // Расширяемая часть XAML
        // Поскольку XAML предназначен для работы с системой типов .NET, то его можно использовать практически с любым объектом .NET (и даже с COM-объектами благодаря интероперабельности с COM), в том числе определенным вами. При этом совершенно неважно, относятся ли эти объекты к пользовательскому интерфейсу.
        // если в классе нет ни конструктора по умолчанию, ни полезных открытых свойств, то им нельзя будет напрямую воспользоваться в XAML
        // Сборки WPF помечены атрибутом XmlnsDefinitionAttribute, который отображает содержащиеся в них пространства имен .NET на пространство имен XML в XAML-файле
        // System.Collections.Hashtable h = new System.Collections.Hashtable();
        // h.Add("key1", 7);
        // h.Add("key2", 23);
        // А вот как его можно представить в XAML:
        // <collections:Hashtable
        //­­xmlns:collections="clr-namespace:System.Collections;assembly=mscorlib"
        //­­xmlns:sys="clr-namespace:System;assembly=mscorlib"
        //­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        //­­<sys:Int32 x:Key="key1">7</sys:Int32>
        //­­<sys:Int32 x:Key="key2">23</sys:Int32>
        //</collections:Hashtable>
        // Директива clr­namespace позволяет использовать пространство имен .NET непосредственно в XAML. 
        // - Дочерние элементы можно добавлять в родительскую хеш-таблицу Hashtable с помощью стандартного синтаксиса XAML x:key, поскольку Hashtable, как и другие классы коллекций в .NET Framework, реализует интерфейс IDicti­ona­ry начиная с версии 1.0.
        // - Тип System.Int32 можно использовать столь простым образом, поскольку уже существует конвертер типа, умеющий преобразовывать строку в целое число. Объясняется это тем, что конвертеры типов, поддерживаемые XAML, – всего лишь подклассы класса System.ComponentModel.TypeConverter, который также существует со времени версии .NET Framework 1.0. Это тот же механизм преобразования типов, что используется в Windows Forms (и позволяет, например, вводить в сетке свойств в Visual Studio строки, которые преобразуются в подходящий тип).

        // Правила обработки потомков объектных элементов в XAML
        // 1. Если тип реализует интерфейс IList, вызвать IList.Add для каждого дочернего элемента.
        // 2. Иначе, если тип реализует интерфейс IDictionary, вызвать IDictionary.Add для каждого дочернего элемента, используя в качестве ключа значение атрибута x:Key, а в качестве значения – сам элемент. (Правда, анализатор XAML2009 проверяет IDictionary раньше IList и поддерживает также другие интерфейсы коллекций, о чем упоминалось выше.)
        // 3. Иначе, если у родителя есть свойство содержимого (помеченное атрибутом System.Win­dows.Markup.ContentPropertyAttribute) и тип дочернего элемента совместим с этим свойством, считать дочерний элемент значением этого свойства.
        // 4. Иначе, если дочерний элемент является простым текстом и существует конвертер типа, который может преобразовать этот текст в тип родителя (и при этом для родителя не установлены никакие свойства), подать дочерний элемент на вход конвертера типа, а полученный результат считать экземпляром родителя.
        // 5. Иначе считать содержимое неизвестным, что может являться поводом для возбуждения исключения.


        // Сочетание XAML и процедурного кода
        // Загрузка и разбор XAML во время выполнения
        // В состав WPF входит анализатор XAML, работающий на этапе выполнения. Он представлен двумя классами в пространстве имен System.Win­dows.Markup:
        // Xaml­Reader и XamlWriter.

        // Класс XamlReader
        // Так, если XAML-файл MyWindow.xaml в текущем каталоге содержит в качестве корневого узла объект Window (подробно рассматриваемый в главе 7 «Структурирование и развертывание приложения»), то для загрузки и получения объекта Window можно использовать следующий код:
        // Window window = null;
        //using (FileStream fs = ­­new FileStream("MyWindow.xaml", FileMode.Open, FileAccess.Read))
        //{
        //­­// По­лу­чить кор­не­вой эле­мент. Мы зна­ем, что это Window
        //­­window = (Window)XamlReader.Load(fs);
        //}
        // Найти кнопку OK, перебирая дочерние элементы (мы
        // пользуемся априорными знаниями о структуре документа!)
        //StackPanel panel = (StackPanel)window.Content;
        //Button okButton = (Button)panel.Children[4];
        // К счастью, XAML поддерживает именование элементов, поэтому их можно находить и использовать посредством процедурного кода.
        // В классе XamlReader определен также метод экземпляра LoadAsync, который загружает и разбирает XAML-код асинхронно. Этим методом имеет смысл пользоваться, например, чтобы не «подвешивать» пользовательский интерфейс на время, пока загружается большой XAML-файл или производится загрузка по сети.
        // К тому же обработка производится асинхронно, только если в корневом узле XAML установлен атрибут x:SynchronousMode="Async"

        // Именование элементов XAML
        // В пространстве имен XAML определено ключевое слово Name, которое позволяет назначить имя любому элементу.
        // <Button x:Name="okButton">OK</Button>
        // Находим кнопку OK, зная только ее имя
        // Button okButton = (Button)window.FindName("okButton");
        // Метод FindName имеется не только в классе Window. Он определен в классах Frame­workElement и FrameworkContentElement, которые являются базовыми для многих важных классов WPF.
        // Синтаксис x:Name можно использовать для именования элементов, но в некоторых классах определено специальное свойство, которое можно рассматривать как имя элемента (оно назначается с помощью атрибута System.Win­dows.Markup.Run­ti­me­Name­Pro­per­tyAttribute). Например, в классах FrameworkElement и Frame­workCon­tent­Element имеется свойство Name, поэтому они помечены атрибутом Run­ti­meNa­meProperty("Name"). Это означает, что для таких элементов можно просто задать свойство Name, не используя синтаксис x:Name
        // Во всех версиях WPF для ссылки на именованный элемент можно использовать расширение разметки Binding в значении свойства:
        //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //­­<Label Target="{Binding ElementName=box}" Content="Enter _text:"/>
        //­­<TextBox Name="box"/>
        //</StackPanel>

        // WPF 4 включает новое, более простое расширение разметки Sys­tem.Win­dows.Markup.Reference, которое позволяет искать элементы на этапе синтаксического разбора, а не выполнения. Его можно использовать следующим образом:
        //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        //­­<Label Target="{x:Reference box}" Content="Enter _text:"/>
        //­­<TextBox Name="box"/>
        //</StackPanel>

        // Кроме того, если свойство помечено конвертером типа System.Win­dows.Markup.Name­Re­fe­ren­ceConverter (как в данном случае), то строковое имя неявно преобразуется в экземпляр, на который ведет ссылка:
        //<StackPanel xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        //­­<Label Target="box" Content="Enter _text:"/>
        //­­<TextBox Name="box"/>
        //</StackPanel>

        // Компиляция XAML
        // Компиляция XAML включает три шага: преобразование XAML-файла в специальный двоичный формат, включение результата в создаваемую сборку в качестве двоичного ресурса и создание инфраструктуры, которая автоматически подключает XAML к процедурному коду.
        // Однако в типичном случае, когда XAML-файл компилируется и сочетается с процедурным кодом, первым делом нужно задать подкласс для корневого элемента в XAMLфайле. Это можно сделать с помощью ключевого слова Class, определенного в пространстве имен XAML. Например:
        //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //x:Class="MyNamespace.MyWindow">
        //­­...
        //</Window>

        // Поддержка откомпилированного XAML-кода в произвольном .NET-языке
        // Для использования откомпилированного XAML-кода в произвольном .NET-совместимом языке программирования необходимо выполнение двух требований: наличие соответствующего поставщика CodeDom и целевого файла MSBiuld. Кроме того, желательна (но не обязательна) поддержка в языке частичных классов.
        //namespace MyNamespace
        //{
        //­­partial class MyWindow : Window
        //­­{
        //­­­­public MyWindow()
        //­­­­{
        //­­­­­­// Не­об­хо­ди­мо для за­груз­ки со­дер­жи­мо­го, оп­ре­де­лен­но­го в XAML­фай­ле!
        //­­­­­­InitializeComponent();
        //­­­­­­...
        //­­­­}
        //­­­­Здесь мо­гут быть лю­бые чле­ны...
        //­­}
        //}
        // Этот файл часто называют застраничным (code­behind file). Если в XAML-коде имеются ссылки на обработчики событий (в таких атрибутах событий, как Click для Button), то именно здесь их следует определить.
        // Ключевое слово partial в определении класса важно, поскольку реализация класса распределена по нескольким файлам. Если .NET-совместимый язык не поддерживает частичные классы (как, например, С++/CLI и J#), то в XAMLфайле необходимо задать также ключевое слово Subclass в корневом элементе:
        //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //x:Class="MyNamespace.MyWindow" x:Subclass="MyNamespace.MyWindow2">
        //­­...
        //</Window>
        // Таким образом, разделение реализации между двумя файлами моделируется с помощью наследования.
        // Visual Studio автоматически создает XAML-файл с атрибутом x:Class в корневом элементе и застраничный исходный файл, содержащий частичное определение класса, а также связывает их между собой, чтобы они правильно обрабатывались при построении проекта.
        // <ItemGroup>
        //­­<Page Include="MyWindow.xaml"/>
        //</ItemGroup>
        //<ItemGroup>
        //­­<Compile Include="MyWindow.xaml.cs">
        //­­­­<DependentUpon>MyWindow.xaml</DependentUpon>
        //­­­­<SubType>Code</SubType>
        //­­</Compile>
        //</ItemGroup>
        // Для такого проекта система построения генерирует несколько файлов в ходе обработке MyWindow.xaml, в том числе:
        // - BAML-файл (MyWindow.baml), который по умолчанию внедряется в сборку в качестве двоичного ресурса.
        // - С#-файл (MyWindow.g.cs), который компилируется и включается в сборку, как любой другой файл с исходным кодом.
        // Атрибут x:Class разрешается использовать только в компилируемых XAMLфайлах. Но иногда можно скомпилировать XAML-файл и без этого атрибута. Это просто означает, что соответствующий застраничный файл отсутствует, так что пользоваться средствами, нуждающимися в процедурном коде, нельзя. Поэтому добавление в проект Visual Studio XAML-файла без атрибута x:Class – хороший способ воспользоваться всеми преимуществами компиляции XAML в плане повышения производительности и удобства развертывания без создания ненужного застраничного файла.

        // BAML
        // Аббревиатура BAML расшифровывается как Binary Application Markup Language (Двоичный язык разметки приложений).
        // По существу, BAML – это деталь реализации процедуры компиляции XAML.

        // Когда-то здесь был CAML…

        // Генерируемый исходный код
        // В процессе компиляции XAML кое-какой процедурный код все же генерируется (если использовался атрибут x:Class), но это всего лишь «клей», аналогичный тому, что пришлось бы писать для загрузки и разбора независимого XAML-файла во время исполнения программы. Таким файлам присваивается суффикс вида .g.cs (или .g.vb), где g означает «сгенерированный» (generated).
        // Каждый сгенерированный исходный файл содержит частичное определение класса, указанного в атрибуте x:Class корневого объектного элемента. В нем находятся поля (по умолчанию internal) для каждого именованного элемента в XAML-файле, при этом в качестве имени поля используется имя элемента.
        // Там же находится метод InitializeComponent, который выполняет всю рутинную работу по загрузке внедренного BAML-ресурса, присваиванию полям экземпляров объектов, первоначально определенных в XAML-файле, и присоединению обработчиков событий (если они были специфицированы в XAML).
        // Нужно только не забыть вызвать метод InitializeComponent в конструкторе своего застраничного класса.

        // Не забывайте вызывать метод InitializeComponent в конструкторе своего застраничного класса!
        // все поля, представляющие именованные объектные элементы, будут равны null.

        // Процедурный код внутри XAML
        // Для этого предназначено ключевое слово Code из пространства имен XAML:
        //<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        //­­­­­­­­xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        //­­­­­­­­x:Class="MyNamespace.MyWindow">
        //­­<Button Click="button_Click">OK</Button>
        //<x:Code><![CDATA[
        //void button_Click(object sender, RoutedEventArgs e)
        //{
        //this.Close();
        //}
        //]]></x:Code>
        //</Window>
        // При компиляции такого XAML-файла содержимое элемента x:Code копируется в частичный класс, находящийся в .g.cs-файле. Отметим, что процедурный язык в XAML-файле не указывается; он определяется проектом, содержащим этот файл.
        // Так не нужно делать!
        
        // Можно ли BAML декомпилировать обратно в XAML?
        // можно вызвать статический метод System.Win­dows.Application.LoadComponent, который загружает нужный объект из BAML:
        //System.Uri uri = new System.Uri("/WpfApplication1;component/MyWindow.xaml", ­­System.UriKind.Relative);
        //Window window = (Window)Application.LoadComponent(uri);
        // На самом деле автоматически генерируемый Visual Studio метод InitializeComponent вызывает именно метод Appli­cati­on.LoadComponent для загрузки внедренного BAML-кода, правда, другой перегруженный вариант.
        // Имея корневой элемент, мы можем воспользоваться классом System.Win­dows.Markup.XamlWriter, чтобы получить XAML-представление этого элемента (а следовательно, и всех его потомков). Класс XamlWriter содержит пять перегруженных вариантов статического метода Save; самый простой принимает экземпляр объекта и возвращает соответствующий XAML-код в виде строки:
        // string xaml = XamlWriter.Save(window);

        // Введение в XAML2009
        // Полная поддержка универсальных классов
        // с#
        // public class PhotoCollection : ObservableCollection<Photo> { }
        // XAML:
        //<custom:PhotoCollection>
        //­­<custom:Photo .../>
        //­­<custom:Photo .../>
        //</custom:PhotoCollection>
        // В XAML2009 атрибут x:TypeArguments может употребляться в любом элементе, поэтому, скажем, объекты класса ObservableCollection<Photo> допустимо создавать непосредственно в XAML:
        //<collections:ObservableCollection TypeArguments="custom:Photo">
        //­­<custom:Photo .../>
        //­­<custom:Photo .../>
        //</collections:ObservableCollection>

        // Словарные ключи произвольного типа
        // В XAML2009 преобразование типов применяется и к значениям атрибута x:Key, поэтому в словарь можно добавлять значения с нестроковыми ключами, не прибегая к расширениям разметки. Например:
        //<collections:Dictionary x:TypeArguments="x:Int32, x:String">
        //­­<x:String x:Key="1">One</x:String>
        //­­<x:String x:Key="2">Two</x:String>
        //</collections:Dictionary>
        // Здесь предполагается, что collections отображается на пространство имен Sys­tem.Collections.Generic.

        // Отключение преобразования типов для нестроковых словарных ключей
        // Для обратной совместимости в классе XamlObjectWriter из XAML2009 имеется возможность отключить новый механизм автоматического преобразования типов. Это свойство XamlObjectWriterSettings.PreferUnconvertedDictionaryKeys. Принимая значение true, System.Xaml не будет конвертировать ключи, если словарь реализует неуниверсальный интерфейс IDictionary, при условии, что:
        // - System.Xaml уже потерпел неудачу при вызове метода IDictionary.Add для того же экземпляра, или
        // - словарь принадлежит известному типу .NET Framework, и System.Xaml точно знает, что для него необходимо преобразование.

        // Встроенные системные типы данных
        // В XAML2006 использовать встроенные типы данных .NET, например String или Int32, было неудобно, так как требовалось ссылаться на пространство имен System из сборки mscorlib; мы уже видели, как это выглядит:
        // <sys:Int32 xmlns:sys="clr­namespace:System;assembly=mscorlib">7</sys:Int32>
        // <x:Int32>7</x:Int32>

        // Создание объектов с помощью конструктора с аргументами
        // В XAML2009 появилось новое ключевое слово x:Arguments, которое позволяет задать один или несколько аргументов для передачи конструктору класса.
        // <sys:Version x:Arguments="4.0.30319.1"/>
        //<sys:Version>
        //<x:Arguments>
        //<x:Int32>4</x:Int32>
        //<x:Int32>0</x:Int32>
        //<x:Int32>30319</x:Int32>
        //<x:Int32>1</x:Int32>
        //</x:Arguments>
        //</sys:Version>

        // Создание экземпляров с помощью фабричных методов
        // С помощью нового ключевого слова x:FactoryMethod в XAML2009 можно создать экземпляр класса, вообще не имеющего открытых конструкторов. x:Facto­ry­Method позволяет указать произвольный открытый статический метод, который возвращает объект нужного типа. Например, в следующем XAML-коде используется объект типа Guid, возвращаемый статическим методом Guid.NewGuid:
        //<Label xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation
        //­­­­­­­xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml
        //­­­­­­­xmlns:sys="clr­namespace:System;assembly=mscorlib">
        //­­<sys:Guid x:FactoryMethod="sys:Guid.NewGuid"/>
        //</Label>

        //<Label xmlns=http://schemas.microsoft.com/winfx/2006/xaml/presentation
        //­­­­­­­xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml
        //­­­­­­­xmlns:sys="clr­namespace:System;assembly=mscorlib"
        //­­­­­­­xmlns:interop=
        //­­­­­­­­­"clr­namespace:System.Runtime.InteropServices;assembly=mscorlib">
        //<sys:Exception x:FactoryMethod="interop:Marshal.GetExceptionForHR">
        //<x:Arguments>
        //<x:Int32>0x80004001</x:Int32>
        //</x:Arguments>
        //</sys:Exception>
        //</Label>

        // Гибкость присоединения обработчиков событий
        // <Button Click="{custom:DelegateFinder Click}"/>

        // Определение новых свойств
        // в XAML2009 появилось два новых элемента – x:Members и x:Property, – которые позволяют определять дополнительные свойства непосредственно на XAML. но не приемлима с wpf.

        // Трюки с классами чтения и записи XAML
        // Мы уже видели, как читать и записывать XAML-код с помощью методов XamlReader.Load и XamlWriter.Save из пространства имен System.Windows.Markup.
        // Новая сборка System.Xaml содержит абстрактные базовые классы System.Xaml.XamlReader и System.Xaml.XamlWriter

        // Обзор
        // Класс XamlReader предназначен для генерации потока логических узлов XAML из произвольного источника
        // а XamlWriter на входе получает такой поток узлов и выводит его произвольным способом.
        // Считыватели (производные от System.Xaml.XamlReader):
        // - System.Xaml.XamlXmlReader – читает XML-код (из System.Xml.XmlReader, System.IO.TextReader, System.IO.Stream или из файла, заданного своим именем в виде строки).
        // - System.Xaml.XamlObjectReader – читает существующий граф объектов.
        // - System.Windows.Baml2006.Baml2006Reader – читает BAML-код (в WPF все еще используется формат 2006 года).
        // - System.Xaml.XamlBackgroundReader – обертывает другой объект XamlReader, реализуя двойную буферизацию, что позволяет считывателю работать не в том же потоке, что записыватель. 
        // Записыватели (производные от System.Xaml.XamlWriter):
        // - System.Xaml.XamlXmlWriter – записывает XML (используя System.Xml.XmlWriter, System.IO.TextWriter или Stream).
        // - System.Xaml.XamlObjectWriter – создает граф объектов.

        // Описанная в этом разделе функциональность применима главным образом к вариантам XAML, не относящимся к WPF!
        // Почему для чтения XAML-файлов лучше использовать XamlXmlReader, а не просто XmlReader? Разве XAML не является диалектом XML?
        // XamlXmlReader в действительности пользуется классом XmlReader, но дополнительно обеспечивает еще две важные возможности.
        // - Абстрагирует различия в представлениях XML, эквивалентных с точки зрения XAML.
        // - Порождает поток узлов XAML, совместимый с любым записывателем XAML и содержащий дополнительную информацию, которая отсутствует в исходном XML.
        // Первая возможность существенна для сокращения работы, связанной с чтением XAML. Например, следующие три фрагмента XAML-кода выражают одну и ту же концепцию – кнопку Button, для которой свойство Content содержит строку "ОК": 
        // <!-- Неявная установка свойства содержимого: -->
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // OK
        // </Button>
        // <-- Установка свойства с помощью синтаксиса элементов: -->
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
        // <Button.Content>
        // OK
        // </Button.Content>
        // </Button>
        // <!-- Установка свойства с помощью синтаксиса атрибутов: -->
        // <Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // Content="OK"/>

        // Циклы обработки узлов
        // Простой цикл обработки узлов
        // while (reader.Read())
        // {
        // writer.WriteNode(reader);
        // }

        // !!! check includes
        //public static object ConvertXmlStringToObjectGraph(string xmlString)
        //{
        //    // String -> TextReader -> XamlXmlReader
        //    using (TextReader textReader = new StringReader(xmlString))
        //    using (XamlXmlReader reader = new XamlXmlReader(textReader, System.Windows.Markup.XamlReader.GetWpfSchemaContext()))
        //    using (XamlObjectWriter writer = new XamlObjectWriter(reader.SchemaContext))
        //    {
        //        // Простой цикл обработки узлов
        //        while (reader.Read())
        //        {
        //            writer.WriteNode(reader);
        //        }
        //        // По завершении работы XamlObjectWriter здесь будет
        //        // находиться экземпляр корневого объекта
        //        return writer.Result;
        //    }
        //}

        // Чтение XAML
        // Самым важным свойством XamlReader, которое имеет смысл анализировать при записи узла в цикле, является NodeType, способное принимать одно из восьми перечисляемых значений:
        // - StartObject – считыватель позиционирован в начале явно представленного объекта, например открывающего тега XML-элемента или расширения разметки, указанного в качестве значения свойства.
        // - GetObject – считыватель позиционирован в начале неявного объекта, например коллекции, которая в XAML явно не представлена, хотя ее элементы присутствуют (как в примере ListBox, приведенном в разделе «Элементы коллекций»).
        // - EndObject – считыватель позиционирован в конце объекта (который ранее встречался в виде StartObject или GetObject). Каждому узлу StartObject или GetObject соответствует узел EndObject, который встретится в потоке позже.
        // - StartMember – считыватель позиционирован в начале некоторого члена объекта: свойства (присоединенного или нет), события (присоединенного или нет) либо директивы XAML, например x:Key. Каждый атрибут принадлежит некоторому родительскому объекту, поэтому узлу StartMember обязательно предшествует узел StartObject или GetObject. Отметим, что в XML неважно, задан ли член с помощью синтаксиса атрибута свойства или элемента свойства, – в любом случае он является членом, а не объектом.
        // - EndMember – считыватель позиционирован в конце члена объекта (для которого ранее встречался узел StartMember). Каждому узлу StartMember обязательно соответствует находящийся далее в потоке узел EndMember. 
        // - Value – считыватель позиционирован в начале значения члена объекта. Поскольку каждое значение ассоциировано с каким-то членом, то невозможно появление узла Value до соответствующего ему StartMember (и предшествующего ему узла StartObject или GetObject).
        // - NamespaceDeclaration – считыватель позиционирован на объявлении пространства имен XML (которое ассоциирует пространство имен с префиксом). Отметим, что такой узел непосредственно предшествует узлу StartObject, который «содержит » эти объявления. Это может показаться удивительным, но, учитывая, что объявления пространств имен предоставляют контекст даже для корневого элемента, важно, чтобы контекст был определен предварительно.
        // None – считыватель позиционирован на чем-то, не являющемся реальным узлом, например находящемся в конце файла. Узлы такого типа можно без опаски игнорировать.
        // В классе XamlReader определены четыре важных свойства, которые позволяют извлекать нужные данные об узле любого типа: Type, Member, Value и Namespace.
        // Когда свойство HasLineInfo равно true, можно получить данные о номере строки и позиции в ней, обратившись к свойствам LineNumber и LinePosition соответственно.

        // Откуда берутся экземпляры XamlType и XamlMember, обнаруживаемые считывателями XAML?
        // Эти классы представляют собой специфическую для XAML форму отражения .NET.
        // Разобрать Поток узлов XAML

        // Совместимость разметки

        // Запись в объекты
        // Производятся две модификации:
        // - Убираются все члены, относящиеся к событиям, так как если обработчик события не найден, то XamlObjectWriter возбуждает исключение, например,с таким сообщением: Failed to create a 'Click' from the text 'button_Click'. Отметим, что в классе XamlObjectWriter имеется свойство RootObjectInstance, которому можно присвоить объект с подходящими обработчиками событий, но проще всего эти события просто выкинуть – для инструмента экспериментирования с XAML такой подход вполне приемлем. Кроме этого, убирается атрибут x:Class, потому что в автономном XAML-коде он недопустим.
        // - Элемент Window конвертируется в Page. В главе 7 эти элементы рассматриваются подробно, но смысл в том, что элемент Window не может быть потомком другого элемента, а XAMLPAD2009 всегда пытается присоединить корневой объект в качестве непосредственного потомка своего собственного пользовательского интерфейса. Существуют и другие способы справиться с этой трудностью (например, увидев, что корневым элементом является Window, создавать из него окно), но описанной выше замены одного узла XAML другим для учебного примера достаточно.

        //public static object ConvertXmlStringToMorphedObjectGraph(string xmlString)
        //{
        //­­// String­­> TextReader­­> XamlXmlReader
        //­­using (TextReader textReader = new StringReader(xmlString))
        //­­using (XamlXmlReader reader = new XamlXmlReader(textReader,
        //­­­­­­­­­­­System.Win­dows.Markup.XamlReader.GetWpfSchemaContext()))
        //­­using (XamlObjectWriter writer = new XamlObjectWriter(reader.SchemaContext))
        //­­{
        //­­­­// Цикл об­ра­бот­ки уз­лов
        //­­­­while (reader.Read())
        //­­­­{
        //// Пропустить события и x:Class
        //if (reader.NodeType == XamlNodeType.StartMember &&
        //reader.Member.IsEvent || reader.Member == XamlLanguage.Class)
        //{
        //reader.Skip();
        //}
        //if (reader.NodeType == XamlNodeType.StartObject &&
        //reader.Type.UnderlyingType == typeof(Window))
        //{
        //// Преобразовать Window в Page
        //writer.WriteStartObject(new XamlType(typeof(Page),
        //reader.SchemaContext));
        //}
        //    else
        //{
        //// В противном случае вывести узел без изменений
        //writer.WriteNode(reader);
        //}
        //­­­­}
        //­­­­// По за­вер­ше­нии ра­бо­ты XamlObjectWriter здесь бу­дет
        //­­­­// эк­зем­п­ляр кор­не­во­го объ­ек­та
        //­­­­return writer.Result;
        //­­}
        //}

        // Запись в формате XML
        //public static string RewriteXaml(string xmlString)
        //{
        //­­// String­­> TextReader­­> XamlXmlReader
        //­­using (TextReader textReader = new StringReader(xmlString))
        //­­using (XamlXmlReader reader = new XamlXmlReader(textReader))
        //­­// TextWriter­­> XmlWriter­­> XamlXmlWriter
        //­­using (StringWriter textWriter = new StringWriter())
        //­­using (XmlWriter xmlWriter = XmlWriter.Create(textWriter,
        //­­­­­­­­­­­new XmlWriterSettings { Indent = true, OmitXmlDeclaration = true }))
        //­­using (XamlXmlWriter writer = new XamlXmlWriter(xmlWriter,
        //­­­­­­­­­­­reader.SchemaContext))
        //­­{
        //­­­­// Про­стой цикл об­ра­бот­ки уз­лов
        //­­­­while (reader.Read())
        //­­­­{
        //­­­­­­writer.WriteNode(reader);
        //­­­­}
        //­­­­return textWriter.ToString();
        //­­}
        //}

        // XamlServices
        // Чтобы пользователю приходилось писать меньше кода, самые распространенные случаи употребления средств чтения и записи XAML инкапсулированы в простые статические методы, определенные в классе System.Xaml.XamlSer­vices, а именно:
        // - Load – есть несколько перегруженных вариантов, принимающих имя файла в виде строки, объекты Stream, TextReader, XmlReader или XamlReader. Все они возвращают корень соответствующего графа объектов, как и прежний метод XamlReader.Load. Внутри Load вся работа производится объектами XamlXmlReader и XamlObjectWriter.
        // - Parse – как и Load, метод Parse возвращает корень графа объектов, но на входе принимает XAML-содержимое в виде строки. Внутри он создает из этой строки объект StringReader, затем XmlReader и наконец XamlXmlReader, от имени которого можно уже вызвать метод Load. Таким образом, Parse аналогичен методу ConvertXmlStringToObjectGraph
        // - Save – принимает на входе объект и, в зависимости от перегруженного варианта, возвращает его содержимое в виде строки, объекта Stream, Text­Writer, XmlWriter либо XamlWriter или даже сохраняет содержимое объекта прямо в текстовом файле. Внутри Save создает экземпляры Xaml­Object­Re­ader и XamlXmlWriter (если только ему уже не передан объект XamlWriter). Он присваивает свойствам Indent и OmitXmlDeclaration объекта XamlWriter значение true.
        // - Transform – выполняет тривиальный цикл обработки узлов, применяя считыватель и записыватель, которые ему переданы.

        //public static void Transform(XamlReader reader, XamlWriter writer)
        //{
        //­­IXamlLineInfo producer = reader as IXamlLineInfo;
        //­­IXamlLineInfoConsumer consumer = writer as IXamlLineInfoConsumer;
        //­­bool transferLineInfo = (producer != null && producer.HasLineInfo &&
        //­­­­­­­­­­­­­­­­­­­­­­­­­­­consumer != null && consumer.ShouldProvideLineInfo);
        //­­// Улуч­шен­ный цикл об­ра­бот­ки уз­лов
        //­­while (reader.Read())
        //­­{
        //­­­­// Передать информацию о строке
        //if (transferLineInfo && producer.LineNumber > 0)
        //consumer.SetLineInfo(producer.LineNumber, producer.LinePosition);
        //­­­­writer.WriteNode(reader);
        //­­}
        //}

        //public static object ConvertXmlStringToObjectGraph(string xmlString)
        //{
        //­­// String­­> TextReader­­> XamlXmlReader
        //­­using (TextReader textReader = new StringReader(xmlString))
        //­­using (XamlXmlReader reader = new XamlXmlReader(textReader,
        //­­­­­­­­­­­System.Win­dows.Markup.XamlReader.GetWpfSchemaContext()))
        //­­using (XamlObjectWriter writer = new XamlObjectWriter(reader.SchemaContext))
        //­­{
        //// Цикл обработки узлов
        //XamlServices.Transform(reader, writer);
        //­­
        //­­­­// По за­вер­ше­нии ра­бо­ты XamlObjectWriter здесь бу­дет
        //­­­­// эк­зем­п­ляр кор­не­во­го объ­ек­та
        //­­return writer.Result;
        //­­}
        //}

        // Берегитесь подводных камней XamlServices в WPF XAML!
        //public static string RewriteXaml(string xmlString)
        //{
        //­­return XamlServices.Save(XamlServices.Parse(xmlString));
        //}
        // приведенный код просто не работает, поскольку XamlObjectWriter в настоящее время не поддерживает WPF-объекты. Можно было бы вместо этого воспользоваться более старыми классами XamlReader и XamlWriter:
        //return System.Win­dows.Markup.XamlWriter.Save(­­System.Win­dows.Markup.XamlReader.Parse(xmlString));
        // Или, если нужна красивая печать:
        // using (StringWriter textWriter = new StringWriter())
        // using (XmlWriter xmlWriter = XmlWriter.Create(textWriter, new XmlWriterSettings { Indent = true, OmitXmlDeclaration = true }))
        //{
        //­­System.Win­dows.Markup.XamlWriter.Save(
        //­­­­System.Win­dows.Markup.XamlReader.Parse(xmlString), xmlWriter);
        //­­return textWriter.ToString();
        //}

        // Набор инструментов Microsoft XAML Toolkit построенный на основе классов из пространства имен System.Xaml, предлагает несколько очень интересных возможностей, например интеграцию XAML с инструментом FxCop и объектную модель документа XAML.

        // Ключевые слова XAML
        // Специальные атрибуты, определенные консорциумом W3C
        // xml:space для управления разбором пробелов и xml:lang для объявления языка и культуры документа
        // Ключевые слова из пространства имен языка XAML со стандартным префиксом x
        // x:AsyncRecords - Атрибут корневого элемента - Управляет размером блока при асинхронной загрузке XAML
        // X:Arguments - Атрибут или вложенный элемент - Задает аргумент (или несколько аргументов, если употребляется в качестве элемента), передаваемый конструктору элемента. При использовании в сочетании с x:FactoryMethod задает аргумент(ы) фабричного метода 
        // X:Boolean - Представляет класс System.Boolean
        // X:Byte - Представляет класс System.Byte
        // x:Char - Представляет класс System.Char
        // x:Class - Определяет для корневого элемента класс, производный от типа элемента. Может сопровождаться необязательным префиксом пространства имен .NET
        // x:ClassAttributes - Не используется в WPF; содержит атрибуты, относящиеся к Windows Workflow Foundation
        // x:ClassModifier - Определяет видимость класса, указанного в x:Class (по умолчанию открытого). Значение атрибута должно быть задано в терминах используемого процедурного языка (например public или inter­nal для С#)
        // x:Code - Окружает процедурный код, включаемый в класс, указанный в x:Class.
        // x:ConnectionId - Не для открытого применения
        // x:Decimal - Представляет System.Decimal
        // x:Double - Представляет System.Double
        // x:FactoryMethod - Определяет статический метод, вызываемый для получения экземпляра элемента вместо конструктора
        // x:FieldModifier - Определяет видимость поля, генерируемого для элемента (по умолчанию internal). Как и в случае x:ClassModifier, значение этого атрибута должно быть задано в терминах процедурного языка (например, public, private, … для С#)
        // x:Int16 - Представляет System.Int16
        // x:Int32 - Представляет System.Int32
        // x:Int64 - Представляет System.Int64
        // x:Key - Задает ключ элемента при добавлении в словарь родителя
        // x:Members - Определяет дополнительные члены корневого класса, заданного в x:Class
        // x:Name - Задает имя поля, генерируемого для элемента, по которому на него можно ссылаться из процедурного кода
        // x:Object - Представляет System.Object
        // x:Property - Определяет свойство внутри элемента x:Members
        // x:Shared - Может принимать значение false для запрета использования одного экземпляра ресурса в нескольких местах (см. главу 12)
        // x:Single - Представляет System.Single
        // x:String - Представляет System.String
        // x:Subclass - Определяет подкласс класса, заданного в x:Class, в котором хранится содержимое, определенное в XAML. В качестве необязательного префикса можно указать пространство имен .NET (используется с языками, не поддерживающими частичные классы)
        // x:SynchronousMode - Определяет, может ли содержимое XAML загружаться асинхронно
        // x:TimeSpan - Представляет System.TimeSpan
        // x:TypeArguments - Делает класс универсальным (как List<T>), конкретизируемым указанными аргументами (например, List<Int32> или List<String>). Может содержать список аргументов конкретизации через запятую. Типам, отсутствующим в пространстве имен по умолчанию, должен предшествовать префикс пространств имен XML
        // x:Uid - Помечает элемент идентификатором для локализации (см. главу 12)
        // x:Uri - Представляет System.Uri
        // x:XData - Произвольный остров данных XML, который остается непрозрачным для анализатора XAML

        // элементы пространства имен XAML, которые можно принять за ключевые слова, хотя на самом деле это расширения разметки (реальные классы .NET в пространстве имен System.Win­dows.Markup). Суффикс Extension в именах классов опущен, поскольку они обычно используются без суффикса.
        // x:Array - Представляет массив .NET. Потомками элемента x:Array являются элементы массива. В элементе должен присутствовать атрибут x:Type, определяющий тип массива
        // x:Null - Представляет ссылку null
        // x:Reference - Ссылка на именованный элемент. Должен присутствовать единственный позиционный параметр, задающий имя этого элемента
        // x:Static - Ссылка на любое статическое свойство, поле, константу или элемент перечисления, определенные в процедурном коде. При компиляции XAML это может быть даже неоткрытый член, определенный в той же сборке. Строка Member должна быть квалифицирована префиксом пространства имен XML, если тип не находится в пространстве имен по умолчанию
        // x:Type - Представляет экземпляр типа System.Type так же, как оператор typeof в С#. Строка TypeName должна быть квалифицирована префиксом пространства имен XML, если тип не находится в пространстве имен по умолчанию

        // Резюме
        // Возражение 1: XML слишком многословен, долго набирать
        // Возражение 2: системы, основанные на XML, низкопроизводительны


        //!!!
        // - Атрибут .net
        // - Расширение разметки
        // - Повторить основные элеметы XAML
        // - Пересмотреть еще раз главу, разобрать основы XAML
        // - Попробовать все примеры с главы, c# <-> XAML соответствия
        // - найти книгу с которой можно копипастить без редактирования
        // - FileStream
        // - using
        // - partial class
        // - x:TypeArguments
        // - XamlXmlReader
        // - XamlXmlWriter
        // - using
        // - x:FactoryMethod
    }
}
