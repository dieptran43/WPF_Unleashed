using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed._1_Basic_Information._3_WPFBasics
{
    /// <summary>
    /// Interaction logic for WPFBasics.xaml
    /// </summary>
    public partial class WPFBasics : Window
    {
        public WPFBasics()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            AboutWindow window = new AboutWindow();
            window.Show();
            this.Close();
        }

        // Обзор иерархии классов
        // 12 наиболее важных классов и соотношения между ними:
        // - Object - базовый класс, которому наследуют все остальные классы .NET, и единственный из представленных на рисунке, не имеющий прямого отношения к WPF.
        // - DispatcherObject - базовый класс, предназначенный для объектов, к которым можно обращаться только из того потока, где они были созданы. Большинство классов WPF наследуют DispatcherObject и, следовательно, принципиально небезопасны относительно потоков.
        // Слово Dispatcher в имени класса относится к реализованному в WPF варианту цикла обработки сообщений Win32, который мы еще будем обсуждать в главе 7.
        // - DependencyObject - базовый класс, предназначенный для объектов, поддерживающих свойства зависимости; это одна из центральных тем данной главы.
        // - Freezable - базовый класс для объектов, которые можно «заморозить в состоянии, разрешающем только чтение, - ради повышения производительности. К замороженным объектам можно безопасно обращаться из разных потоков, в отличие от объектов всех прочих классов, производных от DispatcberObject. Замороженный объект нельзя разморозить, однако можно клонировать, в результате чего получается незамороженная копия. По большей части объекты Freezable - это графические примитивы: кисти, перья, геометрические фигуры и классы анимации.
        // - Visual - базовый класс для объектов, имеющих двумерное визуальное представление. Визуальные объекты подробно рассматриваются в главе 15 «Двумерная графика».
        // - UlElement - базовый класс для двумерных визуальных объектов с поддержкой маршрутизации событий, привязки команд, компоновки и захвата фокуса. Эти механизмы обсуждаются в главе 5 «Компоновка с помощью панелей» и в главе 6 «События ввода: клавиатура, мышь, стилус и мультисенсорные устройства».
        // - Visual3D — базовый класс для объектов, имеющих трехмерное визуальное представление. Рассматривается в главе 16 «Трехмерная графика».
        // - UIElement3D - базовый класс для трехмерных визуальных объектов с поддержкой маршрутизации событий, привязки команд и захвата фокуса. Также рассматривается в главе 16.
        // - ContentElement - базовый класс, аналогичный UIElement, но предназначенный для тех частей содержимого, которые относятся к документам и потому не имеют собственного механизма визуализации. Чтобы объект типа ContentElement появился на экране, им должен владеть объект класса, производного от Visual. Часто для правильной визуализации объект ContentElement нуждается в нескольких объектах Visual (охватывающих несколько строк, столбцов и страниц).
        // - FrameworkElement - базовый класс, добавляющий поддержку стилей, привязки к данным, ресурсов и нескольких механизмов, общих для всех элементов управления в Windows, в частности всплывающих подсказок и контекстных меню.
        // - FrameworkContentElement - аналог FrameworkElement для содержимого. Этот класс рассматривается в главе 11 «Изображения, текст и другие элементы управления».
        // -  Control - базовый класс для таких хорошо знакомых элементов управления, как Button, ListBox и StatusBar. Класс Control добавляет к своему базовому классу FrameworkElement множество свойств, например Foreground, Background и FontSize, а также возможность тотального изменения стиля. Элементы управления WPF рассматриваются в части III.

        // Логические и визуальные деревья
        // В WPF пользовательский интерфейс представляет собой дерево объектов, которое называется логическим деревом.
        // поведение чуть ли не всех механизмов WPF (свойств, событий, ресурсов и т.д.) так или иначе связано с логическим деревом.
        // Например, значения свойств иногда автоматически распространяются вниз по дереву на дочерние элементы, а генерируемые события могут распространяться как вниз, так и вверх. Такое поведение свойств обсуждается ниже в этой главе, а поведение событий - в главе 6.
        // Полное дерево содержащее все визуализированные элементы, называется визуальным деревом.
        // В визуальном дереве представлены не все узлы логического дерева, а лишь элементы, производные от классов System.Windows.Media.Visual или System.Windows.Media.Visual3D.
        // Однако логическое и визуальное деревья можно обойти с помощью взаимодополняющих классов System.Windows.LogicalTreeHelper и System.Windows.Media.VisualTreeHelper.
        // Например, в классе Visual есть три защищенных члена (VisualParent, VisualChildrenCount и GetVisualChild) для доступа к родителю и потомкам визуального элемента.

        // Свойства зависимости
        // Свойство зависимости зависит от нескольких поставщиков, которые определяют его значение во время выполнения. Поставщиком может быть анимация, постоянно изменяющая значение свойства, родительский элемент, распространяющий значение своего свойства на потомков, и т. д. Пожалуй, наиболее существенной особенностью свойства зависимости является встроенная возможность генерировать уведомления об изменениях своего значения!
        // как свойства зависимости расширяют функциональность обычных свойств .NET в следующих направлениях:
        // - Уведомление об изменениях
        // - Наследование значений свойств
        // - Поддержка нескольких поставщиков
        // Например, применять стили и анимацию можно только к свойствам зависимости.

        // Реализация свойства зависимости
        // На практике свойство зависимости - это обычное свойство .NET, которое включено в состав дополнительной инфраструктуры, предоставляемой WPF.
        // Статическое поле IsDefaultProperty типа System.Windows.DependencyProperty и является свойством зависимости.
        // Во время выполнения обертывающие свойства .NET не вызываются при задании значений свойств зависимости в XAML!
        // Хотя компилятор XAML требует, чтобы обертывающее свойство присутствовало, на этапе выполнения WPF напрямую обращается к методам GetValue и SetValue.
        // Для реализации дополнительной логики предназначены методы обратного вызова, задаваемые при регистрации. Все стандартные обертывающие свойства в WPF следуют этому правилу, так что предупреждение адресовано авторам новых классов, содержащих свойства зависимости.
        // Но в действительности 89 из 111 открытых свойств класса Button и 82 из 104 открытых свойств класса Label - это свойства зависимости. Экономия.

        // Уведомление об изменении
        // При изменении значения свойства зависимости WPF может автоматически инициировать некоторые действия в соответствии с метаданными свойства. Это может быть перерисовка элементов, пересчет компоновки, обновление привязки к данным и многое другое. Одна из самых интересных черт встроенного механизма уведомления об изменении — триггеры свойств, которые позволяют ассоциировать с изменением запрограммированные вами действия без написания процедурного кода.
        // можно добавить mouseEnter, mouseLeave обработчики, либо же просто добавить триггер.
        // Триггер данных - разновидность триггера свойства, работающая для произвольных свойств .NET (а не только свойств зависимости); такие триггеры также рассматриваются в главе 14. Триггер события позволяет декларативно описывать, какие действия следует предпринять при генерации маршрутизируемого события.
        // Триггеры событий всегда подразумевают наличие анимации или звукового сопровождения, поэтому мы отложим их рассмотрение до главы 17 «Анимация».
        // ! Свойство Triggers класса FrameworkElement содержит допускающую чтение и запись коллекцию объектов типа TriggerBase (общий базовый класс всех трех типов триггеров) - на первый взгляд это очень простой способ присоединить триггеры свойств к таким элементам, как Button. Но, увы, эта коллекция может содержать только триггеры событий, так что ее название и тип обманчивы. Попытка добавить в коллекцию триггер свойства (или данных) приведет к исключению во время выполнения.

        // Наследование значений свойств
        // Словосочетание «наследование значений свойств» (или просто «наследование свойств») относится не к традиционному для объектно-ориентированного программирования наследованию классов, а к распространению значений свойств вдоль дерева элементов.
        // В большинстве случаев оба эти свойства распространяются вниз по дереву и наследуются всеми потомками.
        // Свойство FontSize первой метки Label не изменяется, потому что для нее явно указано значение FontSize 20, отменяющее унаследованное значение 30.
        // Отметим, что на текст в строке состояния StatusBar эти свойства не оказывают влияния, хотя класс StatusBar и поддерживает их, как, впрочем, любой элемент управления. В подобных случаях поведение механизма наследования свойств видоизменяется по двум причинам.
        // - Не всякое свойство зависимости принимает участие в наследовании свойств. (На самом деле желание подключиться к этому механизму выражается явно путем передачи флага FrameworkPropertyMetadataOptions.Inherits при вызове метода DependencyProperty.Register.)
        // - Могут существовать другие источники значения свойства с более высоким приоритетом (см. следующий раздел).
        // В данном случае наблюдаемое поведение обусловлено второй причиной. Некоторые элементы управления, в частности StatusBar, Menu и ToolTip, устанавливают для себя свойства шрифта в соответствии с текущими системными настройками. Это дает пользователю возможность настраивать шрифты привычным способом - с помощью панели управления.
        // Наследование значений свойств в других местах

        // Поддержка нескольких поставщиков
        // пять шагов, которые WPF применяет при определении окончательного значения каждого свойства зависимости. Все это происходи автоматически благодаря встроенному механизму уведомления об изменении значений свойств.
        // Шаг 1: определение базового значения.
        // 1. Локальное значение
        // 2. Триггер в шаблоне родителя
        // 3. Шаблон родителя
        // 4. Триггеры в стиле
        // 5. Триггеры в шаблоне
        // 6. Установщики стиля
        // 7. Триггеры стиля темы
        // 8. Установщики стиля темы
        // 9. Наследование значения свойства
        // 10. Значение по умолчанию
        // достаточно воспользоваться поставщиком с еще более высоким приоритетом, например, просто задать свойства локально в самом элементе StatusBar.
        // Если вы не можете понять, в какой именно момент данное свойство зависимости получает значение, то попробуйте воспользоваться статическим методом Depen- dencyPropertyHelper.GetValueSource.
        // Очистка локального значения
        // На самом деле надо было бы очистить локальное значение и дать WPF возможность установить его заново, получив значение от применимого поставщика с самым высоким приоритетом. К счастью, в классе DependencyObject имеется как раз такой механизм: метод ClearValue. В C# его можно вызвать от имени объекта Button b:
        // b.ClearValue(Button.ForegroundProperty);
        // После вызова ClearValue WPF пересчитывает базовое значение, просто не принимая во внимание локальное.
        // Шаг 2: вычисление
        // Если значение, полученное на шаге 1, представляет собой выражение (объект класса, производного от System. Windows. Expression), то WPF выполняет специальный шаг вычисления для преобразования выражения в конкретное значение.
        // Шаг 3: применение анимаций
        // Если работает одна или несколько анимаций, то любая из них способна изменить текущее значение свойства (получив на входе значение, вычисленное на шаге 2) или вообще подменить его. Таким образом, анимации (тема главы 17) могут отменить решения всех прочих поставщиков значений - даже локальных! Начинающие изучать WPF часто попадают в эту ловушку.
        // Шаг 4: приведение
        // После того как все поставщики значения свойства сказали свое слово, WPF передает почти окончательное значение делегату CoerceValueCallback, если таковой был указан при регистрации свойства зависимости.
        // Шаг 5: проверка
        // Наконец приведенное значение передается делегату ValidateValueCallback, если таковой был указан при регистрации свойства зависимости.
        // В версии WPF 4 в класс DependencyОbject добавлен новый метод SetCurrentValue. Он напрямую обновляет текущее значение, не изменяя его источник. (Приведение типа и проверка по-прежнему производятся.) Этот метод предназначен для элементов управления, которые устанавливают значения в ответ на действия пользователя.

        // Присоединенные свойства
        // Присоединенное свойство - это частный случай свойства зависимости, которое можно присоединять к произвольным объектам.
        // Предположим, что в примере диалогового окна About свойства FontSize и FontStyle заданы не для всего окна Window (как в листинге 3.4), а только для внутренней панели StackPanel, чтобы они наследовались лишь двумя кнопками Button. Однако перенос атрибутов свойств во внутренний элемент StackPanel работать не будет, потому что в классе StackPanel нет никаких свойств, относящихся к шрифту!
        // Поэтому необходимо использовать присоединенные свойства FontSize и FontStyle, определенные в классе TextElement.
        // В элементе StackPanel необходимо записать TextElement.FontSize и TextElement.FontStyle (а не просто FontSize и FontStyle), потому что в классе StackPanel таких свойств нет.
        // Когда анализатор или компилятор XAML встречает такой синтаксис, он предполагает, что в классе TextElement (который иногда называется поставщиком присоединенных свойств) имеются статические методы SetFontSize и SetFontStyle, которые умеют устанавливать соответствующие свойства.
        // Одной из любопытных особенностей абстракции присоединенных свойств является тот факт, что никакие свойств .NET в ней на самом деле не участвуют!
        // Как и в случае обертывающих свойств для обычных свойств зависимости, методы GetXXX и SetXXX не должны делать ничего, кроме вызова методов GetValue и SetValue соответственно.
        // О поставщиках присоединенных свойств
        // Самым странным в работе с присоединенными свойствами FontSize и FontStyle в листинге 3.5 является тот факт, что они определены не в классе Button и даже не в базовом классе Control, где определены обычные свойства зависимости FontSize и FontStyle, а в, казалось бы, совершенно не относящемся к делу классе TextElement (а также в классе TextBlock, которым можно было бы воспользоваться вместо TextElement)!
        // Присоединенные свойства и механизм расширяемости
        // Часто забывают, что присоединенные свойства позволяют присоединять произвольные данные даже к экземплярам запечатанных классов (а таких в WPF хватает)!
        // Это означает, что в процедурном коде любое свойство зависимости можно использовать как присоединенное.
        //GeometryModel3D model = new GeometryModel3D();
        //model.SetValue(FrameworkElement.TagProperty, "my custom data");
        // И это лишь один из многих способов расширения WPF без применения традиционного наследования.

        // Резюме


        //!!! - разобрать потом, если будет нужно.
        // - свойства зависимости;
        // - маршрутизации событий
        // - is, as +
        // - foreach
        // - универсальные типы .NET
        // - propdp
        // - триггеры свойств
        // - триггер данных
        // - триггер события
        // - маршрутизируемое событие
        // - запечатанный класс
    }
}
