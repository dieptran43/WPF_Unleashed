using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed.Testing
{
    /// <summary>
    /// Interaction logic for Testing.xaml
    /// </summary>
    public partial class Testing : Window
    {
        public Testing()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Panel.Panels window = new Panel.Panels();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Events.Events window = new Events.Events();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            MyApp window = new MyApp();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            Deployment.Deployment window = new Deployment.Deployment();
            window.Show();
        }

        private void Button_Click_4(object sender, RoutedEventArgs e)
        {
            OneChildControls.OneChildControls window = new OneChildControls.OneChildControls();
            window.Show();
        }

        private void Button_Click_5(object sender, RoutedEventArgs e)
        {
            ItemsControls.ItemsControls window = new ItemsControls.ItemsControls();
            window.Show();
        }


        // 4 Задание размера, положения и преобразований элементов


        // 5 Панели
        // StackPanel
        // В отсутствие присоединенных свойств единственный способ организовать дочерние элементы – воспользоваться свойством панели Orientation

        // WrapPanel
        // Панель WrapPanel похожа на StackPanel. Но помимо организации дочерних элементов в стопку она создает новые строки или столбцы, когда для одной стопки не хватает места.
        // В классе WrapPanel определены три свойства, контролирующие его поведение:
        // - Orientation – аналогично одноименному свойству StackPanel с тем отличием, что по умолчанию подразумевается значение Horizontal.
        // - ItemHeight – единая высота для всех дочерних элементов. Каким образом каждый потомок распоряжается этой высотой, зависит от значений его свойств VerticalAlignment, Height и пр. Элементы, ширина которых превышает ItemHeight, отсекаются.
        // - ItemWidth – единая ширина для всех дочерних элементов. Каким образом каждый потомок распоряжается этой шириной, зависит от значений его свойств HorizontalAlignment, Width и пр. Элементы, высота которых превышает ItemWidth, отсекаются.

        // DockPanel
        // Панель DockPanel дает простой способ пристыковки элемента к одной из сторон, растягивая его на всю имеющуюся ширину или высоту.
        // В классе DockPanel определено присоединенное свойство Dock, с помощью которого дочерние элементы могут управлять своим положением.
        // Оно может принимать четыре значения: Left (подразумевается по умолчанию, если свойство Dock не задано явно), Top, Right и Bottom.
        // Отметим, что у свойства Dock нет значения Fill, означающего, что нужно заполнить оставшееся место.
        // Вместо этого действует соглашение о том, что все оставшееся место отдается последнему дочернему элементу, добавленному в DockPanel, если только свойство LastChildFill не равно false.

        // Grid
        // По умолчанию свойства RowSpan и ColumnSpan равны 1, но могут принимать любое значение, большее или равное 1, – соответственно количество строк или столбцов, занимаемых данной ячейкой.
        // Такой автоматический выбор размера достигается путем присваивания свойствам Height и Width соответственно в элементах RowDefinition и ColumnDefinition специального значения Auto, нечувствительного к регистру букв.
        // панель Grid поддерживает три способа задания размера в элементах RowDefinition и ColumnDefinition:
        // - Абсолютный размер – числовое значение Height или Width означает, что размер задан в независимых от устройства пикселах
        // - Автоматический выбор размера – если Height или Width равно Auto, то дочерним элементам выделяется столько места, сколько необходимо, но не больше.
        // - Пропорциональное изменение размера – предусмотрен специальный синтаксис задания свойств Height и Width, позволяющий распределить имеющееся пространство поровну или в соответствии с заданными пропорциями 
        // Звездочка работает следующим образом:
        // - Если высота строки или ширина столбца равна *, то соответствующему структурному элементу выделяется все оставшееся место.
        // - Если размер * задан для нескольких строк или столбцов, то все оставшееся место делится между ними поровну.
        // - Перед символом * можно указывать коэффициент (например, 2* или 5.5*), тогда соответствующей строке или столбцу будет выделено пропорционально больше места, чем остальным строкам или столбцам, в размере которых присутствует символ *.
        // Интерактивное задание размера с помощью GridSplitter
        // В классах RowDefinitions и ColumnDefinitions имеется свойство SharedSizeGroup, позволяющее задать режим, при котором линейные размеры нескольких строк и/или столбцов будут оставаться одинаковыми даже в случае, когда размер любой из них изменяется в процессе выполнения программы
        // Свойство IsSharedSizeScope следует установить потому, что группы размеров могут применяться сразу к нескольким сеткам!

        // Обработка переполнения содержимого
        // Для ее разрешения можно применять различные стратегии:
        // • отсечение
        // • прокрутку
        // • масштабирование
        // • оборачивание
        // • обрезку

        // Отсечение
        // Отсечение дочерних элементов – это тот способ, который панели применяют по умолчанию, когда потомков становится слишком много.
        // Во всех классах, производных от UIElement, есть булевское свойство ClipToBounds, которое управляет тем, можно ли рисовать дочерние элементы вне границ родителя.
        // Однако, если внешний край элемента совпадает с внешним краем Window или Page, отсечение все равно производится.

        // Прокрутка
        // стоит поместить элемент внутрь элемента управления System.Windows.Controls.ScrollViewer, как он сразу же становится прокручиваемым.
        // В классе ScrollViewer имеется еще ряд свойств и методов для манипулирования из программы, но самыми важными являются свойства VerticalScrollBarVisibility и HorizontalScrollBarVisibility.
        // Оба они имеют тип перечисления ScrollBarVisibility, которое определяет четыре состояния полосы прокрутки:
        // - Visible – полоса прокрутки всегда присутствует, даже если она не нужна. Если необходимости в ней нет, то она выглядит неактивной и не реагирует на события ввода.
        // - Auto – полоса прокрутки видна, если содержимое нуждается в прокрутке в данном направлении. В противном случае полоса прокрутки отсутствует.
        // - Hidden – полоса прокрутки всегда невидима, но логически существует, то есть содержимое можно прокручивать клавишами со стрелками. Поэтому содержимое полностью доступно в данном направлении.
        // - Disabled – полоса прокрутки не только невидима, но и вообще не существует, то есть прокрутка невозможна ни с помощью клавиатуры, ни посредством мыши. В таком случае доступна только та часть содержимого, которая видна в пределах родителя.
        
        // Масштабирование
        // Класс Viewbox относится к так называемым декораторам, то есть панелеподобным классам, у которых может быть только один дочерний элемент.
        // Но у него также имеется свойство Stretch, позволяющее указать, как в занимаемой области должен масштабироваться единственный дочерний элемент.
        // Это свойство имеет тип перечисления System.Windows.Media.Stretch и может принимать следующие значения:
        // - None – масштабирование не производится вовсе. Результат такой же, как если бы Viewbox вообще не было.
        // - Fill – размеры дочернего элемента устанавливаются такими же, как размеры самого Viewbox. Поэтому отношение сторон дочернего элемента может не сохраняться.
        // - Uniform – дочерний элемент масштабируется так, чтобы он целиком поместился внутри Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении останется пустое место. Этот вариант подразумевается по умолчанию.
        // - UniformToFill – дочерний элемент масштабируется так, чтобы он целиком заполнял Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении содержимое будет отсечено.
        // Второе свойство Viewbox позволяет указать, какие операции разрешены: только уменьшение содержимого, только увеличение или и то и другое.
        // Оно называется StretchDirection, имеет тип перечисления System.Windows.Controls.StretchDirection и может принимать следующие значения:
        // - UpOnly – увеличивает содержимое, если необходимо. Если содержимое уже слишком велико, то Viewbox оставляет текущий размер без изменения.
        // - DownOnly – уменьшает содержимое, если необходимо. Если содержимое уже достаточно мало, то Viewbox оставляет текущий размер без изменения.
        // - Both – увеличивает или уменьшает содержимое в соответствии с заданным значением описанного выше свойства Stretch. Этот вариант подразумевается по умолчанию.

        // Все вместе: создание сворачиваемой, стыкуемой, изменяющей размер панели
        // Все три сетки помещены (куда бы вы думали?) в сетку с одной строкой и одним столбцом, чтобы они могли перекрывать друг друга и вместе с тем растягиваться, занимая все отведенное им место.
        // Z-порядок слоя 0 всегда наименьший, но Z-порядок двух остальных слоев может меняться так, чтобы текущая непристыкованная панель всегда была наверху.


        // 6 События ввода: клавиатура, мышь, стилус и мультисенсорные устройства
        // Маршрутизируемые события
        // - Tunneling – событие сначала возникает в корне дерева, а потом опускается вниз по дереву, заново возникая в каждом элементе на пути к источнику, включая его самого (если туннелирование не будет прервано по дороге в результате пометки события как обработанного)
        // - Bubbling – событие сначала возникает в элементе-источнике, а затем поднимается вверх по дереву, заново возникая в каждом элементе на пути к корню, включая сам корень (если всплытие не будет прервано по дороге в результате пометки события как обработанного)
        // - Direct – событие возникает только в элементе-источнике. Точно так же ведут себя обычные события .NET; различие лишь в том, что к маршрутизируемому событию применяются и другие механизмы, в частности триггеры событий
        // Сигнатуры обработчиков маршрутизируемых событий устроены так же, как сигнатуры всех обработчиков событий в .NET: первый параметр – объект типа System.Object, который обычно называют sender, второй – экземпляр класса, производного от System.EventArgs.
        // Параметр e является объектом класса RoutedEventArgs – подкласса EventArgs, обладающего следующими полезными свойствами:
        // - Source – элемент логического дерева, первоначально сгенерировавший событие.
        // - OriginalSource – элемент визуального дерева, первоначально сгенерировавший событие (например, в случае стандартной кнопки Button это будет дочерний элемент TextBlock или ButtonChrome). 
        // - Handled – булевский флаг, которому можно присвоить значение true и тем самым пометить, что событие обработано. Именно таким способом прерывается туннелирование и всплытие.
        // - RoutedEvent – сам объект маршрутизированного события (например, Button. ClickEvent), который может быть полезен для различения событий в случае, когда один и тот же обработчик используется для обработки разных событий.

        // Маршрутизируемые события в действии
        // Туннелируемые события легко распознать, потому что по принятому соглашению их имена начинаются со слова Preview. Такое событие – также по соглашению – генерируется непосредственно перед парным ему всплывающим.
        // Например, туннелируемое событие PreviewMouseMove генерируется перед всплывающим событием MouseMove.
        // Идея, стоящая за такими парами событий, заключается в том, чтобы дать элементам возможность отменить или иным способом модифицировать событие, которое еще только произойдет.
        // - Window не получает событие MouseRightButtonDown, если щелкнуть по любому элементу списка ListBoxItem. Дело в том, что ListBoxItem сам обрабатывает это событие, равно как и MouseLeftButtonDown (и прерывает всплытие), – это нужно ему для реализации выбора элементов.
        // - Window получает событие MouseRightButtonDown при щелчке по кнопке Button, но никаких изменений во внешнем виде рамкине происходит. Это объясняется структурой стандартного визуального дерева Button. В отличие от элементов Window, Label, ListBox, ListBoxItem и StatusBar, в визуальном дереве Button нет элемента Border.
        // Присоединенные события

        // Перетаскивание
        // Во всех подклассах UIElement определены события для работы с перетаскиванием:
        // - DragEnter, DragOver, DragLeave, а также PreviewDragEnter, PreviewDragOver и PreviewDragLeave
        // - Drop и PreviewDrop
        // - QueryContinueDrag и PreviewQueryContinueDrag
        // Это перетаскивание элемента в буфер обмена и бросание содержимого буфера на элемент в стиле Win32, а не перетаскивание и бросание самих элементов.
        // Элемент может принять участие в перетаскивании, установив значение true для свойства AllowDrop.
        // Обработчикам событий из первых двух наборов передается объект типа DragEventArgs, содержащий следующие свойства и методы:
        // - GetPosition – такой же метод, как в классе MouseEventArgs
        // - Data – свойство типа IDataObject, представляющее перетаскиваемый или бросаемый объект буфера обмена Win32
        // - Effects и AllowedEffects – битовое перечисление DragDropEffects, допускающее произвольную комбинацию флагов Copy, Move, Link, Scroll, All и None
        // - KeyStates – еще одно битовое перечисление (DragDropKeyStates), показывающее, какие кнопки мыши или клавиши-модификаторы были нажаты во время перетаскивания или бросания: LeftMouseButton, RightMouseButton, MiddleMouseButton, ShiftKey, ControlKey, AltKey или None
        // События QueryContinueDrag и PreviewQueryContinueDrag генерируются, если во время перетаскивания изменяется состояние клавиатуры или какой-нибудь кнопки мыши.
        // Это позволяет обработчику без труда отменить всю операцию.
        // Обработчикам этих событий передается объект класса QueryContinueDragEventArgs, имеющий следующие свойства:
        // - KeyStates – аналогично одноименному свойству класса DragEventArgs
        // - EscapePressed – отдельное булевское свойство, показывающее, была ли нажата клавиша Esc
        // Action – свойство, которое обработчик может установить, чтобы определить судьбу операции перетаскивания; принадлежит перечислению DragAction и принимает значение Continue, Drop или Cancel
        
        // Захват мыши
        // К счастью, WPF позволяет любому элементу UIElement в любой момент захватить или освободить мышь.
        // Когда элемент захватил мышь, он получает все события мыши, даже если указатель оказывается вне занимаемой им области.
        // После освобождения мыши поведение событий возвращается в нормальное русло. Для захвата и освобождения мыши предназначены два метода классаUIElement: CaptureMouse и ReleaseMouseCapture.
        // И, разумеется, есть ряд свойств и событий, сообщающих о состоянии захвата мыши, точнее, свойства IsMouseCaptured и IsMouseCaptureWithin и события GotMouseCapture, LostMouseCapture, IsMouseCaptureChanged и IsMouseCaptureWithinChanged.
        // Поэтому для реализации перетаскивания необходимо захватить мышь в обработчике MouseLeftButtonDown и освободить ее в обработчике MouseLeftButtonUp.

        // Команды
        // Мощь механизма команд основывается на трех основных особенностях:
        // - В WPF определено много встроенных команд.
        // - В команды встроена автоматическая поддержка жестов ввода (например, сочетаний клавиш).
        // - Встроенное поведение некоторых элементов управления WPF уже ориентировано на те или иные команды.

        // Встроенные команды
        // Командой называется любой объект, реализующий интерфейс ICommand (из пространства имен System.Windows.Input), в котором объявлены три простых члена:
        // - Execute – метод, который выполняет характерную для команды логику
        // - CanExecute – метод, который возвращает true, если команда активирована, и false, если она деактивирована
        // - CanExecuteChanged – событие, которое генерируется при изменении значения CanExecute
        // Встроенные в WPF команды доступны в виде статических свойств пяти разных классов:
        // - ApplicationCommands – Close, Copy, Cut, Delete, Find, Help, New, Open, Paste, Print,
        // PrintPreview, Properties, Redo, Replace, Save, SaveAs, SelectAll, Stop, Undo и др.
        // - ComponentCommands – MoveDown, MoveLeft, MoveRight, MoveUp, ScrollByLine, ScrollPageDown,
        // ScrollPageLeft, ScrollPageRight, ScrollPageUp, SelectToEnd, SelectToHome,
        // SelectToPageDown, SelectToPageUp и др.
        // - MediaCommands – ChannelDown, ChannelUp, DecreaseVolume, FastForward, IncreaseVolume,
        // MuteVolume, NextTrack, Pause, Play, PreviousTrack, Record, Rewind, Select, Stop и др.
        // - NavigationCommands – BrowseBack, BrowseForward, BrowseHome, BrowseStop, Favorites,
        // FirstPage, GoToPage, LastPage, NextPage, PreviousPage, Refresh, Search, Zoom и др.
        // - EditingCommands – AlignCenter, AlignJustify, AlignLeft, AlignRight, CorrectSpellingError,
        // DecreaseFontSize, DecreaseIndentation, EnterLineBreak, EnterParagraphBreak,
        // IgnoreSpellingError, IncreaseFontSize, IncreaseIndentation, MoveDownByLine,
        // MoveDownByPage, MoveDownByParagraph, MoveLeftByCharacter, MoveLeftByWord,
        // MoveRightByCharacter, MoveRightByWord и др.

        // Элементы управления со встроенными привязками к командам


        // 7 Структурирование и развертывание приложения
        
        // Класс Window
        // Если некое окно хочет сделать другое окно дочерним, оно должно записать в свойство Owner (типа Window) последнего ссылку на себя, но только после того, как родитель уже был показан на экране.
        // Перебрать дочерние окна позволяет доступное только для чтения свойство OwnedWindows.
        // По принятому соглашению управляемые классы содержат защищенные методы OnEventName, по одному для каждого события

        // Класс Application
        // Метод Application.Run
        // [STAThread]
        // public static void Main()
        // {
        //     Application app = new Application();
        //     MainWindow window = new MainWindow();
        //     window.Show();
        //     app.Run(window);
        // }
        // В классе Application есть также очень полезное свойство-коллекция Properties.
        // Как и состояние приложенияили сеанса в ASP.NET, это словарь, предназначенный для удобного хранения произвольных данных(в виде пар ключ/значение), общих для различных окон или других объектов.
        // Например, в приложении Photo Gallery так хранится имя файла текущей выбранной фотографии:
        // myApplication.Properties["CurrentPhotoFilename"] = filename;
        // А получить к нему доступ можно следующим образом:
        // string filename = myApplication.Properties["CurrentPhotoFilename"] as string;
        // Как в WPF создать приложение, которое может существовать в единственном экземпляре?
        // bool mutexIsNew;
        // using (System.Threading.Mutex m = new System.Threading.Mutex(true, uniqueName, out mutexIsNew))
        // {
        // if (mutexIsNew)
        // Это первый экземпляр, запускаем приложение.
        // else
        // Экземпляр уже работает. Выходим!
        // }

        // Диалоговые окна

        // Сохранение и восстановление состояния приложения

        // Страницы и их навигационные контейнеры
        // Элементы Page могут располагаться в одном из двух встроенных навигационных контейнеров: NavigationWindow или Frame.
        // По умолчанию вдоль верхнего края NavigationWindow располагается панель с кнопками Назад/Вперед, а во фрейме ее нет, но в обоих случаях панель можно добавить или убрать с помощью свойства ShowsNavigationUI, содержащегося внутри страницы Page.
        // Кроме того, в классе NavigationWindow имеется свойство ShowsNavigationUI, а в классе Frame – свойство NavigationUIVisibility, оба они позволяют показать или скрыть эту панель вне зависимости от настроек Page.
        // Элемент Page может взаимодействовать со своим навигационным контейнером с помощью класса NavigationService.
        // Чтобы получить экземпляр NavigationService, следует вызвать статический метод NavigationService.GetNavigationService, передав ему экземпляр Page.
        // Но можно поступить и проще, обратившись к свойству NavigationService объекта Page.
        // this.NavigationService.Title = "Main Photo Gallery Page";
        // this.NavigationService.Refresh();

        // Переходы между страницами
        // Есть три основных способа навигации:
        // - Посредством метода Navigate
        // - С помощью гиперссылок (объектов Hyperlink)
        // - С помощью журнала

        // Вызов метода Navigate
        // Перейти к экземпляру страницы 
        // PhotoPage nextPage = new PhotoPage();
        // this.NavigationService.Navigate(nextPage);
        // Или перейти на страницу с заданным URI
        // this.NavigationService.Navigate(new Uri("PhotoPage.xaml", UriKind.Relative));
        
        // Представление метода Navigate в виде двух свойств
        // Чтобы перейти к объекту Page, достаточно установить свойство Content:
        // this.NavigationService.Content = nextPage;
        // this.NavigationService.Source = new Uri("PhotoPage.xaml", UriKind.Relative);

        // Использование элемента Hyperlink
        // Для простых схем навигации в WPF имеется элемент Hyperlink, который ведет себя во многом аналогично гиперссылкам в HTML.
        // <TextBlock>
        // Click <Hyperlink NavigateUri="PhotoPage.xaml">here</Hyperlink> to view the photo.
        // </TextBlock>
        // Совет
        // Если вам нужна гибкость программной навигации в сочетании с удобными средствами автоматического форматирования текста, предоставляемыми классом Hyperlink, то можете указать в Hyperlink фиктивное значение свойства NavigateUri, а потом в обработчике события Click этого элемента вызвать метод Navigate, задав нужный адрес перехода.
        // Совет
        // Класс Hyperlink поддерживает и дополнительные возможности – как и гиперссылки в HTML.
        // Например, для перехода в конкретный фрейм Frame в случае, когда фреймов несколько, следует присвоить свойству TargetName элемента Hyperlink имя нужного фрейма.
        // Чтобы перейти к определенному месту внутри страницы Page (как в HTML-якорях, обозначаемых символом #), достаточно дописать в конец URI символ # и имя любого элемента на целевой странице.
        // в качестве значения HREF задать какое-нибудь фиктивное значение и написать обработчик события Navigating, в котором динамически изменить цель, вызвав метод Navigate самостоятельно.

        // Использование журнала
        // Отражение навигации в журнале
        // Назад - Помещает текущую страницу в стек прямых переходов, извлекает страницу из стека обратных переходов и переходит на нее
        // Вперед - Помещает текущую страницу в стек обратных переходов, извлекает страницу из стека прямых переходов и переходит на нее
        // Любая другая навигация - Помещает текущую страницу в стек обратных переходов и опустошает стек прямых переходов
        // Действия перехода назад и вперед могут быть инициированы как пользователем, так и программой – путем вызова методов GoBack и GoForward навигационного контейнера (предварительно вызвав соответственно метод CanGoBack или CanGoForward, чтобы избежать исключения в результате попытки извлечения из пустого стека).
        // В объекте NavigationWindow журнал есть всегда, тогда как в объекте Frame собственного журнала может и не быть; это зависит от его свойства JournalOwnership, которое может принимать следующие значения:
        // - OwnsJournal – у фрейма есть свой журнал.
        // - UsesParentJournal – история хранится в журнале родительского контейнера или не хранится вовсе, если у родителя нет журнала.
        // - Automatic – эквивалентно UsesParentJournal, если фрейм содержится в любом из двух навигационных контейнеров (NavigationWindow или Frame), в противном случае эквивалентно OwnsJournal. Это значение по умолчанию.
        // Если у фрейма есть собственный журнал, он получает также встроенные кнопки навигации. Если они вам не нужны, присвойте свойству NavigationUIVisibility значение Hidden.
        // СОВЕТ
        // В случае перехода на страницу Page с помощью URI (неважно, путем вызова метода Navigate или посредством гиперссылки Hyperlink) создается новый экземпляр Page, даже если вы уже посещали эту страницу.
        // Поэтому, если требуется, чтобы страница «запоминала» свои данные, необходимо хранить состояния отдельно (например, в статических переменных или в словаре Application.Properties). (При вызове варианта Navigate, принимающего экземпляр Page, вы, разумеется, вольны сами решать, передать ли ему новый или старый объект.)
        // Однако в случае навигации по журналу можно установить режим принудительного использования одного и того же объекта Page, присвоив его присоединенному свойству JournalEntry.KeepAlive значение true.
        // Совет
        // Объект Page может потребовать не заносить себя в журнал, присвоив своему свойству RemoveFromJournal значение true.
        // Это имеет смысл для страниц, являющихся частью  некоторой последовательности шагов, которые нельзя открывать в произвольном порядке после завершения операции.

        // События навигации
        // Вне зависимости от того, как инициирована навигация – путем вызова метода Navigate, с помощью гиперссылок Hyperlink или по журналу, – она всегда производится асинхронно.
        // В процессе навигации генерируется ряд событий, позволяющих сообщать пользователю подробную информацию или даже прервать навигацию.
        // События навигации, возникающие при загрузке первой страницы:
        // Navigation Container: Initialized -> Navigating -> NavigationProgress -> Loading -> first page initialized -> Navigated -> LoadCompleted -> first page loaded.
        // События навигации, возникающие при переходе от одной страницы к другой:
        // Navigation Container: Navigating -> NavigationProgress -> Loading -> second page Initialized -> first page unloaded -> Navigated -> LoadCompleted -> second page Loaded.
        
        // Передача данных между страницами
        
        // Передача данных странице
        // WPF поддерживает схему, аналогичную параметрам URL, с помощью перегруженных вариантов метода Navigate, которые принимают дополнительный параметр типа Object.
        // int photoId = 10;
        // Перейти к экземпляру Page
        // PhotoPage nextPage = new PhotoPage();
        // this.NavigationService.Navigate(nextPage, photoId);
        // Или перейти к странице по URI
        // this.NavigationService.Navigate(
        // new Uri("PhotoPage.xaml", UriKind.Relative), photoId);

        // Чтобы целевая страница могла получить данные, она должна обработать событие LoadCompleted навигационного контейнера и опросить свойство ExtraData аргумента события:
        // this.NavigationService.LoadCompleted += new LoadCompletedEventHandler(container_LoadCompleted);
        // void container_LoadCompleted(object sender, NavigationEventArgs e)
        // {
        // if (e.ExtraData != null)
        // LoadPhoto((int)e.ExtraData);
        // }
        // Есть и более простой метод:
        // int photoId = 10;
        // Перейти к экземпляру Page
        // PhotoPage nextPage = new PhotoPage(photoId);
        // this.NavigationService.Navigate(nextPage);
        // Третий способ – организовать глобальное обобществление данных с помощью коллекции Properties объекта Application.
        // Такой подход может оказаться удобным, когда нужно сделать данные доступными нескольким страницам (а не просто передать от одной страницыдругой).
        // Однако недостатком, как и в первом случае, является отсутствие строгой типизации.

        // Возврат данных от страницы с помощью PageFunction
        // Классический пример – страница настроек.
        // Достигается это с помощью класса с забавным названием PageFunction.
        // <PageFunction
        // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        // xmlns:sys="clr-namespace:System;assembly=mscorlib"
        // x:Class="MyProject.PageFunction1"
        // x:TypeArguments="sys:String"
        // Title="PageFunction1">
        // <Grid>
        // </Grid>
        // </PageFunction>

        // Поскольку PageFunction – подкласс Page, то на элемент этого типа можно переходить точно так же, как на любую другую страницу:
        // PageFunction1 nextPage = new PageFunction1<string>();
        // this.NavigationService.Navigate(nextPage);
        // Для получения возвращенного значения исходная страница должна обработать событие Return объекта PageFunction:
        // nextPage.Return += new ReturnEventHandler<string>(nextPage_Return);
        // ...
        // void nextPage_Return(object sender, ReturnEventArgs<string> e)
        // {
        // string returnValue = e.Result;
        // }
        // Страница, производная от PageFunction, может вернуть данные, обернув их типом ReturnEventArgs и вызвав метод OnReturn, унаследованный от базового класса PageFunction:
        // OnReturn(new ReturnEventArgs<string>("the data"));

        // Приложения-гаджеты

        // XAML-приложения для браузера


        // 8 Особенности Windows 7
        // В .NET для проверки версии операционной системы можно использовать свойство System.Environment.OSVersion. 
        // if (System.Environment.OSVersion.Version.Major >= 6)
        // Windows Vista или более поздняя, используем TaskDialog
        // else
        // Младше Windows Vista, используем MessageBox


        // 9 Однодетные элементы управления
        // - Button
        // - RepeatButton
        // - ToggleButton
        // - CheckBox
        // - RadioButton

        // Класс Button
        // Класс Button в WPF добавляет к тому, что уже дает ButtonBase, два простых понятия: кнопка отмены и кнопка по умолчанию.
        // Оба удобны для применения в диалоговых окнах. Если для некоторой кнопки, находящейся внутри диалогового окна(ShowDialog),
        // свойство Button.IsCancel равно true, то при нажатии этой кнопки окно автоматически закрывается и свойство DialogResult принимает значение false.

        // Класс RepeatButton
        // Класс RepeatButton ведет себя так же, как Button, но продолжает генерировать событие Click до тех пор, пока кнопка нажата.
        // (Кроме того, в нем нет понятия кнопки по умолчанию и кнопки отмены, так как он наследует непосредственно ButtonBase.)

        // Класс ToggleButton
        // ToggleButton – это «залипающая» кнопка, которая сохраняет свое состояние после нажатия (понятия кнопки по умолчанию и кнопки отмены для нее тоже не определены).
        // При первом щелчке свойство IsChecked становится равным true, при следующем – возвращается в false.
        
        // Класс CheckBox
        // - У него имеется единственный вложенный элемент, задаваемый в разметке (в отличие от стандартного флажка).
        // - Для него определено понятие «нажатия» с помощьюмыши или клавиатуры.
        // - После нажатия он сохраняет состояние: отмечен или сброшен.
        // - Он поддерживает трехпозиционный режим, в котором состояние циклически переключается между вариантами «отмечен», «неизвестно» и «сброшен».
        // Если флажок CheckBox владеет фокусом, то нажатие клавиши плюс (+) отмечает его, а клавиши минус (–) – сбрасывает! Отметим, что это работает, только если свойство IsThreeState равно false.

        // Класс RadioButton
        // RadioButton – еще один элемент управления, производный от ToggleButton. Его уникальная особенность заключается в поддержке взаимного исключения.
        // Если несколько элементов RadioButton помещены в одну группу, то в любой момент времени отмеченным может быть только один из них.
        // Таким образом, элемент RadioButton предназначен для формулирования вопроса, имеющего несколько вариантов ответа.
        // По умолчанию все переключатели, имеющие одного и того же непосредственного логического родителя, автоматически попадают в одну группу.
        // Но если требуется сгруппировать переключатели каким-то особым образом, то можно воспользоваться свойством GroupName, значением которого является строка.

        // Простые контейнеры
        // - Label
        // - ToolTip
        // - Frame

        // Класс Label
        // Уникальная особенность метки – поддержка клавиш доступа. В тексте метки можно выделить одну букву, так что нажатие соответствующей ей комбинации клавиш доступа – эта буква в сочетании с клавишей Alt – будет обрабатываться особым образом.
        // Точнее, можно назначить произвольный элемент, который получит фокус при нажатии этой комбинации.
        // Чтобы выделить букву (которая в зависимости от настроек Windows может быть подчеркнута), достаточно поместить перед ней знак подчеркивания.
        // А чтобы назначить соответствующий целевой элемент, нужно задать свойство метки Target (типа UIElement).

        // Класс ToolTip
        // Элемент управления ToolTip (всплывающая подсказка) представляет свое содержимое в плавающем прямоугольнике, который появляется, когда пользователь наводит указатель мыши на ассоциированный элемент, и исчезает, когда указатель покидает пределы этого элемента.
        // Элемент ToolTip нельзя помещать в дерево элементов UIElement непосредственно.
        // Он должен быть присвоен свойству ToolTip отдельного элемента (это свойство определено в классах FrameworkElement и FrameworkContentElement).
        // В классе ToolTip определены события Open и Closed на случай, если вы захотите что-то сделать при появлении и исчезновении подсказки.
        // Есть также несколько свойств для настройки поведения, например: где помещать подсказку, должна ли она оставаться открытой, пока ее явно не закроют, и даже следует ли рисовать тень.
        // Для таких случаев предусмотрен статический класс ToolTipService.

        // Класс Frame
        // Однако он изолирует свое содержимое от остальной части пользовательского интерфейса.

        // Контейнеры с заголовками
        // Класс GroupBox
        // GroupBox – хорошо знакомый элемент для организации групп элементов управления.

        // Класс Expander
        // Expander очень похож на GroupBox, но содержит кнопку, которая позволяет сворачивать и разворачивать внутреннее содержимое.
        // В классе Expander определено свойство IsExpanded и события Expanded/Collapsed.
        // Кроме того, он позволяет задать направление развертывания (Up, Down, Left, Right) с помощью свойства ExpandDirection.


        // 10 Многодетные элементы управления
        // Общая функциональность
        // Помимо свойств Items и ItemsSource, в классе ItemsControl есть еще несколько интересных свойств, а именно:
        // - HasItems – доступное только для чтения булевское свойство, упрощающее анализ наличия элементов в коллекции из декларативного XAML-кода.
        // В программе на C# можно использовать это свойство или просто проверить значение Items.Count.
        // - IsGrouping – еще одно булевское свойство, доступное только для чтения. Информирует о том, разбиты ли объекты, входящие в элементы управления, на группы верхнего уровня.
        // Группировка производится прямо в классе ItemsCollection, который включает несколько свойств для управления группами и присвоения им имен.
        // - AlternationCount и AlternationIndex – эти два свойства позволяют задать чередующиеся стили объектов-потомков в зависимости от индекса в коллекции.
        // Например, если AlternationCount равно 2, то элементам с четным индексом будет назначен один стиль, а элементам с нечетным индексом – другой.
        // - DisplayMemberPath – строковое свойство; в него можно занести имя свойства каждого объекта (или более сложное выражение), которое изменяет порядок его визуализации.
        // - ItemsPanel – свойство, позволяющее изменить способ организации объектов внутри многодетного элемента управления, не заменяя полностью его шаблон.

        // DisplayMemberPath
        // Свойство DisplayMemberPath поддерживает синтаксис так называемого пути к свойству, который используется в WPF в нескольких местах, в частности для привязки к данным и анимации.
        
        // ItemsPanel
        // Внешний облик всех элементов управления WPF можно изменить, применив другой шаблон, но для многодетных элементов есть и более короткий способ – заменить лишь часть шаблона, отвечающую за организацию хранящихся в нем объектов.
        // Этот мини-шаблон, который еще называют внутренней панелью (items panel), позволяет подменить панель, применяемую для организации объектов, оставив все прочие аспекты элемента управления неизменными.
        // Совет
        // В нескольких многодетных элементах управления для повышения производительности в качестве ItemsPanel по умолчанию используется панель VirtualizingStackPanel.
        // В WPF 4 эта панель поддерживает новый режим, еще больше повышающий производительность прокрутки, но устанавливать его нужно явно.
        // Для этого следует присвоить присоединенному свойству VirtualizingStackPanel.VirtualizationMode значение Recycling.
        // В таком случае панель повторно использует («рециклирует ») контейнеры, в которых хранятся видимые на экране объекты, а не создает новый контейнер для каждого объекта.

        // Управление поведением прокрутки
        // Многодетные элементы можно разделить на три основных группы, которые обсуждаются в следующих разделах:
        // - селекторы,
        // - меню
        // - все остальные

        // Селекторы
        // Селекторами называются многодетные элементы управления, объекты которых можно индексировать и – что более важно – выбирать.
        // Абстрактный класс Selector, производный от ItemsControl, добавляет несколько свойств, необходимых для поддержки выбора.
        // Например, следующие три похожих свойства предназначены для получения и установки текущего выбранного объекта:
        // - SelectedIndex – отсчитываемое от нуля целое число, равное индексу выбранного объекта, или -1, если ничего не выбрано.
        // Объекты нумеруются в порядке добавления в коллекцию.
        // - SelectedItem – сам выбранный объект.
        // - SelectedValue – значение выбранного объекта. По умолчанию оно совпадает с самим объектом, то есть SelectedValue – то же самое, что и SelectedItem.
        // Однако с помощью свойства SelectedValuePath можно задать имя произвольного свойства или даже выражение, которое будет представлять значение объекта (SelectedValuePath работает аналогично DisplayMemberPath).
        // В классе Selector определены также два присоединенных свойства, применяемые к отдельным объектам:
        // - IsSelected – булевское свойство, позволяющее выбрать или отменить выбор объекта (либо узнать, в каком состоянии он сейчас находится).
        // - IsSelectionActive – доступное только для чтения булевское свойство, которое сообщает, владеет ли выбранный объект фокусом.
        // В классе Selector имеется также событие SelectionChanged, которое позволяет получать уведомления об изменении выбранного объекта.
        // В состав WPF входит пять элементов управления, производных от Selector:
        // - ComboBox
        // - ListBox
        // - ListView
        // - TabControl
        // - DataGrid

        // Элемент ComboBox
        // Чтобы раскрыть или закрыть список, можно щелкнуть мышью, а также нажать сочетание клавиш Alt+стрелка вверх, Alt+стрелка вниз либо клавишу F4.
        // В классе ComboBox определены два события – DropDownOpened и DropDownClosed – и свойство IsDropDownOpen.
        // Режимы работы поля выбора
        // Элемент ComboBox поддерживает режим, в котором пользователь может вводить в поле выбора произвольный текст.
        // Если текст совпадает с каким-то из присутствующих в списке элементов, то этот элемент автоматически становится выбранным.
        // В противном случае ни один элемент не будет выбран, но введенный текст сохраняется в свойстве Text элемента ComboBox, так что программа может получить к нему доступ.
        // Этот режим контролируется двумя неудачно названными свойствами – IsEditable и IsReadOnly, – по умолчанию равными false.
        // Кроме того, имеется свойство StaysOpenOnEdit; если оно равно true, то список остается раскрытым, когда пользователь щелкает по полю выбора.
        // Понятно, что выводить в поле выбора имя типа "System.Windows.Controls.StackPanel" никуда не годится, и тут приходит на помощь класс TextSearch.
        // В нем определеныдва присоединенных свойства, позволяющих управлять тем, что отображается в редактируемом поле выбора.
        // В чем разница между свойствами IsEditable и IsReadOnly элемента ComboBox?
        // Если IsEditable равно true, то поле выбора ComboBox превращается в поле ввода.
        // Свойство IsReadOnly управляет тем, можно ли изменять текст в этом поле, – точно так же, как свойство IsReadOnly элемента TextBox.
        // Таким образом, поле IsReadOnly не имеет смысла, если IsEditable не равно true, а тот факт, что IsEditable равно true, еще не означает, что текст в поле выбора можно редактировать.
        // К элементу ComboBox можно присоединить свойство TextSearch.TextPath и тем самым указать, какое свойство (или субсвойство) объекта отображать в поле выбора.
        // Механизм работы такой же, как у свойств DisplayMemberPath и SelectedValuePath;
        // Событие SelectionChanged предназначено для элементов управления, допускающих выбор нескольких объектов, поэтому для селектора типа ComboBox, позволяющего выбрать только один объект, работатьс ним не очень удобно. 
        // Передаваемый обработчику события объект типа SelectionChangedEventArgs имеет два свойства типа IList: AddedItems и RemovedItems.
        // Свойство AddedItems содержит множество вновь выбранных объектов, а свойство RemovedItems – множество ранее выбранных объектов.
        // Если разрешено выбирать только один объект, то получить его можно следующим образом:
        // void ComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        // {
        // if (e.AddedItems.Count > 0)
        // object newSelection = e.AddedItems[0];
        // }

        // Класс ComboBoxItem
        // Класс ComboBox неявно обертывает каждый хранящийся в нем объект объектом ComboBoxItem.
        // В классе ComboBoxItem есть полезные свойства – IsSelected и IsHighlighted – и полезные события – Selected и Unselected.
        // Так как ComboBoxItem – однодетный элемент управления, то его удобно использовать для добавления в список ComboBox простых строк
        // <ComboBox>
        // <ComboBoxItem>Item 1</ComboBoxItem>
        // <ComboBoxItem>Item 2</ComboBoxItem>
        // </ComboBox>

        // Элемент ListBox
        // Пожалуй, самая важная особенность ListBox состоит в том, что он поддерживает выбор нескольких объектов.
        // Этим режимом управляет свойство SelectionMode, которое может принимать три значения (определенных в перечислении SelectionMode):
        // - Single – одновременно может быть выбран только один объект, как и в ComboBox. Это значение по умолчанию.
        // - Multiple – одновременно может быть выбрано несколько объектов. Щелчок по невыбранному объекту добавляет его в коллекцию SelectedItems, а щелчок по выбранному объекту удаляет его из этой коллекции.
        // - Extended – одновременно может быть выбрано несколько объектов, но поведение оптимизировано для выбора одного объекта.
        // Чтобы в этом режиме выбрать несколько объектов, следует во время щелчка мышью удерживать нажатой клавишу Shift (чтобы выбирать соседние элементы) или Ctrl (чтобы выбирать произвольные, необязательно соседние элементы).
        // Точно так же ведет себя элемент управления ListBox в Win32.
        // Как у ComboBox имеется компаньон ComboBoxItem, так и у ListBox есть компаньон ListBoxItem.
        // С этим классом мы уже встречались в предыдущих главах. На самом деле ComboBoxItem наследует классу ListBoxItem, в котором и определены свойство IsSelected и события Selected и Unselected.
        // Если выбрано несколько объектов, то свойство SelectedItem просто указывает на первый элемент в коллекции SelectedItems (то есть тот, которым был выбран первым), а свойства SelectedIndex и SelectedValue возвращают индекс и значение этого объекта.
        // Впрочем, для элементов управления, поддерживающих множественный выбор, этими свойствами лучше не пользоваться.
        // Совет
        // Прием с использованием свойства TextSearch, продемонстрированный ранее для элемента ComboBox, сохраняет актуальность и для ListBox.
        // Как добиться плавной прокрутки ListBox?
        // По умолчанию ListBox прокручивается пообъектно. Поскольку шаг прокрутки рассчитывается на основе высоты объекта, то в случае больших объектов прокрутка может происходитьрывками.
        // Чтобы список прокручивался плавно, с шагом в несколько пикселов, не зависящим от высоты объектов, проще всего присвоить значение false свойству ScrollViewer.CanContentScroll
        // Однако имейте в виду, что в таком режиме теряется возможность виртуализации списка
        // Как отсортировать объекты в списке ListBox?
        
        // Элемент ListView
        // Элемент управления ListView, производный от ListBox, выглядит и ведет себя, как ListBox, с тем отличием, что по умолчанию установлен режим Extended SelectionMode.
        // Однако класс ListView добавляет также свойство View, которое расширяет возможности настройки внешнего вида, не ограничиваясь одним лишь выбором нестандартной панели ItemsPanel.
        // Интересно, что GridView автоматически поддерживает кое-какие специальные возможности табличного вида Проводника Windows, а именно:
        // - Разрешается менять порядок столбцов путем перетаскивания их заголовков.
        // - Разрешается изменять размеры столбцов путем перетаскивания их разделителей.
        // - Двойной щелчок по разделителю столбцов приводит к автоматической подгонке их размера под размер содержимого столбца.
        
        // Элемент TabControl
        // Следующий селектор, TabControl, полезен для переключения между страницами содержимого.
        // Обычно вкладки располагаются вдоль верхнего края, но свойство TabStripPlacment (типа Dock) позволяет разместить их слева (Left), справа (Right) или снизу (Bottom).
        // 339
    }
}
