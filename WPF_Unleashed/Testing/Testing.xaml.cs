using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed.Testing
{
    /// <summary>
    /// Interaction logic for Testing.xaml
    /// </summary>
    public partial class Testing : Window
    {
        public Testing()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Panel.Panels window = new Panel.Panels();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Events.Events window = new Events.Events();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            MyApp window = new MyApp();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            Deployment.Deployment window = new Deployment.Deployment();
            window.Show();
        }

        private void Button_Click_4(object sender, RoutedEventArgs e)
        {
            OneChildControls.OneChildControls window = new OneChildControls.OneChildControls();
            window.Show();
        }

        private void Button_Click_5(object sender, RoutedEventArgs e)
        {
            ItemsControls.ItemsControls window = new ItemsControls.ItemsControls();
            window.Show();
        }

        private void Button_Click_6(object sender, RoutedEventArgs e)
        {
            ImageTextOther.ImageTextOther window = new ImageTextOther.ImageTextOther();
            window.Show();
        }


        // 4 Задание размера, положения и преобразований элементов


        // 5 Панели
        // StackPanel
        // В отсутствие присоединенных свойств единственный способ организовать дочерние элементы – воспользоваться свойством панели Orientation

        // WrapPanel
        // Панель WrapPanel похожа на StackPanel. Но помимо организации дочерних элементов в стопку она создает новые строки или столбцы, когда для одной стопки не хватает места.
        // В классе WrapPanel определены три свойства, контролирующие его поведение:
        // - Orientation – аналогично одноименному свойству StackPanel с тем отличием, что по умолчанию подразумевается значение Horizontal.
        // - ItemHeight – единая высота для всех дочерних элементов. Каким образом каждый потомок распоряжается этой высотой, зависит от значений его свойств VerticalAlignment, Height и пр. Элементы, ширина которых превышает ItemHeight, отсекаются.
        // - ItemWidth – единая ширина для всех дочерних элементов. Каким образом каждый потомок распоряжается этой шириной, зависит от значений его свойств HorizontalAlignment, Width и пр. Элементы, высота которых превышает ItemWidth, отсекаются.

        // DockPanel
        // Панель DockPanel дает простой способ пристыковки элемента к одной из сторон, растягивая его на всю имеющуюся ширину или высоту.
        // В классе DockPanel определено присоединенное свойство Dock, с помощью которого дочерние элементы могут управлять своим положением.
        // Оно может принимать четыре значения: Left (подразумевается по умолчанию, если свойство Dock не задано явно), Top, Right и Bottom.
        // Отметим, что у свойства Dock нет значения Fill, означающего, что нужно заполнить оставшееся место.
        // Вместо этого действует соглашение о том, что все оставшееся место отдается последнему дочернему элементу, добавленному в DockPanel, если только свойство LastChildFill не равно false.

        // Grid
        // По умолчанию свойства RowSpan и ColumnSpan равны 1, но могут принимать любое значение, большее или равное 1, – соответственно количество строк или столбцов, занимаемых данной ячейкой.
        // Такой автоматический выбор размера достигается путем присваивания свойствам Height и Width соответственно в элементах RowDefinition и ColumnDefinition специального значения Auto, нечувствительного к регистру букв.
        // панель Grid поддерживает три способа задания размера в элементах RowDefinition и ColumnDefinition:
        // - Абсолютный размер – числовое значение Height или Width означает, что размер задан в независимых от устройства пикселах
        // - Автоматический выбор размера – если Height или Width равно Auto, то дочерним элементам выделяется столько места, сколько необходимо, но не больше.
        // - Пропорциональное изменение размера – предусмотрен специальный синтаксис задания свойств Height и Width, позволяющий распределить имеющееся пространство поровну или в соответствии с заданными пропорциями 
        // Звездочка работает следующим образом:
        // - Если высота строки или ширина столбца равна *, то соответствующему структурному элементу выделяется все оставшееся место.
        // - Если размер * задан для нескольких строк или столбцов, то все оставшееся место делится между ними поровну.
        // - Перед символом * можно указывать коэффициент (например, 2* или 5.5*), тогда соответствующей строке или столбцу будет выделено пропорционально больше места, чем остальным строкам или столбцам, в размере которых присутствует символ *.
        // Интерактивное задание размера с помощью GridSplitter
        // В классах RowDefinitions и ColumnDefinitions имеется свойство SharedSizeGroup, позволяющее задать режим, при котором линейные размеры нескольких строк и/или столбцов будут оставаться одинаковыми даже в случае, когда размер любой из них изменяется в процессе выполнения программы
        // Свойство IsSharedSizeScope следует установить потому, что группы размеров могут применяться сразу к нескольким сеткам!

        // Обработка переполнения содержимого
        // Для ее разрешения можно применять различные стратегии:
        // • отсечение
        // • прокрутку
        // • масштабирование
        // • оборачивание
        // • обрезку

        // Отсечение
        // Отсечение дочерних элементов – это тот способ, который панели применяют по умолчанию, когда потомков становится слишком много.
        // Во всех классах, производных от UIElement, есть булевское свойство ClipToBounds, которое управляет тем, можно ли рисовать дочерние элементы вне границ родителя.
        // Однако, если внешний край элемента совпадает с внешним краем Window или Page, отсечение все равно производится.

        // Прокрутка
        // стоит поместить элемент внутрь элемента управления System.Windows.Controls.ScrollViewer, как он сразу же становится прокручиваемым.
        // В классе ScrollViewer имеется еще ряд свойств и методов для манипулирования из программы, но самыми важными являются свойства VerticalScrollBarVisibility и HorizontalScrollBarVisibility.
        // Оба они имеют тип перечисления ScrollBarVisibility, которое определяет четыре состояния полосы прокрутки:
        // - Visible – полоса прокрутки всегда присутствует, даже если она не нужна. Если необходимости в ней нет, то она выглядит неактивной и не реагирует на события ввода.
        // - Auto – полоса прокрутки видна, если содержимое нуждается в прокрутке в данном направлении. В противном случае полоса прокрутки отсутствует.
        // - Hidden – полоса прокрутки всегда невидима, но логически существует, то есть содержимое можно прокручивать клавишами со стрелками. Поэтому содержимое полностью доступно в данном направлении.
        // - Disabled – полоса прокрутки не только невидима, но и вообще не существует, то есть прокрутка невозможна ни с помощью клавиатуры, ни посредством мыши. В таком случае доступна только та часть содержимого, которая видна в пределах родителя.
        
        // Масштабирование
        // Класс Viewbox относится к так называемым декораторам, то есть панелеподобным классам, у которых может быть только один дочерний элемент.
        // Но у него также имеется свойство Stretch, позволяющее указать, как в занимаемой области должен масштабироваться единственный дочерний элемент.
        // Это свойство имеет тип перечисления System.Windows.Media.Stretch и может принимать следующие значения:
        // - None – масштабирование не производится вовсе. Результат такой же, как если бы Viewbox вообще не было.
        // - Fill – размеры дочернего элемента устанавливаются такими же, как размеры самого Viewbox. Поэтому отношение сторон дочернего элемента может не сохраняться.
        // - Uniform – дочерний элемент масштабируется так, чтобы он целиком поместился внутри Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении останется пустое место. Этот вариант подразумевается по умолчанию.
        // - UniformToFill – дочерний элемент масштабируется так, чтобы он целиком заполнял Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении содержимое будет отсечено.
        // Второе свойство Viewbox позволяет указать, какие операции разрешены: только уменьшение содержимого, только увеличение или и то и другое.
        // Оно называется StretchDirection, имеет тип перечисления System.Windows.Controls.StretchDirection и может принимать следующие значения:
        // - UpOnly – увеличивает содержимое, если необходимо. Если содержимое уже слишком велико, то Viewbox оставляет текущий размер без изменения.
        // - DownOnly – уменьшает содержимое, если необходимо. Если содержимое уже достаточно мало, то Viewbox оставляет текущий размер без изменения.
        // - Both – увеличивает или уменьшает содержимое в соответствии с заданным значением описанного выше свойства Stretch. Этот вариант подразумевается по умолчанию.

        // Все вместе: создание сворачиваемой, стыкуемой, изменяющей размер панели
        // Все три сетки помещены (куда бы вы думали?) в сетку с одной строкой и одним столбцом, чтобы они могли перекрывать друг друга и вместе с тем растягиваться, занимая все отведенное им место.
        // Z-порядок слоя 0 всегда наименьший, но Z-порядок двух остальных слоев может меняться так, чтобы текущая непристыкованная панель всегда была наверху.


        // 6 События ввода: клавиатура, мышь, стилус и мультисенсорные устройства
        // Маршрутизируемые события
        // - Tunneling – событие сначала возникает в корне дерева, а потом опускается вниз по дереву, заново возникая в каждом элементе на пути к источнику, включая его самого (если туннелирование не будет прервано по дороге в результате пометки события как обработанного)
        // - Bubbling – событие сначала возникает в элементе-источнике, а затем поднимается вверх по дереву, заново возникая в каждом элементе на пути к корню, включая сам корень (если всплытие не будет прервано по дороге в результате пометки события как обработанного)
        // - Direct – событие возникает только в элементе-источнике. Точно так же ведут себя обычные события .NET; различие лишь в том, что к маршрутизируемому событию применяются и другие механизмы, в частности триггеры событий
        // Сигнатуры обработчиков маршрутизируемых событий устроены так же, как сигнатуры всех обработчиков событий в .NET: первый параметр – объект типа System.Object, который обычно называют sender, второй – экземпляр класса, производного от System.EventArgs.
        // Параметр e является объектом класса RoutedEventArgs – подкласса EventArgs, обладающего следующими полезными свойствами:
        // - Source – элемент логического дерева, первоначально сгенерировавший событие.
        // - OriginalSource – элемент визуального дерева, первоначально сгенерировавший событие (например, в случае стандартной кнопки Button это будет дочерний элемент TextBlock или ButtonChrome). 
        // - Handled – булевский флаг, которому можно присвоить значение true и тем самым пометить, что событие обработано. Именно таким способом прерывается туннелирование и всплытие.
        // - RoutedEvent – сам объект маршрутизированного события (например, Button. ClickEvent), который может быть полезен для различения событий в случае, когда один и тот же обработчик используется для обработки разных событий.

        // Маршрутизируемые события в действии
        // Туннелируемые события легко распознать, потому что по принятому соглашению их имена начинаются со слова Preview. Такое событие – также по соглашению – генерируется непосредственно перед парным ему всплывающим.
        // Например, туннелируемое событие PreviewMouseMove генерируется перед всплывающим событием MouseMove.
        // Идея, стоящая за такими парами событий, заключается в том, чтобы дать элементам возможность отменить или иным способом модифицировать событие, которое еще только произойдет.
        // - Window не получает событие MouseRightButtonDown, если щелкнуть по любому элементу списка ListBoxItem. Дело в том, что ListBoxItem сам обрабатывает это событие, равно как и MouseLeftButtonDown (и прерывает всплытие), – это нужно ему для реализации выбора элементов.
        // - Window получает событие MouseRightButtonDown при щелчке по кнопке Button, но никаких изменений во внешнем виде рамкине происходит. Это объясняется структурой стандартного визуального дерева Button. В отличие от элементов Window, Label, ListBox, ListBoxItem и StatusBar, в визуальном дереве Button нет элемента Border.
        // Присоединенные события

        // Перетаскивание
        // Во всех подклассах UIElement определены события для работы с перетаскиванием:
        // - DragEnter, DragOver, DragLeave, а также PreviewDragEnter, PreviewDragOver и PreviewDragLeave
        // - Drop и PreviewDrop
        // - QueryContinueDrag и PreviewQueryContinueDrag
        // Это перетаскивание элемента в буфер обмена и бросание содержимого буфера на элемент в стиле Win32, а не перетаскивание и бросание самих элементов.
        // Элемент может принять участие в перетаскивании, установив значение true для свойства AllowDrop.
        // Обработчикам событий из первых двух наборов передается объект типа DragEventArgs, содержащий следующие свойства и методы:
        // - GetPosition – такой же метод, как в классе MouseEventArgs
        // - Data – свойство типа IDataObject, представляющее перетаскиваемый или бросаемый объект буфера обмена Win32
        // - Effects и AllowedEffects – битовое перечисление DragDropEffects, допускающее произвольную комбинацию флагов Copy, Move, Link, Scroll, All и None
        // - KeyStates – еще одно битовое перечисление (DragDropKeyStates), показывающее, какие кнопки мыши или клавиши-модификаторы были нажаты во время перетаскивания или бросания: LeftMouseButton, RightMouseButton, MiddleMouseButton, ShiftKey, ControlKey, AltKey или None
        // События QueryContinueDrag и PreviewQueryContinueDrag генерируются, если во время перетаскивания изменяется состояние клавиатуры или какой-нибудь кнопки мыши.
        // Это позволяет обработчику без труда отменить всю операцию.
        // Обработчикам этих событий передается объект класса QueryContinueDragEventArgs, имеющий следующие свойства:
        // - KeyStates – аналогично одноименному свойству класса DragEventArgs
        // - EscapePressed – отдельное булевское свойство, показывающее, была ли нажата клавиша Esc
        // Action – свойство, которое обработчик может установить, чтобы определить судьбу операции перетаскивания; принадлежит перечислению DragAction и принимает значение Continue, Drop или Cancel
        
        // Захват мыши
        // К счастью, WPF позволяет любому элементу UIElement в любой момент захватить или освободить мышь.
        // Когда элемент захватил мышь, он получает все события мыши, даже если указатель оказывается вне занимаемой им области.
        // После освобождения мыши поведение событий возвращается в нормальное русло. Для захвата и освобождения мыши предназначены два метода классаUIElement: CaptureMouse и ReleaseMouseCapture.
        // И, разумеется, есть ряд свойств и событий, сообщающих о состоянии захвата мыши, точнее, свойства IsMouseCaptured и IsMouseCaptureWithin и события GotMouseCapture, LostMouseCapture, IsMouseCaptureChanged и IsMouseCaptureWithinChanged.
        // Поэтому для реализации перетаскивания необходимо захватить мышь в обработчике MouseLeftButtonDown и освободить ее в обработчике MouseLeftButtonUp.

        // Команды
        // Мощь механизма команд основывается на трех основных особенностях:
        // - В WPF определено много встроенных команд.
        // - В команды встроена автоматическая поддержка жестов ввода (например, сочетаний клавиш).
        // - Встроенное поведение некоторых элементов управления WPF уже ориентировано на те или иные команды.

        // Встроенные команды
        // Командой называется любой объект, реализующий интерфейс ICommand (из пространства имен System.Windows.Input), в котором объявлены три простых члена:
        // - Execute – метод, который выполняет характерную для команды логику
        // - CanExecute – метод, который возвращает true, если команда активирована, и false, если она деактивирована
        // - CanExecuteChanged – событие, которое генерируется при изменении значения CanExecute
        // Встроенные в WPF команды доступны в виде статических свойств пяти разных классов:
        // - ApplicationCommands – Close, Copy, Cut, Delete, Find, Help, New, Open, Paste, Print,
        // PrintPreview, Properties, Redo, Replace, Save, SaveAs, SelectAll, Stop, Undo и др.
        // - ComponentCommands – MoveDown, MoveLeft, MoveRight, MoveUp, ScrollByLine, ScrollPageDown,
        // ScrollPageLeft, ScrollPageRight, ScrollPageUp, SelectToEnd, SelectToHome,
        // SelectToPageDown, SelectToPageUp и др.
        // - MediaCommands – ChannelDown, ChannelUp, DecreaseVolume, FastForward, IncreaseVolume,
        // MuteVolume, NextTrack, Pause, Play, PreviousTrack, Record, Rewind, Select, Stop и др.
        // - NavigationCommands – BrowseBack, BrowseForward, BrowseHome, BrowseStop, Favorites,
        // FirstPage, GoToPage, LastPage, NextPage, PreviousPage, Refresh, Search, Zoom и др.
        // - EditingCommands – AlignCenter, AlignJustify, AlignLeft, AlignRight, CorrectSpellingError,
        // DecreaseFontSize, DecreaseIndentation, EnterLineBreak, EnterParagraphBreak,
        // IgnoreSpellingError, IncreaseFontSize, IncreaseIndentation, MoveDownByLine,
        // MoveDownByPage, MoveDownByParagraph, MoveLeftByCharacter, MoveLeftByWord,
        // MoveRightByCharacter, MoveRightByWord и др.

        // Элементы управления со встроенными привязками к командам


        // 7 Структурирование и развертывание приложения
        
        // Класс Window
        // Если некое окно хочет сделать другое окно дочерним, оно должно записать в свойство Owner (типа Window) последнего ссылку на себя, но только после того, как родитель уже был показан на экране.
        // Перебрать дочерние окна позволяет доступное только для чтения свойство OwnedWindows.
        // По принятому соглашению управляемые классы содержат защищенные методы OnEventName, по одному для каждого события

        // Класс Application
        // Метод Application.Run
        // [STAThread]
        // public static void Main()
        // {
        //     Application app = new Application();
        //     MainWindow window = new MainWindow();
        //     window.Show();
        //     app.Run(window);
        // }
        // В классе Application есть также очень полезное свойство-коллекция Properties.
        // Как и состояние приложенияили сеанса в ASP.NET, это словарь, предназначенный для удобного хранения произвольных данных(в виде пар ключ/значение), общих для различных окон или других объектов.
        // Например, в приложении Photo Gallery так хранится имя файла текущей выбранной фотографии:
        // myApplication.Properties["CurrentPhotoFilename"] = filename;
        // А получить к нему доступ можно следующим образом:
        // string filename = myApplication.Properties["CurrentPhotoFilename"] as string;
        // Как в WPF создать приложение, которое может существовать в единственном экземпляре?
        // bool mutexIsNew;
        // using (System.Threading.Mutex m = new System.Threading.Mutex(true, uniqueName, out mutexIsNew))
        // {
        // if (mutexIsNew)
        // Это первый экземпляр, запускаем приложение.
        // else
        // Экземпляр уже работает. Выходим!
        // }

        // Диалоговые окна

        // Сохранение и восстановление состояния приложения

        // Страницы и их навигационные контейнеры
        // Элементы Page могут располагаться в одном из двух встроенных навигационных контейнеров: NavigationWindow или Frame.
        // По умолчанию вдоль верхнего края NavigationWindow располагается панель с кнопками Назад/Вперед, а во фрейме ее нет, но в обоих случаях панель можно добавить или убрать с помощью свойства ShowsNavigationUI, содержащегося внутри страницы Page.
        // Кроме того, в классе NavigationWindow имеется свойство ShowsNavigationUI, а в классе Frame – свойство NavigationUIVisibility, оба они позволяют показать или скрыть эту панель вне зависимости от настроек Page.
        // Элемент Page может взаимодействовать со своим навигационным контейнером с помощью класса NavigationService.
        // Чтобы получить экземпляр NavigationService, следует вызвать статический метод NavigationService.GetNavigationService, передав ему экземпляр Page.
        // Но можно поступить и проще, обратившись к свойству NavigationService объекта Page.
        // this.NavigationService.Title = "Main Photo Gallery Page";
        // this.NavigationService.Refresh();

        // Переходы между страницами
        // Есть три основных способа навигации:
        // - Посредством метода Navigate
        // - С помощью гиперссылок (объектов Hyperlink)
        // - С помощью журнала

        // Вызов метода Navigate
        // Перейти к экземпляру страницы 
        // PhotoPage nextPage = new PhotoPage();
        // this.NavigationService.Navigate(nextPage);
        // Или перейти на страницу с заданным URI
        // this.NavigationService.Navigate(new Uri("PhotoPage.xaml", UriKind.Relative));
        
        // Представление метода Navigate в виде двух свойств
        // Чтобы перейти к объекту Page, достаточно установить свойство Content:
        // this.NavigationService.Content = nextPage;
        // this.NavigationService.Source = new Uri("PhotoPage.xaml", UriKind.Relative);

        // Использование элемента Hyperlink
        // Для простых схем навигации в WPF имеется элемент Hyperlink, который ведет себя во многом аналогично гиперссылкам в HTML.
        // <TextBlock>
        // Click <Hyperlink NavigateUri="PhotoPage.xaml">here</Hyperlink> to view the photo.
        // </TextBlock>
        // Совет
        // Если вам нужна гибкость программной навигации в сочетании с удобными средствами автоматического форматирования текста, предоставляемыми классом Hyperlink, то можете указать в Hyperlink фиктивное значение свойства NavigateUri, а потом в обработчике события Click этого элемента вызвать метод Navigate, задав нужный адрес перехода.
        // Совет
        // Класс Hyperlink поддерживает и дополнительные возможности – как и гиперссылки в HTML.
        // Например, для перехода в конкретный фрейм Frame в случае, когда фреймов несколько, следует присвоить свойству TargetName элемента Hyperlink имя нужного фрейма.
        // Чтобы перейти к определенному месту внутри страницы Page (как в HTML-якорях, обозначаемых символом #), достаточно дописать в конец URI символ # и имя любого элемента на целевой странице.
        // в качестве значения HREF задать какое-нибудь фиктивное значение и написать обработчик события Navigating, в котором динамически изменить цель, вызвав метод Navigate самостоятельно.

        // Использование журнала
        // Отражение навигации в журнале
        // Назад - Помещает текущую страницу в стек прямых переходов, извлекает страницу из стека обратных переходов и переходит на нее
        // Вперед - Помещает текущую страницу в стек обратных переходов, извлекает страницу из стека прямых переходов и переходит на нее
        // Любая другая навигация - Помещает текущую страницу в стек обратных переходов и опустошает стек прямых переходов
        // Действия перехода назад и вперед могут быть инициированы как пользователем, так и программой – путем вызова методов GoBack и GoForward навигационного контейнера (предварительно вызвав соответственно метод CanGoBack или CanGoForward, чтобы избежать исключения в результате попытки извлечения из пустого стека).
        // В объекте NavigationWindow журнал есть всегда, тогда как в объекте Frame собственного журнала может и не быть; это зависит от его свойства JournalOwnership, которое может принимать следующие значения:
        // - OwnsJournal – у фрейма есть свой журнал.
        // - UsesParentJournal – история хранится в журнале родительского контейнера или не хранится вовсе, если у родителя нет журнала.
        // - Automatic – эквивалентно UsesParentJournal, если фрейм содержится в любом из двух навигационных контейнеров (NavigationWindow или Frame), в противном случае эквивалентно OwnsJournal. Это значение по умолчанию.
        // Если у фрейма есть собственный журнал, он получает также встроенные кнопки навигации. Если они вам не нужны, присвойте свойству NavigationUIVisibility значение Hidden.
        // СОВЕТ
        // В случае перехода на страницу Page с помощью URI (неважно, путем вызова метода Navigate или посредством гиперссылки Hyperlink) создается новый экземпляр Page, даже если вы уже посещали эту страницу.
        // Поэтому, если требуется, чтобы страница «запоминала» свои данные, необходимо хранить состояния отдельно (например, в статических переменных или в словаре Application.Properties). (При вызове варианта Navigate, принимающего экземпляр Page, вы, разумеется, вольны сами решать, передать ли ему новый или старый объект.)
        // Однако в случае навигации по журналу можно установить режим принудительного использования одного и того же объекта Page, присвоив его присоединенному свойству JournalEntry.KeepAlive значение true.
        // Совет
        // Объект Page может потребовать не заносить себя в журнал, присвоив своему свойству RemoveFromJournal значение true.
        // Это имеет смысл для страниц, являющихся частью  некоторой последовательности шагов, которые нельзя открывать в произвольном порядке после завершения операции.

        // События навигации
        // Вне зависимости от того, как инициирована навигация – путем вызова метода Navigate, с помощью гиперссылок Hyperlink или по журналу, – она всегда производится асинхронно.
        // В процессе навигации генерируется ряд событий, позволяющих сообщать пользователю подробную информацию или даже прервать навигацию.
        // События навигации, возникающие при загрузке первой страницы:
        // Navigation Container: Initialized -> Navigating -> NavigationProgress -> Loading -> first page initialized -> Navigated -> LoadCompleted -> first page loaded.
        // События навигации, возникающие при переходе от одной страницы к другой:
        // Navigation Container: Navigating -> NavigationProgress -> Loading -> second page Initialized -> first page unloaded -> Navigated -> LoadCompleted -> second page Loaded.
        
        // Передача данных между страницами
        
        // Передача данных странице
        // WPF поддерживает схему, аналогичную параметрам URL, с помощью перегруженных вариантов метода Navigate, которые принимают дополнительный параметр типа Object.
        // int photoId = 10;
        // Перейти к экземпляру Page
        // PhotoPage nextPage = new PhotoPage();
        // this.NavigationService.Navigate(nextPage, photoId);
        // Или перейти к странице по URI
        // this.NavigationService.Navigate(
        // new Uri("PhotoPage.xaml", UriKind.Relative), photoId);

        // Чтобы целевая страница могла получить данные, она должна обработать событие LoadCompleted навигационного контейнера и опросить свойство ExtraData аргумента события:
        // this.NavigationService.LoadCompleted += new LoadCompletedEventHandler(container_LoadCompleted);
        // void container_LoadCompleted(object sender, NavigationEventArgs e)
        // {
        // if (e.ExtraData != null)
        // LoadPhoto((int)e.ExtraData);
        // }
        // Есть и более простой метод:
        // int photoId = 10;
        // Перейти к экземпляру Page
        // PhotoPage nextPage = new PhotoPage(photoId);
        // this.NavigationService.Navigate(nextPage);
        // Третий способ – организовать глобальное обобществление данных с помощью коллекции Properties объекта Application.
        // Такой подход может оказаться удобным, когда нужно сделать данные доступными нескольким страницам (а не просто передать от одной страницыдругой).
        // Однако недостатком, как и в первом случае, является отсутствие строгой типизации.

        // Возврат данных от страницы с помощью PageFunction
        // Классический пример – страница настроек.
        // Достигается это с помощью класса с забавным названием PageFunction.
        // <PageFunction
        // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        // xmlns:sys="clr-namespace:System;assembly=mscorlib"
        // x:Class="MyProject.PageFunction1"
        // x:TypeArguments="sys:String"
        // Title="PageFunction1">
        // <Grid>
        // </Grid>
        // </PageFunction>

        // Поскольку PageFunction – подкласс Page, то на элемент этого типа можно переходить точно так же, как на любую другую страницу:
        // PageFunction1 nextPage = new PageFunction1<string>();
        // this.NavigationService.Navigate(nextPage);
        // Для получения возвращенного значения исходная страница должна обработать событие Return объекта PageFunction:
        // nextPage.Return += new ReturnEventHandler<string>(nextPage_Return);
        // ...
        // void nextPage_Return(object sender, ReturnEventArgs<string> e)
        // {
        // string returnValue = e.Result;
        // }
        // Страница, производная от PageFunction, может вернуть данные, обернув их типом ReturnEventArgs и вызвав метод OnReturn, унаследованный от базового класса PageFunction:
        // OnReturn(new ReturnEventArgs<string>("the data"));

        // Приложения-гаджеты

        // XAML-приложения для браузера


        // 8 Особенности Windows 7
        // В .NET для проверки версии операционной системы можно использовать свойство System.Environment.OSVersion. 
        // if (System.Environment.OSVersion.Version.Major >= 6)
        // Windows Vista или более поздняя, используем TaskDialog
        // else
        // Младше Windows Vista, используем MessageBox


        // 9 Однодетные элементы управления
        // - Button
        // - RepeatButton
        // - ToggleButton
        // - CheckBox
        // - RadioButton

        // Класс Button
        // Класс Button в WPF добавляет к тому, что уже дает ButtonBase, два простых понятия: кнопка отмены и кнопка по умолчанию.
        // Оба удобны для применения в диалоговых окнах. Если для некоторой кнопки, находящейся внутри диалогового окна(ShowDialog),
        // свойство Button.IsCancel равно true, то при нажатии этой кнопки окно автоматически закрывается и свойство DialogResult принимает значение false.

        // Класс RepeatButton
        // Класс RepeatButton ведет себя так же, как Button, но продолжает генерировать событие Click до тех пор, пока кнопка нажата.
        // (Кроме того, в нем нет понятия кнопки по умолчанию и кнопки отмены, так как он наследует непосредственно ButtonBase.)

        // Класс ToggleButton
        // ToggleButton – это «залипающая» кнопка, которая сохраняет свое состояние после нажатия (понятия кнопки по умолчанию и кнопки отмены для нее тоже не определены).
        // При первом щелчке свойство IsChecked становится равным true, при следующем – возвращается в false.
        
        // Класс CheckBox
        // - У него имеется единственный вложенный элемент, задаваемый в разметке (в отличие от стандартного флажка).
        // - Для него определено понятие «нажатия» с помощьюмыши или клавиатуры.
        // - После нажатия он сохраняет состояние: отмечен или сброшен.
        // - Он поддерживает трехпозиционный режим, в котором состояние циклически переключается между вариантами «отмечен», «неизвестно» и «сброшен».
        // Если флажок CheckBox владеет фокусом, то нажатие клавиши плюс (+) отмечает его, а клавиши минус (–) – сбрасывает! Отметим, что это работает, только если свойство IsThreeState равно false.

        // Класс RadioButton
        // RadioButton – еще один элемент управления, производный от ToggleButton. Его уникальная особенность заключается в поддержке взаимного исключения.
        // Если несколько элементов RadioButton помещены в одну группу, то в любой момент времени отмеченным может быть только один из них.
        // Таким образом, элемент RadioButton предназначен для формулирования вопроса, имеющего несколько вариантов ответа.
        // По умолчанию все переключатели, имеющие одного и того же непосредственного логического родителя, автоматически попадают в одну группу.
        // Но если требуется сгруппировать переключатели каким-то особым образом, то можно воспользоваться свойством GroupName, значением которого является строка.

        // Простые контейнеры
        // - Label
        // - ToolTip
        // - Frame

        // Класс Label
        // Уникальная особенность метки – поддержка клавиш доступа. В тексте метки можно выделить одну букву, так что нажатие соответствующей ей комбинации клавиш доступа – эта буква в сочетании с клавишей Alt – будет обрабатываться особым образом.
        // Точнее, можно назначить произвольный элемент, который получит фокус при нажатии этой комбинации.
        // Чтобы выделить букву (которая в зависимости от настроек Windows может быть подчеркнута), достаточно поместить перед ней знак подчеркивания.
        // А чтобы назначить соответствующий целевой элемент, нужно задать свойство метки Target (типа UIElement).

        // Класс ToolTip
        // Элемент управления ToolTip (всплывающая подсказка) представляет свое содержимое в плавающем прямоугольнике, который появляется, когда пользователь наводит указатель мыши на ассоциированный элемент, и исчезает, когда указатель покидает пределы этого элемента.
        // Элемент ToolTip нельзя помещать в дерево элементов UIElement непосредственно.
        // Он должен быть присвоен свойству ToolTip отдельного элемента (это свойство определено в классах FrameworkElement и FrameworkContentElement).
        // В классе ToolTip определены события Open и Closed на случай, если вы захотите что-то сделать при появлении и исчезновении подсказки.
        // Есть также несколько свойств для настройки поведения, например: где помещать подсказку, должна ли она оставаться открытой, пока ее явно не закроют, и даже следует ли рисовать тень.
        // Для таких случаев предусмотрен статический класс ToolTipService.

        // Класс Frame
        // Однако он изолирует свое содержимое от остальной части пользовательского интерфейса.

        // Контейнеры с заголовками
        // Класс GroupBox
        // GroupBox – хорошо знакомый элемент для организации групп элементов управления.

        // Класс Expander
        // Expander очень похож на GroupBox, но содержит кнопку, которая позволяет сворачивать и разворачивать внутреннее содержимое.
        // В классе Expander определено свойство IsExpanded и события Expanded/Collapsed.
        // Кроме того, он позволяет задать направление развертывания (Up, Down, Left, Right) с помощью свойства ExpandDirection.


        // 10 Многодетные элементы управления
        // Общая функциональность
        // Помимо свойств Items и ItemsSource, в классе ItemsControl есть еще несколько интересных свойств, а именно:
        // - HasItems – доступное только для чтения булевское свойство, упрощающее анализ наличия элементов в коллекции из декларативного XAML-кода.
        // В программе на C# можно использовать это свойство или просто проверить значение Items.Count.
        // - IsGrouping – еще одно булевское свойство, доступное только для чтения. Информирует о том, разбиты ли объекты, входящие в элементы управления, на группы верхнего уровня.
        // Группировка производится прямо в классе ItemsCollection, который включает несколько свойств для управления группами и присвоения им имен.
        // - AlternationCount и AlternationIndex – эти два свойства позволяют задать чередующиеся стили объектов-потомков в зависимости от индекса в коллекции.
        // Например, если AlternationCount равно 2, то элементам с четным индексом будет назначен один стиль, а элементам с нечетным индексом – другой.
        // - DisplayMemberPath – строковое свойство; в него можно занести имя свойства каждого объекта (или более сложное выражение), которое изменяет порядок его визуализации.
        // - ItemsPanel – свойство, позволяющее изменить способ организации объектов внутри многодетного элемента управления, не заменяя полностью его шаблон.

        // DisplayMemberPath
        // Свойство DisplayMemberPath поддерживает синтаксис так называемого пути к свойству, который используется в WPF в нескольких местах, в частности для привязки к данным и анимации.
        
        // ItemsPanel
        // Внешний облик всех элементов управления WPF можно изменить, применив другой шаблон, но для многодетных элементов есть и более короткий способ – заменить лишь часть шаблона, отвечающую за организацию хранящихся в нем объектов.
        // Этот мини-шаблон, который еще называют внутренней панелью (items panel), позволяет подменить панель, применяемую для организации объектов, оставив все прочие аспекты элемента управления неизменными.
        // Совет
        // В нескольких многодетных элементах управления для повышения производительности в качестве ItemsPanel по умолчанию используется панель VirtualizingStackPanel.
        // В WPF 4 эта панель поддерживает новый режим, еще больше повышающий производительность прокрутки, но устанавливать его нужно явно.
        // Для этого следует присвоить присоединенному свойству VirtualizingStackPanel.VirtualizationMode значение Recycling.
        // В таком случае панель повторно использует («рециклирует ») контейнеры, в которых хранятся видимые на экране объекты, а не создает новый контейнер для каждого объекта.

        // Управление поведением прокрутки
        // Многодетные элементы можно разделить на три основных группы, которые обсуждаются в следующих разделах:
        // - селекторы,
        // - меню
        // - все остальные

        // Селекторы
        // Селекторами называются многодетные элементы управления, объекты которых можно индексировать и – что более важно – выбирать.
        // Абстрактный класс Selector, производный от ItemsControl, добавляет несколько свойств, необходимых для поддержки выбора.
        // Например, следующие три похожих свойства предназначены для получения и установки текущего выбранного объекта:
        // - SelectedIndex – отсчитываемое от нуля целое число, равное индексу выбранного объекта, или -1, если ничего не выбрано.
        // Объекты нумеруются в порядке добавления в коллекцию.
        // - SelectedItem – сам выбранный объект.
        // - SelectedValue – значение выбранного объекта. По умолчанию оно совпадает с самим объектом, то есть SelectedValue – то же самое, что и SelectedItem.
        // Однако с помощью свойства SelectedValuePath можно задать имя произвольного свойства или даже выражение, которое будет представлять значение объекта (SelectedValuePath работает аналогично DisplayMemberPath).
        // В классе Selector определены также два присоединенных свойства, применяемые к отдельным объектам:
        // - IsSelected – булевское свойство, позволяющее выбрать или отменить выбор объекта (либо узнать, в каком состоянии он сейчас находится).
        // - IsSelectionActive – доступное только для чтения булевское свойство, которое сообщает, владеет ли выбранный объект фокусом.
        // В классе Selector имеется также событие SelectionChanged, которое позволяет получать уведомления об изменении выбранного объекта.
        // В состав WPF входит пять элементов управления, производных от Selector:
        // - ComboBox
        // - ListBox
        // - ListView
        // - TabControl
        // - DataGrid

        // Элемент ComboBox
        // Чтобы раскрыть или закрыть список, можно щелкнуть мышью, а также нажать сочетание клавиш Alt+стрелка вверх, Alt+стрелка вниз либо клавишу F4.
        // В классе ComboBox определены два события – DropDownOpened и DropDownClosed – и свойство IsDropDownOpen.
        // Режимы работы поля выбора
        // Элемент ComboBox поддерживает режим, в котором пользователь может вводить в поле выбора произвольный текст.
        // Если текст совпадает с каким-то из присутствующих в списке элементов, то этот элемент автоматически становится выбранным.
        // В противном случае ни один элемент не будет выбран, но введенный текст сохраняется в свойстве Text элемента ComboBox, так что программа может получить к нему доступ.
        // Этот режим контролируется двумя неудачно названными свойствами – IsEditable и IsReadOnly, – по умолчанию равными false.
        // Кроме того, имеется свойство StaysOpenOnEdit; если оно равно true, то список остается раскрытым, когда пользователь щелкает по полю выбора.
        // Понятно, что выводить в поле выбора имя типа "System.Windows.Controls.StackPanel" никуда не годится, и тут приходит на помощь класс TextSearch.
        // В нем определеныдва присоединенных свойства, позволяющих управлять тем, что отображается в редактируемом поле выбора.
        // В чем разница между свойствами IsEditable и IsReadOnly элемента ComboBox?
        // Если IsEditable равно true, то поле выбора ComboBox превращается в поле ввода.
        // Свойство IsReadOnly управляет тем, можно ли изменять текст в этом поле, – точно так же, как свойство IsReadOnly элемента TextBox.
        // Таким образом, поле IsReadOnly не имеет смысла, если IsEditable не равно true, а тот факт, что IsEditable равно true, еще не означает, что текст в поле выбора можно редактировать.
        // К элементу ComboBox можно присоединить свойство TextSearch.TextPath и тем самым указать, какое свойство (или субсвойство) объекта отображать в поле выбора.
        // Механизм работы такой же, как у свойств DisplayMemberPath и SelectedValuePath;
        // Событие SelectionChanged предназначено для элементов управления, допускающих выбор нескольких объектов, поэтому для селектора типа ComboBox, позволяющего выбрать только один объект, работатьс ним не очень удобно. 
        // Передаваемый обработчику события объект типа SelectionChangedEventArgs имеет два свойства типа IList: AddedItems и RemovedItems.
        // Свойство AddedItems содержит множество вновь выбранных объектов, а свойство RemovedItems – множество ранее выбранных объектов.
        // Если разрешено выбирать только один объект, то получить его можно следующим образом:
        // void ComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        // {
        // if (e.AddedItems.Count > 0)
        // object newSelection = e.AddedItems[0];
        // }

        // Класс ComboBoxItem
        // Класс ComboBox неявно обертывает каждый хранящийся в нем объект объектом ComboBoxItem.
        // В классе ComboBoxItem есть полезные свойства – IsSelected и IsHighlighted – и полезные события – Selected и Unselected.
        // Так как ComboBoxItem – однодетный элемент управления, то его удобно использовать для добавления в список ComboBox простых строк
        // <ComboBox>
        // <ComboBoxItem>Item 1</ComboBoxItem>
        // <ComboBoxItem>Item 2</ComboBoxItem>
        // </ComboBox>

        // Элемент ListBox
        // Пожалуй, самая важная особенность ListBox состоит в том, что он поддерживает выбор нескольких объектов.
        // Этим режимом управляет свойство SelectionMode, которое может принимать три значения (определенных в перечислении SelectionMode):
        // - Single – одновременно может быть выбран только один объект, как и в ComboBox. Это значение по умолчанию.
        // - Multiple – одновременно может быть выбрано несколько объектов. Щелчок по невыбранному объекту добавляет его в коллекцию SelectedItems, а щелчок по выбранному объекту удаляет его из этой коллекции.
        // - Extended – одновременно может быть выбрано несколько объектов, но поведение оптимизировано для выбора одного объекта.
        // Чтобы в этом режиме выбрать несколько объектов, следует во время щелчка мышью удерживать нажатой клавишу Shift (чтобы выбирать соседние элементы) или Ctrl (чтобы выбирать произвольные, необязательно соседние элементы).
        // Точно так же ведет себя элемент управления ListBox в Win32.
        // Как у ComboBox имеется компаньон ComboBoxItem, так и у ListBox есть компаньон ListBoxItem.
        // С этим классом мы уже встречались в предыдущих главах. На самом деле ComboBoxItem наследует классу ListBoxItem, в котором и определены свойство IsSelected и события Selected и Unselected.
        // Если выбрано несколько объектов, то свойство SelectedItem просто указывает на первый элемент в коллекции SelectedItems (то есть тот, которым был выбран первым), а свойства SelectedIndex и SelectedValue возвращают индекс и значение этого объекта.
        // Впрочем, для элементов управления, поддерживающих множественный выбор, этими свойствами лучше не пользоваться.
        // Совет
        // Прием с использованием свойства TextSearch, продемонстрированный ранее для элемента ComboBox, сохраняет актуальность и для ListBox.
        // Как добиться плавной прокрутки ListBox?
        // По умолчанию ListBox прокручивается пообъектно. Поскольку шаг прокрутки рассчитывается на основе высоты объекта, то в случае больших объектов прокрутка может происходитьрывками.
        // Чтобы список прокручивался плавно, с шагом в несколько пикселов, не зависящим от высоты объектов, проще всего присвоить значение false свойству ScrollViewer.CanContentScroll
        // Однако имейте в виду, что в таком режиме теряется возможность виртуализации списка
        // Как отсортировать объекты в списке ListBox?
        
        // Элемент ListView
        // Элемент управления ListView, производный от ListBox, выглядит и ведет себя, как ListBox, с тем отличием, что по умолчанию установлен режим Extended SelectionMode.
        // Однако класс ListView добавляет также свойство View, которое расширяет возможности настройки внешнего вида, не ограничиваясь одним лишь выбором нестандартной панели ItemsPanel.
        // Интересно, что GridView автоматически поддерживает кое-какие специальные возможности табличного вида Проводника Windows, а именно:
        // - Разрешается менять порядок столбцов путем перетаскивания их заголовков.
        // - Разрешается изменять размеры столбцов путем перетаскивания их разделителей.
        // - Двойной щелчок по разделителю столбцов приводит к автоматической подгонке их размера под размер содержимого столбца.
        
        // Элемент TabControl
        // Следующий селектор, TabControl, полезен для переключения между страницами содержимого.
        // Обычно вкладки располагаются вдоль верхнего края, но свойство TabStripPlacment (типа Dock) позволяет разместить их слева (Left), справа (Right) или снизу (Bottom).
        // В отличие от других селекторов, первый элемент TabItem по умолчанию оказывается выбранным.
        // Однако в программе можно сделать все вкладки невыбранными, записав значение null в свойство SelectedItem или значение -1 в свойство SelectedIndex.

        // Элемент DataGrid
        // DataGrid – весьма гибкий элемент управления для отображения данных в виде таблицы с несколькими столбцами, допускающей сортировку, редактирование и многое другое.
        // Он оптимизирован для связывания с таблицей базы данных в памяти (например, типа System.Data.DataTable из ADO.NET).
        // Мастера Visual Studio и такие технологии, как LINQ to SQL, предельно упрощают такое связывание.
        // Элемент DataGrid автоматически поддерживает изменение порядка и размера столбцов и сортировку по столбцам, но любую возможность можно отключить, установив значение false для некоторых из следующих свойств: CanUserReorderColumns, CanUserResizeColumns, CanUserResizeRows и CanUserSortColumns.
        // Свойства GridLinesVisibility и HeadersVisibility позволяют отключить показ линий сетки и заголовков соответственно.
        // Типы столбцов, поддерживаемые элементом DataGrid:
        // - DataGridTextColumn – идеален для представления строк, поскольку в обычном режиме используется элемент TextBlock, а в режиме редактирования – элемент TextBox.
        // - DataGridHyperlinkColumn – представляет обычный текст в виде гиперссылки, по которой можно щелкнуть.
        // Отметим, однако, что со щелчком не ассоциируется никакое поведениепо умолчанию (например, открытие браузера).
        // Эти действия вы должны обрабатывать явно.
        // - DataGridCheckBoxColumn – идеален для представления булевских значений, поскольку используется элемент CheckBox, который в отмеченном состоянии соответствует значению true, а в сброшенном – значению false.
        // - DataGridComboBoxColumn – идеален для представления перечислений, поскольку в обычном режиме используется элемент TextBlock, а в режиме редактирования – элемент ComboBox, содержащий все возможные значения.
        // - DataGridTemplateColumn – позволяет задать произвольные шаблоны для представления значения в обычном режиме и в режиме редактирования.
        // Делается это с помощью свойств CellTemplate и CellEditingTemplate.

        // Автоматически генерируемые столбцы
        // Если объекты, отображаемые в элементе DataGrid, задаются с помощью свойства ItemsSource, то элемент пытается автоматически сгенерировать соответствующие столбцы.
        // В таком случае для представления строк выбирается столбец типа DataGridTextColumn, для представления URI – столбец типа DataGridHyperlinkColumn, для представления булевских величин – столбец типа DataGridCheckBoxColumn, а для представления перечислений – столбец типа DataGridComboBoxColumn (при этом источник данных для значений перечисления присоединяется автоматически).
        
        // Выбор строк и ячеек
        // Элемент DataGrid поддерживает несколько моделей выбора с помощью двух свойств – SelectionMode и SelectionUnit.
        // Свойству SelectionMode можно присвоить значение Single – тогда разрешено выбирать только один объект, или значение Extended – в этом случае можно выбирать несколько объектов (это режим по умолчанию).
        // Определение слова «объект» зависит от значения свойства SelectionUnit:
        // - Cell – разрешено выбирать только отдельные ячейки.
        // - FullRow – разрешено выбирать только строки целиком.
        // - CellOrRowHeader – разрешено выбирать и то и другое (для выбора всей строки следует щелкнуть по ее заголовку).
        // При выборе строк генерируется событие Selected, а свойство SelectedItems содержит коллекцию выбранных объектов.
        // Для элемента DataGrid это была бы коллекция объектов типа Record.
        // При выборе отдельных ячеек генерируется событие SelectedCellChanged, а свойство SelectedCells содержит список структур DataGridCellInfo, в которых хранится информация о соответствующих строках и столбцах.
        // Выбираемые объекты DataGridRow и DataGridCell также генерируют свои события Selected, а их свойство IsSelected принимает значение true.
        // Даже если выбрано несколько ячеек или строк, в каждый момент времени фокус может принадлежать только одной ячейке.
        // Получить или установить эту ячейку позволяет свойство CurrentCell.
        // Кроме того, свойство CurrentColumn позволяет определить, в каком столбце находится ячейка CurrentCell, а свойство CurrentItem возвращает объект данных, соответствующий строке, которая содержит ячейку CurrentCell.

        // Дополнительные настройки
        // Класс DataGrid поддерживает и другие способы настройки, например взаимодействие с буфером обмена, виртуализацию, возможность выводить дополнительную информацию для строк и «замораживать » столбцы.
        // Взаимодействие с буфером обмена.
        // Настроить, какие именно данные копируются из DataGrid в буфер обмена (например, при нажатии Ctrl+C после выбора объектов), позволяет свойство ClipboardCopyMode.
        // Оно может принимать следующие значения:
        // - ExcludeHeader – не включать заголовки столбцов в копируемый текст. Это режим по умолчанию.
        // - IncludeHeader – включать заголовки столбцов в копируемый текст.
        // - None – ничего не копировать в буфер обмена.
        // Виртуализация.
        // По умолчанию строки DataGrid виртуализируются (объекты UIElement не создаются для строк, невидимых на экране, причем в зависимости от источника данных даже выборка данных для этих строк может откладываться), а столбцы – нет. 
        // Для изменения этого поведения предназначены свойства EnableRowVirtualization (если оно равно false, то строки не виртуализируются) и EnableColumnVirtualization (если оно равно true, то столбцы виртуализируются).
        // Свойство EnableColumnVirtualization по умолчанию не равно true, потому что в этом режиме может замедляться обновление изображения при горизонтальной прокрутке.
        // Дополнительная информация для строк.
        // Элемент DataGrid поддерживает показ дополнительной информации в строках за счет установки свойства RowDetailsTemplate.
        // По умолчанию дополнительная информация показывается только для выбранной строки (или строк), но это поведение можно изменить с помощью свойства RowDetailsVisibilityMode, принимающего следующие значения:
        // - VisibleWhenSelected – дополнительная информация показывается только для выбранных строк. Это режим по умолчанию.
        // - Visible – дополнительная информация показывается для всех строк.
        // - Collapsed – дополнительная информация вообще не показывается.
        // Замораживание столбцов.
        // Элемент DataGrid позволяет заморозить любое число столбцов.
        // Это означает, что они не будут выдвинуты за пределы области элемента при горизонтальной прокрутке.
        // Но имеется несколько ограничений: замораживать можно только самые левые столбцы и замороженные столбцы нельзя менять местами с незамороженными.
        // Можно ли в DataGrid замораживать строки?
        // Нет, такая возможность не предусмотрена. Автоматически заморозить можно только дополнительную информацию для строк.
        // Если свойство AreRowDetailsFrozen равно true, то вся показанная дополнительная информация не смещается при горизонтальной прокрутке.

        // Редактирование, добавление и удаление данных
        // Поскольку коллекция ItemsSource допускает также добавление и удаление объектов, то DataGrid автоматически поддерживает и эти операции.
        // Хотя вход в режим редактирования (и переключение ячейки в такой режим) производится автоматически, по ходу дела возникает несколько событий, позволяющих вмешаться в этот процесс: PreparingCellForEdit, BeginningEdit, CellEditEnding/RowEditEnding и InitializeNewItem.
        // ПРЕДУПРЕЖДЕНИЕ
        // Свойства CanUserAddRows и CanUserDeleteRows могут быть автоматически сброшены в false!
        // В зависимости от значений прочих свойств, свойства CanUserAddRows и CanUserDeleteRows могут оказаться равными false, хотя для них было явно установлено значение true!
        // Например, если свойство IsReadOnly или IsEnabled элемента DataGrid равно false, то будут равны false и оба вышеупомянутых свойства.
        // Есть и менее очевидный случай: если источник данных не поддерживает добавление или удаление (на что указывают свойства CanAddNew и CanRemove, определенные в интерфейсе IEditableCollectionView), то и CanUserAddRows, и CanUserDeleteRows будут равны false.

        // Меню
        // В WPF имеются оба элемента, относящихся к меню: Menu и ContextMenu.
        // Элемент Menu
        // Элемент Menu располагает хранящиеся в нем объекты по горизонтали в строке характерного серого цвета (по умолчанию).
        // К своему базовому классу ItemsControl класс Menu добавляет только свойство IsMainMenu.
        // Если оно равно true (случай по умолчанию), то меню Menu получает фокус при нажатии клавиши Alt или F10.
        // Поскольку Menu – обычный многодетный элемент управления, то в качестве объектов в нем может храниться все что угодно, хотя предполагается, что это будут объекты типа MenuItem или Separator.
        // Класс MenuItem относится к многодетным элементам управления с заголовком (наследует классу HeaderedItemsControl) и во многом напоминает однодетные элементы управления с заголовком.
        // В случае MenuItem свойство Header представляет собой основной объект. В коллекции Items, если она непустая, хранятся дочерние элементы, отображаемые в виде подменю.
        // Так же как Button и Label, класс MenuItem поддерживает клавиши доступа, обозначаемые предшествующим знаком подчеркивания.
        // Separator – это простой элемент управления, который, будучи помещен в MenuItem, визуализируется в виде горизонтальной черты.
        // Этот класс может использоваться и в двух других многодетных элементах: ToolBar и StatusBar.
        // Хотя Menu – простой элемент управления, класс MenuItem содержит много свойств для настройки своего поведения. Приведем наиболее интересные.
        // - Icon – позволяет добавлять произвольный объект, отображаемый рядом с заголовком Header. Объект Icon визуализируется так же, как Header, хотя обычно представляет собой небольшое изображение.
        // - IsCheckable – наделяет MenuItem поведением флажка CheckBox.
        // - InputGestureText – позволяет аннотировать элемент меню ассоциированным с ним жестом (чаще всего какой-нибудь комбинацией клавиш, например Ctrl+O).
        // В классе MenuItem определено также пять событий: Checked, Unchecked, SubmenuOpened, SubmenuClosed и Click.
        // Обычно для наделения пункта меню поведением применяется обработчик события Click, но можно также записать команду в свойство Command объекта MenuItem.
        // ПРЕДУПРЕЖДЕНИЕ
        // Задание свойства InputGestureText не ассоциирует с MenuItem соответствующую комбинацию клавиш!
        // запись в свойство InputGestureText элемента MenuItem строки вида "Ctrl+O" еще не означает, что при нажатии комбинации клавиш Ctrl+O будет автоматически вызван данный пункт меню!
        // Эта строка – не более чем документация.
        // Чтобы связать с MenuItem комбинацию клавиш, необходимо ассоциировать ее с командой с помощью свойства Command.
        // Если с командой ассоциирован некий жест ввода, то в свойство InputGestureText объекта MenuItem автоматически записывается соответствующая ему строка, то есть текстовое представление комбинации клавиш отображается без каких-либо дополнительных действий.
        // СОВЕТ
        // Когда свойству Command объекта MenuItem присваивается ссылка на объект типа RoutedUICommand, в его свойство Header автоматически записывается значение свойства Text команды.
        // Это поведение можно переопределить, установив заголовок Header явно.
        // FAQ
        // Как расположить пункты Menu по вертикали, а не по горизонтали?
        // Поскольку Menu – обычный многодетный элемент управления, можно воспользоваться описанным выше при рассмотрении ListBox приемом – подменой панели ItemsPanel, только подразумеваемую по умолчанию панель следует заменить на StackPanel.
        // Если вы хотите, чтобы пункты меню были еще и повернуты на 90° (как в старых программах из пакета Microsoft Office в случае, когда меню перетаскивается и пристыковывается к левой или правой стороне окна), то воспользуйтесь преобразованием RotateTransform.

        // Элемент ContextMenu
        // Элемент ContextMenu работает так же, как Menu; это простой контейнер, предназначенный для хранения пунктов меню MenuItem и разделителей Separator.
        // Однако же включать ContextMenu непосредственно в дерево элементов нельзя. Следует связывать его с элементом управления посредством подходящего присоединенного свойства, например свойства ContextMenu в классах FrameworkElement и FrameworkContentElement.
        // Помимо ожидаемого свойства IsOpen и событий Opened/Closed, в классе ContextMenu определено еще много свойств для настройки местоположения меню.
        // По умолчанию левый верхний угол меню совпадает с позицией указателя мыши. Но свойство Placement можетпринимать и другие значения, кроме MousePoint (например, Absolute).
        // К тому же с помощью свойств HorizontalOffset и VerticalOffset можно задавать смещение от указателя по горизонтали и вертикали.
        // FAQ
        // Как сделать, чтобы контекстное меню появлялось при щелчке правой кнопкой мыши по неактивному элементу?
        // Как и ToolTipService, класс ContextMenuService содержит присоединенное свойство ShowOnDisabled специально для этой цели.
        // Напомним, что с классом ToolTip связан статический класс ToolTipService, позволяющий управлять свойствами всплывающей подсказки из элемента, с которым она ассоциирована.
        // Точно так же с классом ContextMenu связан статический класс ContextMenuService, предназначенный для той же цели.
        // В нем имеется несколько присоединенных свойств, соответствующих свойствам, определенным в самом классе ContextMenu.

        // Другие многодетные элементы управления
        // Оставшиеся многодетные элементы управления – TreeView, ToolBar и StatusBar – не являются ни селекторами, ни меню, но тем не менее могут содержать неограниченное число произвольных объектов.

        // Элемент TreeView
        // TreeView – популярный элемент управления, предназначенный для отображения иерархически организованных данных с возможностью раскрывать и сворачивать узлы дерева.
        // В теме Aero состояние узлов обозначается треугольничками, в других темах, например Luna, – привычными  наками плюс и минус.
        // TreeView, как и Menu, – очень простой элемент управления. Он может содержать любые объекты и располагает их по вертикали.
        // Однако от TreeView мало пользы, если в нем хранится что-то, кроме объектов типа TreeViewItem.
        // TreeViewItem, как и MenuItem, – многодетный элемент управления с заголовком. В его свойстве Header хранится сам элемент, а в коллекции Items – его подэлементы (предполагается, что они также являются объектами типа TreeViewItem).
        // В классе TreeViewItem имеются удобные свойства IsExpanded и IsSelected, а также четыре события, соответствующие четырем возможным состояниям этих свойств: Expanded, Collapsed, Selected и Unselected.
        // КОПНЕМ ГЛУБЖЕ
        // Сравнение классов TreeView и Selector
        // С точки зрения API класс TreeView очень похож на класс Selector, но не является производным от него, потому что для иерархически организованных объектов не существует естественного понятия целочисленного индекса.
        // Поэтому в TreeView определены собственные свойства SelectedItem и SelectedValue (но не SelectedIndex). Также определено событие SelectedItemChanged, вместе с которым обработчику передаются не коллекции, а просто объекты OldValue и NewValue, поскольку TreeView поддерживает выбор толькоодного объекта.
        // Отсутствие поддержки для выбора нескольких объектов – досадное ограничение, сохранившееся и в версии WPF 4. Если вам это необходимо, то можете воспользоваться каким-нибудь сторонним элементом управления, например RadTreeView.
        // СОВЕТ
        // В версии WPF 4 класс TreeView начал поддерживать виртуализацию, но включать ее нужно явно – путем установки для присоединенного свойства VirtualizingStackPanel.IsVirtualizing объекта TreeView значения true.
        // Этот режим позволяетзаметно сэкономить память и повысить производительность прокрутки, когда количество узлов очень велико.
        // ПРЕДУПРЕЖДЕНИЕ
        // Всегда явно обертывайте узлы TreeView элементами TreeViewItem!

        // Элемент ToolBar
        // Элемент управления ToolBar (панель инструментов) обычно применяется для группировки небольших кнопок (или других элементов управления) и служит дополнением к традиционной системе меню.
        // Элементы ToolBar могут находиться в любом месте дерева элементов, но обычно их помещают в специальный контейнер ToolBarTray, производный от FrameworkElement.
        // Объект ToolBarTray содержит коллекцию элементов ToolBar и, если его свойство IsLocked не равно true, позволяет перетаскивать панели инструментов и располагать их в другом месте.
        // Если панель инструментов ToolBar содержит больше элементов, чем помещается в занимаемой ею области, то лишние попадают в область переполнения.
        // этим поведением можно управлять с помощью присоединенного свойства OverflowMode из класса ToolBar.
        // С его помощью можно определить, что элемент должен перемещаться в область переполнения по мере необходимости (AsNeeded – по умолчанию), всегда (Always) или никогда (Never).
        // СОВЕТ
        // Чтобы создать настраиваемую панель инструментов, как в Visual Studio, присвойте свойству ToolBar.OverflowMode значение Never для каждого элемента, затем добавьте элемент Menu с заголовком "_Add or Remove Buttons" (Добавить или удалить кнопки), для которого свойство ToolBar.OverflowMode должно быть равно Always (чтобы он всегда оставался в области переполнения).
        // Далее в это меню можно добавить пункты MenuItem и сделать так, чтобы отметка флажка в таком пункте приводила к добавлению соответствующего пункта на панель инструментов, а сброс флажка – к убиранию элемента с панели.
        // СОВЕТ
        // Если элемент содержит небольшой значок, то имеет смысл задать для него присоединенное свойство RenderOptions.BitmapScalingMode, равное NearestNeighbor.
        // Тогда изображение будет выглядеть гораздо четче, чем в обычном режиме прорисовки. 
        // Рассматриваемая в этом разделе панель ToolBar визуализируется именно в таком режиме.
        // КОПНЕМ ГЛУБЖЕ
        // Настройка навигации с помощью клавиатуры
        // В классе KeyboardNavigation из пространства имен System.Windows.Input определено несколько полезных присоединенных свойств для настройки этого и других аспектов поведения клавиатуры.
        // Например, чтобы избежать зацикливания при нажатии клавиши Tab на панели инструментов, можно присвоить свойству KeyboardNavigation.TabNavigation для элемента ToolBar значение Continue (вместо Cycle).
        // А чтобы не попасть в цикл при навигации по меню с помощью клавиш со стрелками, задайте для элемента Menu свойство KeyboardNavigation.DirectionalNavigation, равное Continue.
        // КОПНЕМ ГЛУБЖЕ
        // Неиспользуемое свойство Header элемента ToolBar
        // На самом деле ToolBar – многодетный элемент управления с заголовком (как MenuItem и TreeViewItem). Его свойство Header никогда не отображается, но может быть полезно для реализации дополнительных возможностей ToolBarTray.
        // Например, можно добавить контекстное меню, в котором перечислены все панели инструментов ToolBar (представленные своими заголовками Header), дав пользователям возможность добавлять или удалять панели.
        // Или реализовать перемещаемые панели инструментов и показывать заголовок, когда панель «плавает».

        // Элемент StatusBar
        // Элемент StatusBar ведет себя, как Menu, но располагает своих потомков по горизонтали.
        // Обычно его помещают вдоль нижнего края окна Window и используют для отображения информации о состоянии.
        // По умолчанию StatusBar переопределяет шаблон элемента управления Separator так, что он отображается в виде вертикальной линии, как на панели инструментов ToolBar.
        // Дочерние элементы StatusBar (кроме Separator) неявно обертываются объектами StatusBarItem, но можно включить их и явно.
        // FAQ
        // Как сделать, чтобы секции строки состояния пропорционально растягивались?
        // Добиться этого эффекта можно, заменив внутреннюю панель ItemsPanel сеткой Grid. 
        // Отметим, что к элементам внутри StatusBar необходимо явно присоединять свойство Grid.Column (которое имеет смысл, только если в качестве ItemsPanel используется Grid), иначе все они окажутся в столбце с индексом 0.
        // Кроме того, имейте в виду, что такие свойства компоновки работают только для потомков типа StatusBarItem и Separator.
        // Дело в том, что остальные элементы (Label, ComboBox и Button в рассматриваемом примере StatusBar) неявно обернуты объектами StatusBarItem, к которым нужные свойства не присоединены.
        // Поэтому, чтобы добиться требуемого эффекта, необходимо обернуть их в StatusBarItem явно.

        // 11 Изображения, текст и другие элементы управления
        // Элемент управления Image
        // К элементу Image можно присоединить свойство RenderOptions.BitmapScalingMode, задающее компромисс между скоростью и качеством визуализации.
        // СОВЕТ
        // Вместо того чтобы пользоваться конвертером типа для преобразования строкового имени файла в объект ImageSource, можно явно присвоить свойству Source объекта Image ссылку на объект одного из подклассов ImageSource, что открывает дополнительные возможности.

        // Элементы управления Text и Ink
        // Главное, о чем нужно знать, – это присоединенное свойство TextOptions.TextFormattingMode.
        // Его можно задавать как для отдельных текстовых элементов, так и – что практикуется чаще – для родительского элемента, например Window; в последнем случае оно распространяется на визуализацию текста во всем дереве элементов-потомков.
        // Присоединенному свойству TextOptions.TextRenderingMode можно присвоить значение ClearType, Grayscale, Aliased или Auto – для управления режимом сглаживания текста (antialiasing). При заданном значении Auto (по умолчанию) будет действовать режим ClearType, если эта технология не отключена на данном компьютере, в противном случае – режим Grayscale.
        // FAQ
        // Не следует ли всегда задавать значение Display свойства TextFormattingMode, чтобы оптимизировать визуализацию текста?
        // Нет. Если текст отображается достаточно крупным кеглем (FontSize порядка 15 или больше), то режим Ideal дает такое же четкое изображение, как режим Display, а глифы располагаются лучше.
        // Но еще важнее то, что в случае применения к тексту геометрического преобразования режим Display оказывается хуже, поскольку выравнивание на границы пикселов больше не применяется.
        
        // Элемент TextBlock
        // У элемента TextBlock есть ряд простых свойств, модифицирующих его внешний вид, например FontFamily, FontSize, FontStyle, FontWeight и FontStretch.
        // КОПНЕМ ГЛУБЖЕ
        // TextBlock и пустое пространство
        // Если содержимое TextBlock устанавливается с помощью свойства Text, то все символы пробела сохраняются.
        // Если же оно устанавливается с помощью свойства Inlines в XAML, то пустое пространство не сохраняется.
        // СОВЕТ
        // При добавлении содержимого в свойство Inlines элемента TextBlock его неформатированное представление дописывается в конец свойства Text.
        // Поэтому программа по-прежнему может пользоваться свойством Text, даже если явно устанавливается только Inlines.
        // КОПНЕМ ГЛУБЖЕ
        // Явно и неявно заданные фрагменты Run

        // Элемент TextBox
        // Хотя на первый взгляд TextBox выглядит очень просто, в него встроена весьма развитая функциональность, привязки для команд Cut, Copy, Paste, Undo и Redo и даже проверка правописания.
        // В классе TextBox определено несколько методов и свойств для выбора различных частей текста.
        // Определены также события TextChanged и SelectionChanged.
        // FAQ
        // Как сделать, чтобы элемент TextBox поддерживал ввод нескольких строк текста?
        // Если присвоить свойству AcceptsReturn значение true, то при нажатии клавиши Enter будет создаваться новая строка.
        // КОПНЕМ ГЛУБЖЕ
        // Проверка правописания
        // Чтобы включить проверку правописания в TextBox (или RichTextBox), необходимо присвоить присоединенному свойству SpellCheck.IsEnabled значение true.

        // Элемент RichTextBox
        // Элемент RichTextBox предоставляет больше возможностей, чем TextBox, поскольку может содержать форматированный текст.
        
        // Элемент PasswordBox
        // Если вам не нравятся кружочки, можете выбрать другой символ с помощью свойства PasswordChar.
        // При изменении пароля генерируется событие TextboxPasswordChanged.
        // Его обработчик имеет тип RoutedEventHandler, то есть вместе с событием не передается информация о старом и новом паролях.
        // Если нужно узнать текущий пароль, можно просто опросить внутри обработчика свойство Password.
        
        // Элемент InkCanvas
        // Основная задача поразительно гибкого элемента InkCanvas – предоставить средства для рукописного ввода.
        // Свойство DefaultDrawingAttributes позволяет изменить внешний вид будущих штрихов
        // Элемент InkCanvas поддерживает несколько режимов, которые можно независимо применять к заостренному концу стилуса (или к мыши) – посредством свойства EditingMode – и к обратному его концу – с помощью свойства EditingModeInverted.
        // Предназначенное только для чтения свойство ActiveEditingMode сообщает, какой режим действует в данный момент.
        // Все три эти свойства имеют тип перечисления InkCanvasEditingMode, в котором определены следующие значения:
        // - Ink – рисование штрихов мышью или стилусом. Это подразумеваемое по умолчанию значение свойства EditingMode.
        // - InkAndGesture – аналогично Ink, но распознает также жесты пользователя. Список поддерживаемых жестов (Up, Down, Circle, ScratchOut, Tap и др.) определен в перечислении System.Windows.Ink.ApplicationGesture.
        // - GestureOnly – только распознает жесты, никакие штрихи не рисуются.
        // - EraseByStroke – стирает весь штрих, которого коснулся стилус. Это подразумеваемое по умолчанию значение свойства EditingModeInverted.
        // - EraseByPoint – стирает только часть штриха, находящуюся непосредственно под стилусом (как обычный ластик).
        // - Select – выделяет штрихи или другие элементы UIElement при касании, так чтобы впоследствии сразу ко всем можно было применить операцию удаления, перемещения или изменения размеров в границах InkCanvas.
        // - None – никак не реагирует на попытки ввода данных мышью или стилусом.

        // Документы
        // Создание потоковых документов
        // Простой потоковый документ
        // Класс Block
        // В WPF есть пять типов блоков:
        // - Paragraph – содержит коллекцию Inlines, которая обычно и составляет содержание документа.
        // В XAML содержимым элемента Paragraph часто бывает простой текст, но внутри система обертывает этот текст объектом класса Run, производного от Inline, который и добавляется в коллекцию Inlines – так же, как в случае TextBlock.
        // - Section – группирует один или несколько блоков, не вводя никакой дополнительной структуры.
        // Это удобно, когда нужно применить к нескольким блокам одно и то же значение некоторого свойства, например Background или Foreground.
        // - List – представляет коллекцию объектов типа ListItem в виде маркированного, нумерованного или простого списка.
        // - Table – располагает содержимое в виде таблицы из строк и столбцов, наподобие Grid, но все же ближе к HTML-таблице.
        // - BlockUIContainer – содержит единственный элемент UIElement.
        // Поэтому BlockUIContainer – ключ к размещению разнообразного WPF-содержимого внутри FlowDocument: изображений Image, видео, содержащегося внутри MediaElement, кнопок Button, трехмерной графики внутри элемента Viewport3D и т. д.
        // Класс Inline
        // Элементы Inline могут находиться внутри Paragraph, позволяя добавлять к тексту эффектное форматирование.
        // Отрезки. Наиболее распространенными отрезками являются элементы Bold, Italic, Underline и уже знакомый Hyperlink.
        // СОВЕТ
        // Так как TextBlock хранит свое содержимое в виде коллекции Inline, то можно было бы заменить теги Paragraph в показанной выше разметке фрагментами с тегами TextBlock, и все работало бы по-прежнему.
        // Заякоренные блоки.
        // WPF содержит два подкласса Inline, необычных тем, что они используются как контейнеры для элементов Block.
        // Это классы Figure и Floater – оба наследующие абстрактному классу AnchoredBlock.
        // Прочие элементы Inline. Два оставшихся элемента Inline не имеют ничего общего за исключением того факта, что они не наследуют ни одному из классов Span или AnchoredBlock. 
        // СОВЕТ
        // Чтобы вставить в FlowDocument разрыв не строки, а страницы, задайте свойство BreakPageBefore для того элемента Paragraph, перед которым нужно перейти на новую страницу.
        // Свойство BreakPageBefore определено в классе Block, так что применимо также к Section, List, BlockUIContainer и Table.

        // Отображение потоковых документов
        // WPF предлагает три дополнительных элемента для отображения потоковых документов.
        // - FlowDocumentScrollViewer – отображает документ как один непрерывный файл с полосой прокрутки, как в режиме веб-документа в Microsoft Word
        // - FlowDocumentPageViewer – отображает документ в виде набора отдельных страниц, как в режиме полноэкранного чтения в Microsoft Word.
        // - FlowDocumentReader – объединяет FlowDocumentScrollViewer и FlowDocumentPageViewer в один элемент управления и предлагает дополнительную функциональность, в частности встроенный текстовый поиск.
        
        // Добавление комментариев
        // Конструировать свой интерфейс для ввода комментариев утомительно, но не слишком трудно.
        // На помощь приходит класс AnnotationService в пространстве имен System.Windows.Annotations, в котором имеются команды для всех нужных функций:
        // - CreateTextStickyNoteCommand присоединяет новый текстовый элемент StickyNoteControl в качестве комментария к выделенному тексту.
        // - CreateInkStickyNoteCommand присоединяет новый рукописный элемент StickyNoteControl в качестве комментария к выделенному тексту.
        // - DeleteStickyNotesCommand удаляет выделенные в данный момент элементы StickyNoteControl.
        // - CreateHighlightCommand подсвечивает выделенный текст цветом, переданным команде в качестве параметра.
        // - ClearHighlightsCommand удаляет подсветку с выделенного в данный момент текста.
        // СОВЕТ
        // Элементы StickyNoteControl, которыми представлены комментарии, – это полноценные элементы управления WPF (находятся в пространстве имен System.Windows.Controls).
        // Поэтому их внешний облик можно полностью изменить, задав другой шаблон.

        // Диапазонные элементы управления
        // 385


    }
}
