using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed.Testing
{
    /// <summary>
    /// Interaction logic for Testing.xaml
    /// </summary>
    public partial class Testing : Window
    {
        public Testing()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Panel.Panels window = new Panel.Panels();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Events.Events window = new Events.Events();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            MyApp window = new MyApp();
            window.Show();
        }

        private void Button_Click_2(object sender, RoutedEventArgs e)
        {
            Deployment.Deployment window = new Deployment.Deployment();
            window.Show();
        }

        private void Button_Click_4(object sender, RoutedEventArgs e)
        {
            OneChildControls.OneChildControls window = new OneChildControls.OneChildControls();
            window.Show();
        }


        // 4 Задание размера, положения и преобразований элементов


        // 5 Панели
        // StackPanel
        // В отсутствие присоединенных свойств единственный способ организовать дочерние элементы – воспользоваться свойством панели Orientation

        // WrapPanel
        // Панель WrapPanel похожа на StackPanel. Но помимо организации дочерних элементов в стопку она создает новые строки или столбцы, когда для одной стопки не хватает места.
        // В классе WrapPanel определены три свойства, контролирующие его поведение:
        // - Orientation – аналогично одноименному свойству StackPanel с тем отличием, что по умолчанию подразумевается значение Horizontal.
        // - ItemHeight – единая высота для всех дочерних элементов. Каким образом каждый потомок распоряжается этой высотой, зависит от значений его свойств VerticalAlignment, Height и пр. Элементы, ширина которых превышает ItemHeight, отсекаются.
        // - ItemWidth – единая ширина для всех дочерних элементов. Каким образом каждый потомок распоряжается этой шириной, зависит от значений его свойств HorizontalAlignment, Width и пр. Элементы, высота которых превышает ItemWidth, отсекаются.

        // DockPanel
        // Панель DockPanel дает простой способ пристыковки элемента к одной из сторон, растягивая его на всю имеющуюся ширину или высоту.
        // В классе DockPanel определено присоединенное свойство Dock, с помощью которого дочерние элементы могут управлять своим положением.
        // Оно может принимать четыре значения: Left (подразумевается по умолчанию, если свойство Dock не задано явно), Top, Right и Bottom.
        // Отметим, что у свойства Dock нет значения Fill, означающего, что нужно заполнить оставшееся место.
        // Вместо этого действует соглашение о том, что все оставшееся место отдается последнему дочернему элементу, добавленному в DockPanel, если только свойство LastChildFill не равно false.

        // Grid
        // По умолчанию свойства RowSpan и ColumnSpan равны 1, но могут принимать любое значение, большее или равное 1, – соответственно количество строк или столбцов, занимаемых данной ячейкой.
        // Такой автоматический выбор размера достигается путем присваивания свойствам Height и Width соответственно в элементах RowDefinition и ColumnDefinition специального значения Auto, нечувствительного к регистру букв.
        // панель Grid поддерживает три способа задания размера в элементах RowDefinition и ColumnDefinition:
        // - Абсолютный размер – числовое значение Height или Width означает, что размер задан в независимых от устройства пикселах
        // - Автоматический выбор размера – если Height или Width равно Auto, то дочерним элементам выделяется столько места, сколько необходимо, но не больше.
        // - Пропорциональное изменение размера – предусмотрен специальный синтаксис задания свойств Height и Width, позволяющий распределить имеющееся пространство поровну или в соответствии с заданными пропорциями 
        // Звездочка работает следующим образом:
        // - Если высота строки или ширина столбца равна *, то соответствующему структурному элементу выделяется все оставшееся место.
        // - Если размер * задан для нескольких строк или столбцов, то все оставшееся место делится между ними поровну.
        // - Перед символом * можно указывать коэффициент (например, 2* или 5.5*), тогда соответствующей строке или столбцу будет выделено пропорционально больше места, чем остальным строкам или столбцам, в размере которых присутствует символ *.
        // Интерактивное задание размера с помощью GridSplitter
        // В классах RowDefinitions и ColumnDefinitions имеется свойство SharedSizeGroup, позволяющее задать режим, при котором линейные размеры нескольких строк и/или столбцов будут оставаться одинаковыми даже в случае, когда размер любой из них изменяется в процессе выполнения программы
        // Свойство IsSharedSizeScope следует установить потому, что группы размеров могут применяться сразу к нескольким сеткам!

        // Обработка переполнения содержимого
        // Для ее разрешения можно применять различные стратегии:
        // • отсечение
        // • прокрутку
        // • масштабирование
        // • оборачивание
        // • обрезку

        // Отсечение
        // Отсечение дочерних элементов – это тот способ, который панели применяют по умолчанию, когда потомков становится слишком много.
        // Во всех классах, производных от UIElement, есть булевское свойство ClipToBounds, которое управляет тем, можно ли рисовать дочерние элементы вне границ родителя.
        // Однако, если внешний край элемента совпадает с внешним краем Window или Page, отсечение все равно производится.

        // Прокрутка
        // стоит поместить элемент внутрь элемента управления System.Windows.Controls.ScrollViewer, как он сразу же становится прокручиваемым.
        // В классе ScrollViewer имеется еще ряд свойств и методов для манипулирования из программы, но самыми важными являются свойства VerticalScrollBarVisibility и HorizontalScrollBarVisibility.
        // Оба они имеют тип перечисления ScrollBarVisibility, которое определяет четыре состояния полосы прокрутки:
        // - Visible – полоса прокрутки всегда присутствует, даже если она не нужна. Если необходимости в ней нет, то она выглядит неактивной и не реагирует на события ввода.
        // - Auto – полоса прокрутки видна, если содержимое нуждается в прокрутке в данном направлении. В противном случае полоса прокрутки отсутствует.
        // - Hidden – полоса прокрутки всегда невидима, но логически существует, то есть содержимое можно прокручивать клавишами со стрелками. Поэтому содержимое полностью доступно в данном направлении.
        // - Disabled – полоса прокрутки не только невидима, но и вообще не существует, то есть прокрутка невозможна ни с помощью клавиатуры, ни посредством мыши. В таком случае доступна только та часть содержимого, которая видна в пределах родителя.
        
        // Масштабирование
        // Класс Viewbox относится к так называемым декораторам, то есть панелеподобным классам, у которых может быть только один дочерний элемент.
        // Но у него также имеется свойство Stretch, позволяющее указать, как в занимаемой области должен масштабироваться единственный дочерний элемент.
        // Это свойство имеет тип перечисления System.Windows.Media.Stretch и может принимать следующие значения:
        // - None – масштабирование не производится вовсе. Результат такой же, как если бы Viewbox вообще не было.
        // - Fill – размеры дочернего элемента устанавливаются такими же, как размеры самого Viewbox. Поэтому отношение сторон дочернего элемента может не сохраняться.
        // - Uniform – дочерний элемент масштабируется так, чтобы он целиком поместился внутри Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении останется пустое место. Этот вариант подразумевается по умолчанию.
        // - UniformToFill – дочерний элемент масштабируется так, чтобы он целиком заполнял Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении содержимое будет отсечено.
        // Второе свойство Viewbox позволяет указать, какие операции разрешены: только уменьшение содержимого, только увеличение или и то и другое.
        // Оно называется StretchDirection, имеет тип перечисления System.Windows.Controls.StretchDirection и может принимать следующие значения:
        // - UpOnly – увеличивает содержимое, если необходимо. Если содержимое уже слишком велико, то Viewbox оставляет текущий размер без изменения.
        // - DownOnly – уменьшает содержимое, если необходимо. Если содержимое уже достаточно мало, то Viewbox оставляет текущий размер без изменения.
        // - Both – увеличивает или уменьшает содержимое в соответствии с заданным значением описанного выше свойства Stretch. Этот вариант подразумевается по умолчанию.

        // Все вместе: создание сворачиваемой, стыкуемой, изменяющей размер панели
        // Все три сетки помещены (куда бы вы думали?) в сетку с одной строкой и одним столбцом, чтобы они могли перекрывать друг друга и вместе с тем растягиваться, занимая все отведенное им место.
        // Z-порядок слоя 0 всегда наименьший, но Z-порядок двух остальных слоев может меняться так, чтобы текущая непристыкованная панель всегда была наверху.


        // 6 События ввода: клавиатура, мышь, стилус и мультисенсорные устройства
        // Маршрутизируемые события
        // - Tunneling – событие сначала возникает в корне дерева, а потом опускается вниз по дереву, заново возникая в каждом элементе на пути к источнику, включая его самого (если туннелирование не будет прервано по дороге в результате пометки события как обработанного)
        // - Bubbling – событие сначала возникает в элементе-источнике, а затем поднимается вверх по дереву, заново возникая в каждом элементе на пути к корню, включая сам корень (если всплытие не будет прервано по дороге в результате пометки события как обработанного)
        // - Direct – событие возникает только в элементе-источнике. Точно так же ведут себя обычные события .NET; различие лишь в том, что к маршрутизируемому событию применяются и другие механизмы, в частности триггеры событий
        // Сигнатуры обработчиков маршрутизируемых событий устроены так же, как сигнатуры всех обработчиков событий в .NET: первый параметр – объект типа System.Object, который обычно называют sender, второй – экземпляр класса, производного от System.EventArgs.
        // Параметр e является объектом класса RoutedEventArgs – подкласса EventArgs, обладающего следующими полезными свойствами:
        // - Source – элемент логического дерева, первоначально сгенерировавший событие.
        // - OriginalSource – элемент визуального дерева, первоначально сгенерировавший событие (например, в случае стандартной кнопки Button это будет дочерний элемент TextBlock или ButtonChrome). 
        // - Handled – булевский флаг, которому можно присвоить значение true и тем самым пометить, что событие обработано. Именно таким способом прерывается туннелирование и всплытие.
        // - RoutedEvent – сам объект маршрутизированного события (например, Button. ClickEvent), который может быть полезен для различения событий в случае, когда один и тот же обработчик используется для обработки разных событий.

        // Маршрутизируемые события в действии
        // Туннелируемые события легко распознать, потому что по принятому соглашению их имена начинаются со слова Preview. Такое событие – также по соглашению – генерируется непосредственно перед парным ему всплывающим.
        // Например, туннелируемое событие PreviewMouseMove генерируется перед всплывающим событием MouseMove.
        // Идея, стоящая за такими парами событий, заключается в том, чтобы дать элементам возможность отменить или иным способом модифицировать событие, которое еще только произойдет.
        // - Window не получает событие MouseRightButtonDown, если щелкнуть по любому элементу списка ListBoxItem. Дело в том, что ListBoxItem сам обрабатывает это событие, равно как и MouseLeftButtonDown (и прерывает всплытие), – это нужно ему для реализации выбора элементов.
        // - Window получает событие MouseRightButtonDown при щелчке по кнопке Button, но никаких изменений во внешнем виде рамкине происходит. Это объясняется структурой стандартного визуального дерева Button. В отличие от элементов Window, Label, ListBox, ListBoxItem и StatusBar, в визуальном дереве Button нет элемента Border.
        // Присоединенные события

        // Перетаскивание
        // Во всех подклассах UIElement определены события для работы с перетаскиванием:
        // - DragEnter, DragOver, DragLeave, а также PreviewDragEnter, PreviewDragOver и PreviewDragLeave
        // - Drop и PreviewDrop
        // - QueryContinueDrag и PreviewQueryContinueDrag
        // Это перетаскивание элемента в буфер обмена и бросание содержимого буфера на элемент в стиле Win32, а не перетаскивание и бросание самих элементов.
        // Элемент может принять участие в перетаскивании, установив значение true для свойства AllowDrop.
        // Обработчикам событий из первых двух наборов передается объект типа DragEventArgs, содержащий следующие свойства и методы:
        // - GetPosition – такой же метод, как в классе MouseEventArgs
        // - Data – свойство типа IDataObject, представляющее перетаскиваемый или бросаемый объект буфера обмена Win32
        // - Effects и AllowedEffects – битовое перечисление DragDropEffects, допускающее произвольную комбинацию флагов Copy, Move, Link, Scroll, All и None
        // - KeyStates – еще одно битовое перечисление (DragDropKeyStates), показывающее, какие кнопки мыши или клавиши-модификаторы были нажаты во время перетаскивания или бросания: LeftMouseButton, RightMouseButton, MiddleMouseButton, ShiftKey, ControlKey, AltKey или None
        // События QueryContinueDrag и PreviewQueryContinueDrag генерируются, если во время перетаскивания изменяется состояние клавиатуры или какой-нибудь кнопки мыши.
        // Это позволяет обработчику без труда отменить всю операцию.
        // Обработчикам этих событий передается объект класса QueryContinueDragEventArgs, имеющий следующие свойства:
        // - KeyStates – аналогично одноименному свойству класса DragEventArgs
        // - EscapePressed – отдельное булевское свойство, показывающее, была ли нажата клавиша Esc
        // Action – свойство, которое обработчик может установить, чтобы определить судьбу операции перетаскивания; принадлежит перечислению DragAction и принимает значение Continue, Drop или Cancel
        
        // Захват мыши
        // К счастью, WPF позволяет любому элементу UIElement в любой момент захватить или освободить мышь.
        // Когда элемент захватил мышь, он получает все события мыши, даже если указатель оказывается вне занимаемой им области.
        // После освобождения мыши поведение событий возвращается в нормальное русло. Для захвата и освобождения мыши предназначены два метода классаUIElement: CaptureMouse и ReleaseMouseCapture.
        // И, разумеется, есть ряд свойств и событий, сообщающих о состоянии захвата мыши, точнее, свойства IsMouseCaptured и IsMouseCaptureWithin и события GotMouseCapture, LostMouseCapture, IsMouseCaptureChanged и IsMouseCaptureWithinChanged.
        // Поэтому для реализации перетаскивания необходимо захватить мышь в обработчике MouseLeftButtonDown и освободить ее в обработчике MouseLeftButtonUp.

        // Команды
        // Мощь механизма команд основывается на трех основных особенностях:
        // - В WPF определено много встроенных команд.
        // - В команды встроена автоматическая поддержка жестов ввода (например, сочетаний клавиш).
        // - Встроенное поведение некоторых элементов управления WPF уже ориентировано на те или иные команды.

        // Встроенные команды
        // Командой называется любой объект, реализующий интерфейс ICommand (из пространства имен System.Windows.Input), в котором объявлены три простых члена:
        // - Execute – метод, который выполняет характерную для команды логику
        // - CanExecute – метод, который возвращает true, если команда активирована, и false, если она деактивирована
        // - CanExecuteChanged – событие, которое генерируется при изменении значения CanExecute
        // Встроенные в WPF команды доступны в виде статических свойств пяти разных классов:
        // - ApplicationCommands – Close, Copy, Cut, Delete, Find, Help, New, Open, Paste, Print,
        // PrintPreview, Properties, Redo, Replace, Save, SaveAs, SelectAll, Stop, Undo и др.
        // - ComponentCommands – MoveDown, MoveLeft, MoveRight, MoveUp, ScrollByLine, ScrollPageDown,
        // ScrollPageLeft, ScrollPageRight, ScrollPageUp, SelectToEnd, SelectToHome,
        // SelectToPageDown, SelectToPageUp и др.
        // - MediaCommands – ChannelDown, ChannelUp, DecreaseVolume, FastForward, IncreaseVolume,
        // MuteVolume, NextTrack, Pause, Play, PreviousTrack, Record, Rewind, Select, Stop и др.
        // - NavigationCommands – BrowseBack, BrowseForward, BrowseHome, BrowseStop, Favorites,
        // FirstPage, GoToPage, LastPage, NextPage, PreviousPage, Refresh, Search, Zoom и др.
        // - EditingCommands – AlignCenter, AlignJustify, AlignLeft, AlignRight, CorrectSpellingError,
        // DecreaseFontSize, DecreaseIndentation, EnterLineBreak, EnterParagraphBreak,
        // IgnoreSpellingError, IncreaseFontSize, IncreaseIndentation, MoveDownByLine,
        // MoveDownByPage, MoveDownByParagraph, MoveLeftByCharacter, MoveLeftByWord,
        // MoveRightByCharacter, MoveRightByWord и др.

        // Элементы управления со встроенными привязками к командам


        // 7 Структурирование и развертывание приложения
        
        // Класс Window
        // Если некое окно хочет сделать другое окно дочерним, оно должно записать в свойство Owner (типа Window) последнего ссылку на себя, но только после того, как родитель уже был показан на экране.
        // Перебрать дочерние окна позволяет доступное только для чтения свойство OwnedWindows.
        // По принятому соглашению управляемые классы содержат защищенные методы OnEventName, по одному для каждого события

        // Класс Application
        // Метод Application.Run
        // [STAThread]
        // public static void Main()
        // {
        //     Application app = new Application();
        //     MainWindow window = new MainWindow();
        //     window.Show();
        //     app.Run(window);
        // }
        // В классе Application есть также очень полезное свойство-коллекция Properties.
        // Как и состояние приложенияили сеанса в ASP.NET, это словарь, предназначенный для удобного хранения произвольных данных(в виде пар ключ/значение), общих для различных окон или других объектов.
        // Например, в приложении Photo Gallery так хранится имя файла текущей выбранной фотографии:
        // myApplication.Properties["CurrentPhotoFilename"] = filename;
        // А получить к нему доступ можно следующим образом:
        // string filename = myApplication.Properties["CurrentPhotoFilename"] as string;
        // Как в WPF создать приложение, которое может существовать в единственном экземпляре?
        // bool mutexIsNew;
        // using (System.Threading.Mutex m = new System.Threading.Mutex(true, uniqueName, out mutexIsNew))
        // {
        // if (mutexIsNew)
        // Это первый экземпляр, запускаем приложение.
        // else
        // Экземпляр уже работает. Выходим!
        // }

        // Диалоговые окна

        // Сохранение и восстановление состояния приложения

        // Страницы и их навигационные контейнеры
        // Элементы Page могут располагаться в одном из двух встроенных навигационных контейнеров: NavigationWindow или Frame.
        // По умолчанию вдоль верхнего края NavigationWindow располагается панель с кнопками Назад/Вперед, а во фрейме ее нет, но в обоих случаях панель можно добавить или убрать с помощью свойства ShowsNavigationUI, содержащегося внутри страницы Page.
        // Кроме того, в классе NavigationWindow имеется свойство ShowsNavigationUI, а в классе Frame – свойство NavigationUIVisibility, оба они позволяют показать или скрыть эту панель вне зависимости от настроек Page.
        // Элемент Page может взаимодействовать со своим навигационным контейнером с помощью класса NavigationService.
        // Чтобы получить экземпляр NavigationService, следует вызвать статический метод NavigationService.GetNavigationService, передав ему экземпляр Page.
        // Но можно поступить и проще, обратившись к свойству NavigationService объекта Page.
        // this.NavigationService.Title = "Main Photo Gallery Page";
        // this.NavigationService.Refresh();

        // Переходы между страницами
        // Есть три основных способа навигации:
        // - Посредством метода Navigate
        // - С помощью гиперссылок (объектов Hyperlink)
        // - С помощью журнала

        // Вызов метода Navigate
        // Перейти к экземпляру страницы 
        // PhotoPage nextPage = new PhotoPage();
        // this.NavigationService.Navigate(nextPage);
        // Или перейти на страницу с заданным URI
        // this.NavigationService.Navigate(new Uri("PhotoPage.xaml", UriKind.Relative));
        
        // Представление метода Navigate в виде двух свойств
        // Чтобы перейти к объекту Page, достаточно установить свойство Content:
        // this.NavigationService.Content = nextPage;
        // this.NavigationService.Source = new Uri("PhotoPage.xaml", UriKind.Relative);

        // Использование элемента Hyperlink
        // Для простых схем навигации в WPF имеется элемент Hyperlink, который ведет себя во многом аналогично гиперссылкам в HTML.
        // <TextBlock>
        // Click <Hyperlink NavigateUri="PhotoPage.xaml">here</Hyperlink> to view the photo.
        // </TextBlock>
        // Совет
        // Если вам нужна гибкость программной навигации в сочетании с удобными средствами автоматического форматирования текста, предоставляемыми классом Hyperlink, то можете указать в Hyperlink фиктивное значение свойства NavigateUri, а потом в обработчике события Click этого элемента вызвать метод Navigate, задав нужный адрес перехода.
        // Совет
        // Класс Hyperlink поддерживает и дополнительные возможности – как и гиперссылки в HTML.
        // Например, для перехода в конкретный фрейм Frame в случае, когда фреймов несколько, следует присвоить свойству TargetName элемента Hyperlink имя нужного фрейма.
        // Чтобы перейти к определенному месту внутри страницы Page (как в HTML-якорях, обозначаемых символом #), достаточно дописать в конец URI символ # и имя любого элемента на целевой странице.
        // в качестве значения HREF задать какое-нибудь фиктивное значение и написать обработчик события Navigating, в котором динамически изменить цель, вызвав метод Navigate самостоятельно.

        // Использование журнала
        // Отражение навигации в журнале
        // Назад - Помещает текущую страницу в стек прямых переходов, извлекает страницу из стека обратных переходов и переходит на нее
        // Вперед - Помещает текущую страницу в стек обратных переходов, извлекает страницу из стека прямых переходов и переходит на нее
        // Любая другая навигация - Помещает текущую страницу в стек обратных переходов и опустошает стек прямых переходов
        // Действия перехода назад и вперед могут быть инициированы как пользователем, так и программой – путем вызова методов GoBack и GoForward навигационного контейнера (предварительно вызвав соответственно метод CanGoBack или CanGoForward, чтобы избежать исключения в результате попытки извлечения из пустого стека).
        // В объекте NavigationWindow журнал есть всегда, тогда как в объекте Frame собственного журнала может и не быть; это зависит от его свойства JournalOwnership, которое может принимать следующие значения:
        // - OwnsJournal – у фрейма есть свой журнал.
        // - UsesParentJournal – история хранится в журнале родительского контейнера или не хранится вовсе, если у родителя нет журнала.
        // - Automatic – эквивалентно UsesParentJournal, если фрейм содержится в любом из двух навигационных контейнеров (NavigationWindow или Frame), в противном случае эквивалентно OwnsJournal. Это значение по умолчанию.
        // Если у фрейма есть собственный журнал, он получает также встроенные кнопки навигации. Если они вам не нужны, присвойте свойству NavigationUIVisibility значение Hidden.
        // СОВЕТ
        // В случае перехода на страницу Page с помощью URI (неважно, путем вызова метода Navigate или посредством гиперссылки Hyperlink) создается новый экземпляр Page, даже если вы уже посещали эту страницу.
        // Поэтому, если требуется, чтобы страница «запоминала» свои данные, необходимо хранить состояния отдельно (например, в статических переменных или в словаре Application.Properties). (При вызове варианта Navigate, принимающего экземпляр Page, вы, разумеется, вольны сами решать, передать ли ему новый или старый объект.)
        // Однако в случае навигации по журналу можно установить режим принудительного использования одного и того же объекта Page, присвоив его присоединенному свойству JournalEntry.KeepAlive значение true.
        // Совет
        // Объект Page может потребовать не заносить себя в журнал, присвоив своему свойству RemoveFromJournal значение true.
        // Это имеет смысл для страниц, являющихся частью  некоторой последовательности шагов, которые нельзя открывать в произвольном порядке после завершения операции.

        // События навигации
        // Вне зависимости от того, как инициирована навигация – путем вызова метода Navigate, с помощью гиперссылок Hyperlink или по журналу, – она всегда производится асинхронно.
        // В процессе навигации генерируется ряд событий, позволяющих сообщать пользователю подробную информацию или даже прервать навигацию.
        // События навигации, возникающие при загрузке первой страницы:
        // Navigation Container: Initialized -> Navigating -> NavigationProgress -> Loading -> first page initialized -> Navigated -> LoadCompleted -> first page loaded.
        // События навигации, возникающие при переходе от одной страницы к другой:
        // Navigation Container: Navigating -> NavigationProgress -> Loading -> second page Initialized -> first page unloaded -> Navigated -> LoadCompleted -> second page Loaded.
        
        // Передача данных между страницами
        
        // Передача данных странице
        // WPF поддерживает схему, аналогичную параметрам URL, с помощью перегруженных вариантов метода Navigate, которые принимают дополнительный параметр типа Object.
        // int photoId = 10;
        // Перейти к экземпляру Page
        // PhotoPage nextPage = new PhotoPage();
        // this.NavigationService.Navigate(nextPage, photoId);
        // Или перейти к странице по URI
        // this.NavigationService.Navigate(
        // new Uri("PhotoPage.xaml", UriKind.Relative), photoId);

        // Чтобы целевая страница могла получить данные, она должна обработать событие LoadCompleted навигационного контейнера и опросить свойство ExtraData аргумента события:
        // this.NavigationService.LoadCompleted += new LoadCompletedEventHandler(container_LoadCompleted);
        // void container_LoadCompleted(object sender, NavigationEventArgs e)
        // {
        // if (e.ExtraData != null)
        // LoadPhoto((int)e.ExtraData);
        // }
        // Есть и более простой метод:
        // int photoId = 10;
        // Перейти к экземпляру Page
        // PhotoPage nextPage = new PhotoPage(photoId);
        // this.NavigationService.Navigate(nextPage);
        // Третий способ – организовать глобальное обобществление данных с помощью коллекции Properties объекта Application.
        // Такой подход может оказаться удобным, когда нужно сделать данные доступными нескольким страницам (а не просто передать от одной страницыдругой).
        // Однако недостатком, как и в первом случае, является отсутствие строгой типизации.

        // Возврат данных от страницы с помощью PageFunction
        // Классический пример – страница настроек.
        // Достигается это с помощью класса с забавным названием PageFunction.
        // <PageFunction
        // xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        // xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        // xmlns:sys="clr-namespace:System;assembly=mscorlib"
        // x:Class="MyProject.PageFunction1"
        // x:TypeArguments="sys:String"
        // Title="PageFunction1">
        // <Grid>
        // </Grid>
        // </PageFunction>

        // Поскольку PageFunction – подкласс Page, то на элемент этого типа можно переходить точно так же, как на любую другую страницу:
        // PageFunction1 nextPage = new PageFunction1<string>();
        // this.NavigationService.Navigate(nextPage);
        // Для получения возвращенного значения исходная страница должна обработать событие Return объекта PageFunction:
        // nextPage.Return += new ReturnEventHandler<string>(nextPage_Return);
        // ...
        // void nextPage_Return(object sender, ReturnEventArgs<string> e)
        // {
        // string returnValue = e.Result;
        // }
        // Страница, производная от PageFunction, может вернуть данные, обернув их типом ReturnEventArgs и вызвав метод OnReturn, унаследованный от базового класса PageFunction:
        // OnReturn(new ReturnEventArgs<string>("the data"));

        // Приложения-гаджеты

        // XAML-приложения для браузера


        // 8 Особенности Windows 7
        // В .NET для проверки версии операционной системы можно использовать свойство System.Environment.OSVersion. 
        // if (System.Environment.OSVersion.Version.Major >= 6)
        // Windows Vista или более поздняя, используем TaskDialog
        // else
        // Младше Windows Vista, используем MessageBox


        // 9 Однодетные элементы управления
        // Класс Button
        // Класс Button в WPF добавляет к тому, что уже дает ButtonBase, два простых понятия: кнопка отмены и кнопка по умолчанию.
        // Оба удобны для применения в диалоговых окнах. Если для некоторой кнопки, находящейся внутри диалогового окна(ShowDialog),
        // свойство Button.IsCancel равно true, то при нажатии этой кнопки окно автоматически закрывается и свойство DialogResult принимает значение false.

        // Класс RepeatButton
    }
}
