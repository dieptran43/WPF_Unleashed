using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace WPF_Unleashed.Testing
{
    /// <summary>
    /// Interaction logic for Testing.xaml
    /// </summary>
    public partial class Testing : Window
    {
        public Testing()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Panel.Panels window = new Panel.Panels();
            window.Show();
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            Events.Events window = new Events.Events();
            window.Show();
        }

        private void Button_Click_3(object sender, RoutedEventArgs e)
        {
            MyApp window = new MyApp();
            window.Show();
        }


        // 5 Панели
        // StackPanel
        // В отсутствие присоединенных свойств единственный способ организовать дочерние элементы – воспользоваться свойством панели Orientation

        // WrapPanel
        // Панель WrapPanel похожа на StackPanel. Но помимо организации дочерних элементов в стопку она создает новые строки или столбцы, когда для одной стопки не хватает места.
        // В классе WrapPanel определены три свойства, контролирующие его поведение:
        // - Orientation – аналогично одноименному свойству StackPanel с тем отличием, что по умолчанию подразумевается значение Horizontal.
        // - ItemHeight – единая высота для всех дочерних элементов. Каким образом каждый потомок распоряжается этой высотой, зависит от значений его свойств VerticalAlignment, Height и пр. Элементы, ширина которых превышает ItemHeight, отсекаются.
        // - ItemWidth – единая ширина для всех дочерних элементов. Каким образом каждый потомок распоряжается этой шириной, зависит от значений его свойств HorizontalAlignment, Width и пр. Элементы, высота которых превышает ItemWidth, отсекаются.

        // DockPanel
        // Панель DockPanel дает простой способ пристыковки элемента к одной из сторон, растягивая его на всю имеющуюся ширину или высоту.
        // В классе DockPanel определено присоединенное свойство Dock, с помощью которого дочерние элементы могут управлять своим положением.
        // Оно может принимать четыре значения: Left (подразумевается по умолчанию, если свойство Dock не задано явно), Top, Right и Bottom.
        // Отметим, что у свойства Dock нет значения Fill, означающего, что нужно заполнить оставшееся место.
        // Вместо этого действует соглашение о том, что все оставшееся место отдается последнему дочернему элементу, добавленному в DockPanel, если только свойство LastChildFill не равно false.

        // Grid
        // По умолчанию свойства RowSpan и ColumnSpan равны 1, но могут принимать любое значение, большее или равное 1, – соответственно количество строк или столбцов, занимаемых данной ячейкой.
        // Такой автоматический выбор размера достигается путем присваивания свойствам Height и Width соответственно в элементах RowDefinition и ColumnDefinition специального значения Auto, нечувствительного к регистру букв.
        // панель Grid поддерживает три способа задания размера в элементах RowDefinition и ColumnDefinition:
        // - Абсолютный размер – числовое значение Height или Width означает, что размер задан в независимых от устройства пикселах
        // - Автоматический выбор размера – если Height или Width равно Auto, то дочерним элементам выделяется столько места, сколько необходимо, но не больше.
        // - Пропорциональное изменение размера – предусмотрен специальный синтаксис задания свойств Height и Width, позволяющий распределить имеющееся пространство поровну или в соответствии с заданными пропорциями 
        // Звездочка работает следующим образом:
        // - Если высота строки или ширина столбца равна *, то соответствующему структурному элементу выделяется все оставшееся место.
        // - Если размер * задан для нескольких строк или столбцов, то все оставшееся место делится между ними поровну.
        // - Перед символом * можно указывать коэффициент (например, 2* или 5.5*), тогда соответствующей строке или столбцу будет выделено пропорционально больше места, чем остальным строкам или столбцам, в размере которых присутствует символ *.
        // Интерактивное задание размера с помощью GridSplitter
        // В классах RowDefinitions и ColumnDefinitions имеется свойство SharedSizeGroup, позволяющее задать режим, при котором линейные размеры нескольких строк и/или столбцов будут оставаться одинаковыми даже в случае, когда размер любой из них изменяется в процессе выполнения программы
        // Свойство IsSharedSizeScope следует установить потому, что группы размеров могут применяться сразу к нескольким сеткам!

        // Обработка переполнения содержимого
        // Для ее разрешения можно применять различные стратегии:
        // • отсечение
        // • прокрутку
        // • масштабирование
        // • оборачивание
        // • обрезку

        // Отсечение
        // Отсечение дочерних элементов – это тот способ, который панели применяют по умолчанию, когда потомков становится слишком много.
        // Во всех классах, производных от UIElement, есть булевское свойство ClipToBounds, которое управляет тем, можно ли рисовать дочерние элементы вне границ родителя.
        // Однако, если внешний край элемента совпадает с внешним краем Window или Page, отсечение все равно производится.

        // Прокрутка
        // стоит поместить элемент внутрь элемента управления System.Windows.Controls.ScrollViewer, как он сразу же становится прокручиваемым.
        // В классе ScrollViewer имеется еще ряд свойств и методов для манипулирования из программы, но самыми важными являются свойства VerticalScrollBarVisibility и HorizontalScrollBarVisibility.
        // Оба они имеют тип перечисления ScrollBarVisibility, которое определяет четыре состояния полосы прокрутки:
        // - Visible – полоса прокрутки всегда присутствует, даже если она не нужна. Если необходимости в ней нет, то она выглядит неактивной и не реагирует на события ввода.
        // - Auto – полоса прокрутки видна, если содержимое нуждается в прокрутке в данном направлении. В противном случае полоса прокрутки отсутствует.
        // - Hidden – полоса прокрутки всегда невидима, но логически существует, то есть содержимое можно прокручивать клавишами со стрелками. Поэтому содержимое полностью доступно в данном направлении.
        // - Disabled – полоса прокрутки не только невидима, но и вообще не существует, то есть прокрутка невозможна ни с помощью клавиатуры, ни посредством мыши. В таком случае доступна только та часть содержимого, которая видна в пределах родителя.
        
        // Масштабирование
        // Класс Viewbox относится к так называемым декораторам, то есть панелеподобным классам, у которых может быть только один дочерний элемент.
        // Но у него также имеется свойство Stretch, позволяющее указать, как в занимаемой области должен масштабироваться единственный дочерний элемент.
        // Это свойство имеет тип перечисления System.Windows.Media.Stretch и может принимать следующие значения:
        // - None – масштабирование не производится вовсе. Результат такой же, как если бы Viewbox вообще не было.
        // - Fill – размеры дочернего элемента устанавливаются такими же, как размеры самого Viewbox. Поэтому отношение сторон дочернего элемента может не сохраняться.
        // - Uniform – дочерний элемент масштабируется так, чтобы он целиком поместился внутри Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении останется пустое место. Этот вариант подразумевается по умолчанию.
        // - UniformToFill – дочерний элемент масштабируется так, чтобы он целиком заполнял Viewbox с сохранением отношения сторон. Поэтому, если отношения сторон Viewbox и дочернего элемента не совпадают, то в одном направлении содержимое будет отсечено.
        // Второе свойство Viewbox позволяет указать, какие операции разрешены: только уменьшение содержимого, только увеличение или и то и другое.
        // Оно называется StretchDirection, имеет тип перечисления System.Windows.Controls.StretchDirection и может принимать следующие значения:
        // - UpOnly – увеличивает содержимое, если необходимо. Если содержимое уже слишком велико, то Viewbox оставляет текущий размер без изменения.
        // - DownOnly – уменьшает содержимое, если необходимо. Если содержимое уже достаточно мало, то Viewbox оставляет текущий размер без изменения.
        // - Both – увеличивает или уменьшает содержимое в соответствии с заданным значением описанного выше свойства Stretch. Этот вариант подразумевается по умолчанию.

        // Все вместе: создание сворачиваемой, стыкуемой, изменяющей размер панели
        // Все три сетки помещены (куда бы вы думали?) в сетку с одной строкой и одним столбцом, чтобы они могли перекрывать друг друга и вместе с тем растягиваться, занимая все отведенное им место.
        // Z-порядок слоя 0 всегда наименьший, но Z-порядок двух остальных слоев может меняться так, чтобы текущая непристыкованная панель всегда была наверху.


        // 6 События ввода: клавиатура, мышь, стилус и мультисенсорные устройства
        // Маршрутизируемые события
        // - Tunneling – событие сначала возникает в корне дерева, а потом опускается вниз по дереву, заново возникая в каждом элементе на пути к источнику, включая его самого (если туннелирование не будет прервано по дороге в результате пометки события как обработанного)
        // - Bubbling – событие сначала возникает в элементе-источнике, а затем поднимается вверх по дереву, заново возникая в каждом элементе на пути к корню, включая сам корень (если всплытие не будет прервано по дороге в результате пометки события как обработанного)
        // - Direct – событие возникает только в элементе-источнике. Точно так же ведут себя обычные события .NET; различие лишь в том, что к маршрутизируемому событию применяются и другие механизмы, в частности триггеры событий
        // Сигнатуры обработчиков маршрутизируемых событий устроены так же, как сигнатуры всех обработчиков событий в .NET: первый параметр – объект типа System.Object, который обычно называют sender, второй – экземпляр класса, производного от System.EventArgs.
        // Параметр e является объектом класса RoutedEventArgs – подкласса EventArgs, обладающего следующими полезными свойствами:
        // - Source – элемент логического дерева, первоначально сгенерировавший событие.
        // - OriginalSource – элемент визуального дерева, первоначально сгенерировавший событие (например, в случае стандартной кнопки Button это будет дочерний элемент TextBlock или ButtonChrome). 
        // - Handled – булевский флаг, которому можно присвоить значение true и тем самым пометить, что событие обработано. Именно таким способом прерывается туннелирование и всплытие.
        // - RoutedEvent – сам объект маршрутизированного события (например, Button. ClickEvent), который может быть полезен для различения событий в случае, когда один и тот же обработчик используется для обработки разных событий.

        // Маршрутизируемые события в действии
        // Туннелируемые события легко распознать, потому что по принятому соглашению их имена начинаются со слова Preview. Такое событие – также по соглашению – генерируется непосредственно перед парным ему всплывающим.
        // Например, туннелируемое событие PreviewMouseMove генерируется перед всплывающим событием MouseMove.
        // Идея, стоящая за такими парами событий, заключается в том, чтобы дать элементам возможность отменить или иным способом модифицировать событие, которое еще только произойдет.
        // - Window не получает событие MouseRightButtonDown, если щелкнуть по любому элементу списка ListBoxItem. Дело в том, что ListBoxItem сам обрабатывает это событие, равно как и MouseLeftButtonDown (и прерывает всплытие), – это нужно ему для реализации выбора элементов.
        // - Window получает событие MouseRightButtonDown при щелчке по кнопке Button, но никаких изменений во внешнем виде рамкине происходит. Это объясняется структурой стандартного визуального дерева Button. В отличие от элементов Window, Label, ListBox, ListBoxItem и StatusBar, в визуальном дереве Button нет элемента Border.
        // Присоединенные события

        // Перетаскивание
        // Во всех подклассах UIElement определены события для работы с перетаскиванием:
        // - DragEnter, DragOver, DragLeave, а также PreviewDragEnter, PreviewDragOver и PreviewDragLeave
        // - Drop и PreviewDrop
        // - QueryContinueDrag и PreviewQueryContinueDrag
        // Это перетаскивание элемента в буфер обмена и бросание содержимого буфера на элемент в стиле Win32, а не перетаскивание и бросание самих элементов.
        // Элемент может принять участие в перетаскивании, установив значение true для свойства AllowDrop.
        // Обработчикам событий из первых двух наборов передается объект типа DragEventArgs, содержащий следующие свойства и методы:
        // - GetPosition – такой же метод, как в классе MouseEventArgs
        // - Data – свойство типа IDataObject, представляющее перетаскиваемый или бросаемый объект буфера обмена Win32
        // - Effects и AllowedEffects – битовое перечисление DragDropEffects, допускающее произвольную комбинацию флагов Copy, Move, Link, Scroll, All и None
        // - KeyStates – еще одно битовое перечисление (DragDropKeyStates), показывающее, какие кнопки мыши или клавиши-модификаторы были нажаты во время перетаскивания или бросания: LeftMouseButton, RightMouseButton, MiddleMouseButton, ShiftKey, ControlKey, AltKey или None
        // События QueryContinueDrag и PreviewQueryContinueDrag генерируются, если во время перетаскивания изменяется состояние клавиатуры или какой-нибудь кнопки мыши.
        // Это позволяет обработчику без труда отменить всю операцию.
        // Обработчикам этих событий передается объект класса QueryContinueDragEventArgs, имеющий следующие свойства:
        // - KeyStates – аналогично одноименному свойству класса DragEventArgs
        // - EscapePressed – отдельное булевское свойство, показывающее, была ли нажата клавиша Esc
        // Action – свойство, которое обработчик может установить, чтобы определить судьбу операции перетаскивания; принадлежит перечислению DragAction и принимает значение Continue, Drop или Cancel
        
        // Захват мыши
        // К счастью, WPF позволяет любому элементу UIElement в любой момент захватить или освободить мышь.
        // Когда элемент захватил мышь, он получает все события мыши, даже если указатель оказывается вне занимаемой им области.
        // После освобождения мыши поведение событий возвращается в нормальное русло. Для захвата и освобождения мыши предназначены два метода классаUIElement: CaptureMouse и ReleaseMouseCapture.
        // И, разумеется, есть ряд свойств и событий, сообщающих о состоянии захвата мыши, точнее, свойства IsMouseCaptured и IsMouseCaptureWithin и события GotMouseCapture, LostMouseCapture, IsMouseCaptureChanged и IsMouseCaptureWithinChanged.
        // Поэтому для реализации перетаскивания необходимо захватить мышь в обработчике MouseLeftButtonDown и освободить ее в обработчике MouseLeftButtonUp.

        // Команды
        // Мощь механизма команд основывается на трех основных особенностях:
        // - В WPF определено много встроенных команд.
        // - В команды встроена автоматическая поддержка жестов ввода (например, сочетаний клавиш).
        // - Встроенное поведение некоторых элементов управления WPF уже ориентировано на те или иные команды.

        // Встроенные команды
        // Командой называется любой объект, реализующий интерфейс ICommand (из пространства имен System.Windows.Input), в котором объявлены три простых члена:
        // - Execute – метод, который выполняет характерную для команды логику
        // - CanExecute – метод, который возвращает true, если команда активирована, и false, если она деактивирована
        // - CanExecuteChanged – событие, которое генерируется при изменении значения CanExecute
        // Встроенные в WPF команды доступны в виде статических свойств пяти разных классов:
        // - ApplicationCommands – Close, Copy, Cut, Delete, Find, Help, New, Open, Paste, Print,
        // PrintPreview, Properties, Redo, Replace, Save, SaveAs, SelectAll, Stop, Undo и др.
        // - ComponentCommands – MoveDown, MoveLeft, MoveRight, MoveUp, ScrollByLine, ScrollPageDown,
        // ScrollPageLeft, ScrollPageRight, ScrollPageUp, SelectToEnd, SelectToHome,
        // SelectToPageDown, SelectToPageUp и др.
        // - MediaCommands – ChannelDown, ChannelUp, DecreaseVolume, FastForward, IncreaseVolume,
        // MuteVolume, NextTrack, Pause, Play, PreviousTrack, Record, Rewind, Select, Stop и др.
        // - NavigationCommands – BrowseBack, BrowseForward, BrowseHome, BrowseStop, Favorites,
        // FirstPage, GoToPage, LastPage, NextPage, PreviousPage, Refresh, Search, Zoom и др.
        // - EditingCommands – AlignCenter, AlignJustify, AlignLeft, AlignRight, CorrectSpellingError,
        // DecreaseFontSize, DecreaseIndentation, EnterLineBreak, EnterParagraphBreak,
        // IgnoreSpellingError, IncreaseFontSize, IncreaseIndentation, MoveDownByLine,
        // MoveDownByPage, MoveDownByParagraph, MoveLeftByCharacter, MoveLeftByWord,
        // MoveRightByCharacter, MoveRightByWord и др.

        // Элементы управления со встроенными привязками к командам


        // !!!
        // продолжить разбор части 6
        // написать программу, используя материал с части 2.
    }
}
